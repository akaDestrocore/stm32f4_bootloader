# [doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "End of operation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eopr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: One or more Flash operations has/have completed successfully"] Active = 1 , } impl From < Eopr > for bool { # [inline (always)] fn from (variant : Eopr) -> Self { variant as u8 != 0 } } # [doc = "Field `EOP` reader - End of operation"] pub type EopR = crate :: BitReader < Eopr > ; impl EopR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eopr { match self . bits { false => Eopr :: Inactive , true => Eopr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Eopr :: Inactive } # [doc = "One or more Flash operations has/have completed successfully"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Eopr :: Active } } # [doc = "End of operation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum EopwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < EopwWO > for bool { # [inline (always)] fn from (variant : EopwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `EOP` writer - End of operation"] pub type EopW < 'a , REG > = crate :: BitWriter1C < 'a , REG , EopwWO > ; impl < 'a , REG > EopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (EopwWO :: Clear) } } # [doc = "Operation error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Operrr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: A Flash operation request is detected and cannot be run because of parallelism"] Active = 1 , } impl From < Operrr > for bool { # [inline (always)] fn from (variant : Operrr) -> Self { variant as u8 != 0 } } # [doc = "Field `OPERR` reader - Operation error"] pub type OperrR = crate :: BitReader < Operrr > ; impl OperrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Operrr { match self . bits { false => Operrr :: Inactive , true => Operrr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Operrr :: Inactive } # [doc = "A Flash operation request is detected and cannot be run because of parallelism"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Operrr :: Active } } # [doc = "Operation error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum OperrwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < OperrwWO > for bool { # [inline (always)] fn from (variant : OperrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `OPERR` writer - Operation error"] pub type OperrW < 'a , REG > = crate :: BitWriter1C < 'a , REG , OperrwWO > ; impl < 'a , REG > OperrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (OperrwWO :: Clear) } } # [doc = "Write protection error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wrperrr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: The address to be erased/programmed belongs to a write-protected part of the Flash memory"] Active = 1 , } impl From < Wrperrr > for bool { # [inline (always)] fn from (variant : Wrperrr) -> Self { variant as u8 != 0 } } # [doc = "Field `WRPERR` reader - Write protection error"] pub type WrperrR = crate :: BitReader < Wrperrr > ; impl WrperrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wrperrr { match self . bits { false => Wrperrr :: Inactive , true => Wrperrr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Wrperrr :: Inactive } # [doc = "The address to be erased/programmed belongs to a write-protected part of the Flash memory"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Wrperrr :: Active } } # [doc = "Write protection error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum WrperrwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < WrperrwWO > for bool { # [inline (always)] fn from (variant : WrperrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `WRPERR` writer - Write protection error"] pub type WrperrW < 'a , REG > = crate :: BitWriter1C < 'a , REG , WrperrwWO > ; impl < 'a , REG > WrperrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (WrperrwWO :: Clear) } } # [doc = "Programming alignment error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pgaerrr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: The data to program cannot be contained in the same 128-bit Flash memory row"] Active = 1 , } impl From < Pgaerrr > for bool { # [inline (always)] fn from (variant : Pgaerrr) -> Self { variant as u8 != 0 } } # [doc = "Field `PGAERR` reader - Programming alignment error"] pub type PgaerrR = crate :: BitReader < Pgaerrr > ; impl PgaerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pgaerrr { match self . bits { false => Pgaerrr :: Inactive , true => Pgaerrr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Pgaerrr :: Inactive } # [doc = "The data to program cannot be contained in the same 128-bit Flash memory row"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Pgaerrr :: Active } } # [doc = "Programming alignment error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PgaerrwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < PgaerrwWO > for bool { # [inline (always)] fn from (variant : PgaerrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PGAERR` writer - Programming alignment error"] pub type PgaerrW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PgaerrwWO > ; impl < 'a , REG > PgaerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (PgaerrwWO :: Clear) } } # [doc = "Programming parallelism error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pgperrr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: The size of the access during the program sequence doesn't correspond to the parallelism configuration PSIZE"] Active = 1 , } impl From < Pgperrr > for bool { # [inline (always)] fn from (variant : Pgperrr) -> Self { variant as u8 != 0 } } # [doc = "Field `PGPERR` reader - Programming parallelism error"] pub type PgperrR = crate :: BitReader < Pgperrr > ; impl PgperrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pgperrr { match self . bits { false => Pgperrr :: Inactive , true => Pgperrr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Pgperrr :: Inactive } # [doc = "The size of the access during the program sequence doesn't correspond to the parallelism configuration PSIZE"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Pgperrr :: Active } } # [doc = "Programming parallelism error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PgperrwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < PgperrwWO > for bool { # [inline (always)] fn from (variant : PgperrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PGPERR` writer - Programming parallelism error"] pub type PgperrW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PgperrwWO > ; impl < 'a , REG > PgperrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (PgperrwWO :: Clear) } } # [doc = "Programming sequence error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pgserrr { # [doc = "0: No error"] Inactive = 0 , # [doc = "1: A write access to the Flash memory is performed by the code while the control register has not been correctly configured"] Active = 1 , } impl From < Pgserrr > for bool { # [inline (always)] fn from (variant : Pgserrr) -> Self { variant as u8 != 0 } } # [doc = "Field `PGSERR` reader - Programming sequence error"] pub type PgserrR = crate :: BitReader < Pgserrr > ; impl PgserrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pgserrr { match self . bits { false => Pgserrr :: Inactive , true => Pgserrr :: Active , } } # [doc = "No error"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == Pgserrr :: Inactive } # [doc = "A write access to the Flash memory is performed by the code while the control register has not been correctly configured"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Pgserrr :: Active } } # [doc = "Programming sequence error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PgserrwWO { # [doc = "1: Clear error flag"] Clear = 1 , } impl From < PgserrwWO > for bool { # [inline (always)] fn from (variant : PgserrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PGSERR` writer - Programming sequence error"] pub type PgserrW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PgserrwWO > ; impl < 'a , REG > PgserrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear error flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (PgserrwWO :: Clear) } } # [doc = "Busy\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bsyr { # [doc = "0: No Flash memory operation ongoing"] NotBusy = 0 , # [doc = "1: Flash memory operation ongoing"] Busy = 1 , } impl From < Bsyr > for bool { # [inline (always)] fn from (variant : Bsyr) -> Self { variant as u8 != 0 } } # [doc = "Field `BSY` reader - Busy"] pub type BsyR = crate :: BitReader < Bsyr > ; impl BsyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bsyr { match self . bits { false => Bsyr :: NotBusy , true => Bsyr :: Busy , } } # [doc = "No Flash memory operation ongoing"] # [inline (always)] pub fn is_not_busy (& self) -> bool { * self == Bsyr :: NotBusy } # [doc = "Flash memory operation ongoing"] # [inline (always)] pub fn is_busy (& self) -> bool { * self == Bsyr :: Busy } } impl R { # [doc = "Bit 0 - End of operation"] # [inline (always)] pub fn eop (& self) -> EopR { EopR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Operation error"] # [inline (always)] pub fn operr (& self) -> OperrR { OperrR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Write protection error"] # [inline (always)] pub fn wrperr (& self) -> WrperrR { WrperrR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Programming alignment error"] # [inline (always)] pub fn pgaerr (& self) -> PgaerrR { PgaerrR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Programming parallelism error"] # [inline (always)] pub fn pgperr (& self) -> PgperrR { PgperrR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Programming sequence error"] # [inline (always)] pub fn pgserr (& self) -> PgserrR { PgserrR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 16 - Busy"] # [inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 16) & 1) != 0) } } impl W { # [doc = "Bit 0 - End of operation"] # [inline (always)] pub fn eop (& mut self) -> EopW < SrSpec > { EopW :: new (self , 0) } # [doc = "Bit 1 - Operation error"] # [inline (always)] pub fn operr (& mut self) -> OperrW < SrSpec > { OperrW :: new (self , 1) } # [doc = "Bit 4 - Write protection error"] # [inline (always)] pub fn wrperr (& mut self) -> WrperrW < SrSpec > { WrperrW :: new (self , 4) } # [doc = "Bit 5 - Programming alignment error"] # [inline (always)] pub fn pgaerr (& mut self) -> PgaerrW < SrSpec > { PgaerrW :: new (self , 5) } # [doc = "Bit 6 - Programming parallelism error"] # [inline (always)] pub fn pgperr (& mut self) -> PgperrW < SrSpec > { PgperrW :: new (self , 6) } # [doc = "Bit 7 - Programming sequence error"] # [inline (always)] pub fn pgserr (& mut self) -> PgserrW < SrSpec > { PgserrW :: new (self , 7) } } # [doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xf3 ; } # [doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { }
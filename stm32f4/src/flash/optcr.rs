# [doc = "Register `OPTCR` reader"] pub type R = crate :: R < OptcrSpec > ; # [doc = "Register `OPTCR` writer"] pub type W = crate :: W < OptcrSpec > ; # [doc = "Option lock\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Optlockr { # [doc = "0: The write and erase operations in the Option bytes area are disabled"] Unlocked = 0 , # [doc = "1: The write and erase operations in the Option bytes area are enabled"] Locked = 1 , } impl From < Optlockr > for bool { # [inline (always)] fn from (variant : Optlockr) -> Self { variant as u8 != 0 } } # [doc = "Field `OPTLOCK` reader - Option lock"] pub type OptlockR = crate :: BitReader < Optlockr > ; impl OptlockR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Optlockr { match self . bits { false => Optlockr :: Unlocked , true => Optlockr :: Locked , } } # [doc = "The write and erase operations in the Option bytes area are disabled"] # [inline (always)] pub fn is_unlocked (& self) -> bool { * self == Optlockr :: Unlocked } # [doc = "The write and erase operations in the Option bytes area are enabled"] # [inline (always)] pub fn is_locked (& self) -> bool { * self == Optlockr :: Locked } } # [doc = "Option lock\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum OptlockwWO { # [doc = "1: Lock the FLASH_OPTCR register"] Set = 1 , } impl From < OptlockwWO > for bool { # [inline (always)] fn from (variant : OptlockwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `OPTLOCK` writer - Option lock"] pub type OptlockW < 'a , REG > = crate :: BitWriter < 'a , REG , OptlockwWO > ; impl < 'a , REG > OptlockW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Lock the FLASH_OPTCR register"] # [inline (always)] pub fn set_ (self) -> & 'a mut crate :: W < REG > { self . variant (OptlockwWO :: Set) } } # [doc = "Option start\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Optstrtr { # [doc = "0: Cleared when BSY bit is cleared in SR"] Complete = 0 , # [doc = "1: Options modification requested"] Requested = 1 , } impl From < Optstrtr > for bool { # [inline (always)] fn from (variant : Optstrtr) -> Self { variant as u8 != 0 } } # [doc = "Field `OPTSTRT` reader - Option start"] pub type OptstrtR = crate :: BitReader < Optstrtr > ; impl OptstrtR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Optstrtr { match self . bits { false => Optstrtr :: Complete , true => Optstrtr :: Requested , } } # [doc = "Cleared when BSY bit is cleared in SR"] # [inline (always)] pub fn is_complete (& self) -> bool { * self == Optstrtr :: Complete } # [doc = "Options modification requested"] # [inline (always)] pub fn is_requested (& self) -> bool { * self == Optstrtr :: Requested } } # [doc = "Option start\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum OptstrtwWO { # [doc = "1: This bit triggers an options operation when set"] Set = 1 , } impl From < OptstrtwWO > for bool { # [inline (always)] fn from (variant : OptstrtwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `OPTSTRT` writer - Option start"] pub type OptstrtW < 'a , REG > = crate :: BitWriter < 'a , REG , OptstrtwWO > ; impl < 'a , REG > OptstrtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "This bit triggers an options operation when set"] # [inline (always)] pub fn set_ (self) -> & 'a mut crate :: W < REG > { self . variant (OptstrtwWO :: Set) } } # [doc = "BOR reset Level\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum BorLev { # [doc = "0: Reset threshold level for POR/PDR (around 1.7V)"] BorOff = 0 , # [doc = "1: Reset threshold level for VBOR1 (around 2.2 V)"] BorLevel1 = 1 , # [doc = "2: Reset threshold level for VBOR2 (around 2.5 V)"] BorLevel2 = 2 , # [doc = "3: Reset threshold level for VBOR3 (around 2.8 V)"] BorLevel3 = 3 , } impl From < BorLev > for u8 { # [inline (always)] fn from (variant : BorLev) -> Self { variant as _ } } impl crate :: FieldSpec for BorLev { type Ux = u8 ; } impl crate :: IsEnum for BorLev { } # [doc = "Field `BOR_LEV` reader - BOR reset Level"] pub type BorLevR = crate :: FieldReader < BorLev > ; impl BorLevR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> BorLev { match self . bits { 0 => BorLev :: BorOff , 1 => BorLev :: BorLevel1 , 2 => BorLev :: BorLevel2 , 3 => BorLev :: BorLevel3 , _ => unreachable ! () , } } # [doc = "Reset threshold level for POR/PDR (around 1.7V)"] # [inline (always)] pub fn is_bor_off (& self) -> bool { * self == BorLev :: BorOff } # [doc = "Reset threshold level for VBOR1 (around 2.2 V)"] # [inline (always)] pub fn is_bor_level1 (& self) -> bool { * self == BorLev :: BorLevel1 } # [doc = "Reset threshold level for VBOR2 (around 2.5 V)"] # [inline (always)] pub fn is_bor_level2 (& self) -> bool { * self == BorLev :: BorLevel2 } # [doc = "Reset threshold level for VBOR3 (around 2.8 V)"] # [inline (always)] pub fn is_bor_level3 (& self) -> bool { * self == BorLev :: BorLevel3 } } # [doc = "Field `BOR_LEV` writer - BOR reset Level"] pub type BorLevW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , BorLev , crate :: Safe > ; impl < 'a , REG > BorLevW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Reset threshold level for POR/PDR (around 1.7V)"] # [inline (always)] pub fn bor_off (self) -> & 'a mut crate :: W < REG > { self . variant (BorLev :: BorOff) } # [doc = "Reset threshold level for VBOR1 (around 2.2 V)"] # [inline (always)] pub fn bor_level1 (self) -> & 'a mut crate :: W < REG > { self . variant (BorLev :: BorLevel1) } # [doc = "Reset threshold level for VBOR2 (around 2.5 V)"] # [inline (always)] pub fn bor_level2 (self) -> & 'a mut crate :: W < REG > { self . variant (BorLev :: BorLevel2) } # [doc = "Reset threshold level for VBOR3 (around 2.8 V)"] # [inline (always)] pub fn bor_level3 (self) -> & 'a mut crate :: W < REG > { self . variant (BorLev :: BorLevel3) } } # [doc = "WDG_SW User option bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum WdgSw { # [doc = "0: Hardware watchdog"] Hardware = 0 , # [doc = "1: Software watchdog"] Software = 1 , } impl From < WdgSw > for bool { # [inline (always)] fn from (variant : WdgSw) -> Self { variant as u8 != 0 } } # [doc = "Field `WDG_SW` reader - WDG_SW User option bytes"] pub type WdgSwR = crate :: BitReader < WdgSw > ; impl WdgSwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> WdgSw { match self . bits { false => WdgSw :: Hardware , true => WdgSw :: Software , } } # [doc = "Hardware watchdog"] # [inline (always)] pub fn is_hardware (& self) -> bool { * self == WdgSw :: Hardware } # [doc = "Software watchdog"] # [inline (always)] pub fn is_software (& self) -> bool { * self == WdgSw :: Software } } # [doc = "Field `WDG_SW` writer - WDG_SW User option bytes"] pub type WdgSwW < 'a , REG > = crate :: BitWriter < 'a , REG , WdgSw > ; impl < 'a , REG > WdgSwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Hardware watchdog"] # [inline (always)] pub fn hardware (self) -> & 'a mut crate :: W < REG > { self . variant (WdgSw :: Hardware) } # [doc = "Software watchdog"] # [inline (always)] pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (WdgSw :: Software) } } # [doc = "nRST_STOP User option bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum NRstStop { # [doc = "0: Reset generated when entering Stop mode"] Reset = 0 , # [doc = "1: No reset generated"] NoReset = 1 , } impl From < NRstStop > for bool { # [inline (always)] fn from (variant : NRstStop) -> Self { variant as u8 != 0 } } # [doc = "Field `nRST_STOP` reader - nRST_STOP User option bytes"] pub type NRstStopR = crate :: BitReader < NRstStop > ; impl NRstStopR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> NRstStop { match self . bits { false => NRstStop :: Reset , true => NRstStop :: NoReset , } } # [doc = "Reset generated when entering Stop mode"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == NRstStop :: Reset } # [doc = "No reset generated"] # [inline (always)] pub fn is_no_reset (& self) -> bool { * self == NRstStop :: NoReset } } # [doc = "Field `nRST_STOP` writer - nRST_STOP User option bytes"] pub type NRstStopW < 'a , REG > = crate :: BitWriter < 'a , REG , NRstStop > ; impl < 'a , REG > NRstStopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Reset generated when entering Stop mode"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (NRstStop :: Reset) } # [doc = "No reset generated"] # [inline (always)] pub fn no_reset (self) -> & 'a mut crate :: W < REG > { self . variant (NRstStop :: NoReset) } } # [doc = "nRST_STDBY User option bytes\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum NRstStdby { # [doc = "0: Reset generated when entering Standby mode"] Reset = 0 , # [doc = "1: No reset generated"] NoReset = 1 , } impl From < NRstStdby > for bool { # [inline (always)] fn from (variant : NRstStdby) -> Self { variant as u8 != 0 } } # [doc = "Field `nRST_STDBY` reader - nRST_STDBY User option bytes"] pub type NRstStdbyR = crate :: BitReader < NRstStdby > ; impl NRstStdbyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> NRstStdby { match self . bits { false => NRstStdby :: Reset , true => NRstStdby :: NoReset , } } # [doc = "Reset generated when entering Standby mode"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == NRstStdby :: Reset } # [doc = "No reset generated"] # [inline (always)] pub fn is_no_reset (& self) -> bool { * self == NRstStdby :: NoReset } } # [doc = "Field `nRST_STDBY` writer - nRST_STDBY User option bytes"] pub type NRstStdbyW < 'a , REG > = crate :: BitWriter < 'a , REG , NRstStdby > ; impl < 'a , REG > NRstStdbyW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Reset generated when entering Standby mode"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (NRstStdby :: Reset) } # [doc = "No reset generated"] # [inline (always)] pub fn no_reset (self) -> & 'a mut crate :: W < REG > { self . variant (NRstStdby :: NoReset) } } # [doc = "Read protect\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Rdp { # [doc = "170: Read protection not active"] Level0 = 170 , # [doc = "204: Chip read protection active"] Level2 = 204 , # [doc = "0: Read protection of memories active"] Level1 = 0 , } impl From < Rdp > for u8 { # [inline (always)] fn from (variant : Rdp) -> Self { variant as _ } } impl crate :: FieldSpec for Rdp { type Ux = u8 ; } impl crate :: IsEnum for Rdp { } # [doc = "Field `RDP` reader - Read protect"] pub type RdpR = crate :: FieldReader < Rdp > ; impl RdpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rdp { match self . bits { 170 => Rdp :: Level0 , 204 => Rdp :: Level2 , _ => Rdp :: Level1 , } } # [doc = "Read protection not active"] # [inline (always)] pub fn is_level0 (& self) -> bool { * self == Rdp :: Level0 } # [doc = "Chip read protection active"] # [inline (always)] pub fn is_level2 (& self) -> bool { * self == Rdp :: Level2 } # [doc = "Read protection of memories active"] # [inline (always)] pub fn is_level1 (& self) -> bool { matches ! (self . variant () , Rdp :: Level1) } } # [doc = "Field `RDP` writer - Read protect"] pub type RdpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 , Rdp , crate :: Safe > ; impl < 'a , REG > RdpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Read protection not active"] # [inline (always)] pub fn level0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Level0) } # [doc = "Chip read protection active"] # [inline (always)] pub fn level2 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Level2) } # [doc = "Read protection of memories active"] # [inline (always)] pub fn level1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Level1) } } # [doc = "Not write protect\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum NWrp0 { # [doc = "0: Write protection active on sector %s"] Active = 0 , # [doc = "1: Write protection inactive on sector %s"] Inactive = 1 , } impl From < NWrp0 > for bool { # [inline (always)] fn from (variant : NWrp0) -> Self { variant as u8 != 0 } } # [doc = "Field `nWRP(0-11)` reader - Not write protect"] pub type NWrpR = crate :: BitReader < NWrp0 > ; impl NWrpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> NWrp0 { match self . bits { false => NWrp0 :: Active , true => NWrp0 :: Inactive , } } # [doc = "Write protection active on sector %s"] # [inline (always)] pub fn is_active (& self) -> bool { * self == NWrp0 :: Active } # [doc = "Write protection inactive on sector %s"] # [inline (always)] pub fn is_inactive (& self) -> bool { * self == NWrp0 :: Inactive } } # [doc = "Field `nWRP(0-11)` writer - Not write protect"] pub type NWrpW < 'a , REG > = crate :: BitWriter < 'a , REG , NWrp0 > ; impl < 'a , REG > NWrpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Write protection active on sector %s"] # [inline (always)] pub fn active (self) -> & 'a mut crate :: W < REG > { self . variant (NWrp0 :: Active) } # [doc = "Write protection inactive on sector %s"] # [inline (always)] pub fn inactive (self) -> & 'a mut crate :: W < REG > { self . variant (NWrp0 :: Inactive) } } impl R { # [doc = "Bit 0 - Option lock"] # [inline (always)] pub fn optlock (& self) -> OptlockR { OptlockR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Option start"] # [inline (always)] pub fn optstrt (& self) -> OptstrtR { OptstrtR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - BOR reset Level"] # [inline (always)] pub fn bor_lev (& self) -> BorLevR { BorLevR :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 5 - WDG_SW User option bytes"] # [inline (always)] pub fn wdg_sw (& self) -> WdgSwR { WdgSwR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - nRST_STOP User option bytes"] # [inline (always)] pub fn n_rst_stop (& self) -> NRstStopR { NRstStopR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - nRST_STDBY User option bytes"] # [inline (always)] pub fn n_rst_stdby (& self) -> NRstStdbyR { NRstStdbyR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:15 - Read protect"] # [inline (always)] pub fn rdp (& self) -> RdpR { RdpR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Not write protect"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `nWRP0` field.</div>"] # [inline (always)] pub fn n_wrp (& self , n : u8) -> NWrpR { # [allow (clippy :: no_effect)] [() ; 12] [n as usize] ; NWrpR :: new (((self . bits >> (n + 16)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Not write protect"] # [inline (always)] pub fn n_wrp_iter (& self) -> impl Iterator < Item = NWrpR > + '_ { (0 .. 12) . map (move | n | NWrpR :: new (((self . bits >> (n + 16)) & 1) != 0)) } # [doc = "Bit 16 - Not write protect"] # [inline (always)] pub fn n_wrp0 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Not write protect"] # [inline (always)] pub fn n_wrp1 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Not write protect"] # [inline (always)] pub fn n_wrp2 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Not write protect"] # [inline (always)] pub fn n_wrp3 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Not write protect"] # [inline (always)] pub fn n_wrp4 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Not write protect"] # [inline (always)] pub fn n_wrp5 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Not write protect"] # [inline (always)] pub fn n_wrp6 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Not write protect"] # [inline (always)] pub fn n_wrp7 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Not write protect"] # [inline (always)] pub fn n_wrp8 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Not write protect"] # [inline (always)] pub fn n_wrp9 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Not write protect"] # [inline (always)] pub fn n_wrp10 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Not write protect"] # [inline (always)] pub fn n_wrp11 (& self) -> NWrpR { NWrpR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Option lock"] # [inline (always)] pub fn optlock (& mut self) -> OptlockW < OptcrSpec > { OptlockW :: new (self , 0) } # [doc = "Bit 1 - Option start"] # [inline (always)] pub fn optstrt (& mut self) -> OptstrtW < OptcrSpec > { OptstrtW :: new (self , 1) } # [doc = "Bits 2:3 - BOR reset Level"] # [inline (always)] pub fn bor_lev (& mut self) -> BorLevW < OptcrSpec > { BorLevW :: new (self , 2) } # [doc = "Bit 5 - WDG_SW User option bytes"] # [inline (always)] pub fn wdg_sw (& mut self) -> WdgSwW < OptcrSpec > { WdgSwW :: new (self , 5) } # [doc = "Bit 6 - nRST_STOP User option bytes"] # [inline (always)] pub fn n_rst_stop (& mut self) -> NRstStopW < OptcrSpec > { NRstStopW :: new (self , 6) } # [doc = "Bit 7 - nRST_STDBY User option bytes"] # [inline (always)] pub fn n_rst_stdby (& mut self) -> NRstStdbyW < OptcrSpec > { NRstStdbyW :: new (self , 7) } # [doc = "Bits 8:15 - Read protect"] # [inline (always)] pub fn rdp (& mut self) -> RdpW < OptcrSpec > { RdpW :: new (self , 8) } # [doc = "Not write protect"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `nWRP0` field.</div>"] # [inline (always)] pub fn n_wrp (& mut self , n : u8) -> NWrpW < OptcrSpec > { # [allow (clippy :: no_effect)] [() ; 12] [n as usize] ; NWrpW :: new (self , n + 16) } # [doc = "Bit 16 - Not write protect"] # [inline (always)] pub fn n_wrp0 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 16) } # [doc = "Bit 17 - Not write protect"] # [inline (always)] pub fn n_wrp1 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 17) } # [doc = "Bit 18 - Not write protect"] # [inline (always)] pub fn n_wrp2 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 18) } # [doc = "Bit 19 - Not write protect"] # [inline (always)] pub fn n_wrp3 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 19) } # [doc = "Bit 20 - Not write protect"] # [inline (always)] pub fn n_wrp4 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 20) } # [doc = "Bit 21 - Not write protect"] # [inline (always)] pub fn n_wrp5 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 21) } # [doc = "Bit 22 - Not write protect"] # [inline (always)] pub fn n_wrp6 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 22) } # [doc = "Bit 23 - Not write protect"] # [inline (always)] pub fn n_wrp7 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 23) } # [doc = "Bit 24 - Not write protect"] # [inline (always)] pub fn n_wrp8 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 24) } # [doc = "Bit 25 - Not write protect"] # [inline (always)] pub fn n_wrp9 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 25) } # [doc = "Bit 26 - Not write protect"] # [inline (always)] pub fn n_wrp10 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 26) } # [doc = "Bit 27 - Not write protect"] # [inline (always)] pub fn n_wrp11 (& mut self) -> NWrpW < OptcrSpec > { NWrpW :: new (self , 27) } } # [doc = "Flash option control register\n\nYou can [`read`](crate::Reg::read) this register and get [`optcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OptcrSpec ; impl crate :: RegisterSpec for OptcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`optcr::R`](R) reader structure"] impl crate :: Readable for OptcrSpec { } # [doc = "`write(|w| ..)` method takes [`optcr::W`](W) writer structure"] impl crate :: Writable for OptcrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets OPTCR to value 0x14"] impl crate :: Resettable for OptcrSpec { const RESET_VALUE : u32 = 0x14 ; }
# ! [doc = "Peripheral access API for STM32F407 microcontrollers (generated using svd2rust v0.36.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))] # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)] use generic :: * ; # [doc = "Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { fn WWDG () ; fn PVD () ; fn TAMP_STAMP () ; fn RTC_WKUP () ; fn RCC () ; fn EXTI0 () ; fn EXTI1 () ; fn EXTI2 () ; fn EXTI3 () ; fn EXTI4 () ; fn DMA1_Stream0 () ; fn DMA1_Stream1 () ; fn DMA1_Stream2 () ; fn DMA1_Stream3 () ; fn DMA1_Stream4 () ; fn DMA1_Stream5 () ; fn DMA1_Stream6 () ; fn ADC () ; fn CAN1_TX () ; fn CAN1_RX0 () ; fn CAN1_RX1 () ; fn CAN1_SCE () ; fn EXTI9_5 () ; fn TIM1_BRK_TIM9 () ; fn TIM1_UP_TIM10 () ; fn TIM1_TRG_COM_TIM11 () ; fn TIM1_CC () ; fn TIM2 () ; fn TIM3 () ; fn TIM4 () ; fn I2C1_EV () ; fn I2C1_ER () ; fn I2C2_EV () ; fn I2C2_ER () ; fn SPI1 () ; fn SPI2 () ; fn USART1 () ; fn USART2 () ; fn USART3 () ; fn EXTI15_10 () ; fn RTC_Alarm () ; fn OTG_FS_WKUP () ; fn TIM8_BRK_TIM12 () ; fn TIM8_UP_TIM13 () ; fn TIM8_TRG_COM_TIM14 () ; fn TIM8_CC () ; fn DMA1_Stream7 () ; fn FSMC () ; fn SDIO () ; fn TIM5 () ; fn SPI3 () ; fn UART4 () ; fn UART5 () ; fn TIM6_DAC () ; fn TIM7 () ; fn DMA2_Stream0 () ; fn DMA2_Stream1 () ; fn DMA2_Stream2 () ; fn DMA2_Stream3 () ; fn DMA2_Stream4 () ; fn ETH () ; fn ETH_WKUP () ; fn CAN2_TX () ; fn CAN2_RX0 () ; fn CAN2_RX1 () ; fn CAN2_SCE () ; fn OTG_FS () ; fn DMA2_Stream5 () ; fn DMA2_Stream6 () ; fn DMA2_Stream7 () ; fn USART6 () ; fn I2C3_EV () ; fn I2C3_ER () ; fn OTG_HS_EP1_OUT () ; fn OTG_HS_EP1_IN () ; fn OTG_HS_WKUP () ; fn OTG_HS () ; fn DCMI () ; fn CRYP () ; fn HASH_RNG () ; fn FPU () ; } # [doc (hidden)] # [repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] # [link_section = ".vector_table.interrupts"] # [no_mangle] pub static __INTERRUPTS : [Vector ; 82] = [Vector { _handler : WWDG } , Vector { _handler : PVD } , Vector { _handler : TAMP_STAMP } , Vector { _handler : RTC_WKUP } , Vector { _reserved : 0 } , Vector { _handler : RCC } , Vector { _handler : EXTI0 } , Vector { _handler : EXTI1 } , Vector { _handler : EXTI2 } , Vector { _handler : EXTI3 } , Vector { _handler : EXTI4 } , Vector { _handler : DMA1_Stream0 } , Vector { _handler : DMA1_Stream1 } , Vector { _handler : DMA1_Stream2 } , Vector { _handler : DMA1_Stream3 } , Vector { _handler : DMA1_Stream4 } , Vector { _handler : DMA1_Stream5 } , Vector { _handler : DMA1_Stream6 } , Vector { _handler : ADC } , Vector { _handler : CAN1_TX } , Vector { _handler : CAN1_RX0 } , Vector { _handler : CAN1_RX1 } , Vector { _handler : CAN1_SCE } , Vector { _handler : EXTI9_5 } , Vector { _handler : TIM1_BRK_TIM9 } , Vector { _handler : TIM1_UP_TIM10 } , Vector { _handler : TIM1_TRG_COM_TIM11 } , Vector { _handler : TIM1_CC } , Vector { _handler : TIM2 } , Vector { _handler : TIM3 } , Vector { _handler : TIM4 } , Vector { _handler : I2C1_EV } , Vector { _handler : I2C1_ER } , Vector { _handler : I2C2_EV } , Vector { _handler : I2C2_ER } , Vector { _handler : SPI1 } , Vector { _handler : SPI2 } , Vector { _handler : USART1 } , Vector { _handler : USART2 } , Vector { _handler : USART3 } , Vector { _handler : EXTI15_10 } , Vector { _handler : RTC_Alarm } , Vector { _handler : OTG_FS_WKUP } , Vector { _handler : TIM8_BRK_TIM12 } , Vector { _handler : TIM8_UP_TIM13 } , Vector { _handler : TIM8_TRG_COM_TIM14 } , Vector { _handler : TIM8_CC } , Vector { _handler : DMA1_Stream7 } , Vector { _handler : FSMC } , Vector { _handler : SDIO } , Vector { _handler : TIM5 } , Vector { _handler : SPI3 } , Vector { _handler : UART4 } , Vector { _handler : UART5 } , Vector { _handler : TIM6_DAC } , Vector { _handler : TIM7 } , Vector { _handler : DMA2_Stream0 } , Vector { _handler : DMA2_Stream1 } , Vector { _handler : DMA2_Stream2 } , Vector { _handler : DMA2_Stream3 } , Vector { _handler : DMA2_Stream4 } , Vector { _handler : ETH } , Vector { _handler : ETH_WKUP } , Vector { _handler : CAN2_TX } , Vector { _handler : CAN2_RX0 } , Vector { _handler : CAN2_RX1 } , Vector { _handler : CAN2_SCE } , Vector { _handler : OTG_FS } , Vector { _handler : DMA2_Stream5 } , Vector { _handler : DMA2_Stream6 } , Vector { _handler : DMA2_Stream7 } , Vector { _handler : USART6 } , Vector { _handler : I2C3_EV } , Vector { _handler : I2C3_ER } , Vector { _handler : OTG_HS_EP1_OUT } , Vector { _handler : OTG_HS_EP1_IN } , Vector { _handler : OTG_HS_WKUP } , Vector { _handler : OTG_HS } , Vector { _handler : DCMI } , Vector { _handler : CRYP } , Vector { _handler : HASH_RNG } , Vector { _handler : FPU } ,] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [repr (u16)] pub enum Interrupt { # [doc = "0 - Window Watchdog interrupt"] WWDG = 0 , # [doc = "1 - PVD through EXTI line detection interrupt"] PVD = 1 , # [doc = "2 - Tamper and TimeStamp interrupts through the EXTI line"] TAMP_STAMP = 2 , # [doc = "3 - RTC Wakeup interrupt through the EXTI line"] RTC_WKUP = 3 , # [doc = "5 - RCC global interrupt"] RCC = 5 , # [doc = "6 - EXTI Line0 interrupt"] EXTI0 = 6 , # [doc = "7 - EXTI Line1 interrupt"] EXTI1 = 7 , # [doc = "8 - EXTI Line2 interrupt"] EXTI2 = 8 , # [doc = "9 - EXTI Line3 interrupt"] EXTI3 = 9 , # [doc = "10 - EXTI Line4 interrupt"] EXTI4 = 10 , # [doc = "11 - DMA1 Stream0 global interrupt"] DMA1_Stream0 = 11 , # [doc = "12 - DMA1 Stream1 global interrupt"] DMA1_Stream1 = 12 , # [doc = "13 - DMA1 Stream2 global interrupt"] DMA1_Stream2 = 13 , # [doc = "14 - DMA1 Stream3 global interrupt"] DMA1_Stream3 = 14 , # [doc = "15 - DMA1 Stream4 global interrupt"] DMA1_Stream4 = 15 , # [doc = "16 - DMA1 Stream5 global interrupt"] DMA1_Stream5 = 16 , # [doc = "17 - DMA1 Stream6 global interrupt"] DMA1_Stream6 = 17 , # [doc = "18 - ADC1, ADC2 and ADC3 global interrupts"] ADC = 18 , # [doc = "19 - CAN1 TX interrupts"] CAN1_TX = 19 , # [doc = "20 - CAN1 RX0 interrupts"] CAN1_RX0 = 20 , # [doc = "21 - CAN1 RX1 interrupts"] CAN1_RX1 = 21 , # [doc = "22 - CAN1 SCE interrupt"] CAN1_SCE = 22 , # [doc = "23 - EXTI Line\\[9:5\\] interrupts"] EXTI9_5 = 23 , # [doc = "24 - TIM1 Break interrupt and TIM9 global interrupt"] TIM1_BRK_TIM9 = 24 , # [doc = "25 - TIM1 Update interrupt and TIM10 global interrupt"] TIM1_UP_TIM10 = 25 , # [doc = "26 - TIM1 Trigger and Commutation interrupts and TIM11 global interrupt"] TIM1_TRG_COM_TIM11 = 26 , # [doc = "27 - TIM1 Capture Compare interrupt"] TIM1_CC = 27 , # [doc = "28 - TIM2 global interrupt"] TIM2 = 28 , # [doc = "29 - TIM3 global interrupt"] TIM3 = 29 , # [doc = "30 - TIM4 global interrupt"] TIM4 = 30 , # [doc = "31 - I2C1 event interrupt"] I2C1_EV = 31 , # [doc = "32 - I2C1 error interrupt"] I2C1_ER = 32 , # [doc = "33 - I2C2 event interrupt"] I2C2_EV = 33 , # [doc = "34 - I2C2 error interrupt"] I2C2_ER = 34 , # [doc = "35 - SPI1 global interrupt"] SPI1 = 35 , # [doc = "36 - SPI2 global interrupt"] SPI2 = 36 , # [doc = "37 - USART1 global interrupt"] USART1 = 37 , # [doc = "38 - USART2 global interrupt"] USART2 = 38 , # [doc = "39 - USART3 global interrupt"] USART3 = 39 , # [doc = "40 - EXTI Line\\[15:10\\] interrupts"] EXTI15_10 = 40 , # [doc = "41 - RTC Alarms (A and B) through EXTI line interrupt"] RTC_Alarm = 41 , # [doc = "42 - USB On-The-Go FS Wakeup through EXTI line interrupt"] OTG_FS_WKUP = 42 , # [doc = "43 - TIM8 Break interrupt and TIM12 global interrupt"] TIM8_BRK_TIM12 = 43 , # [doc = "44 - TIM8 Update interrupt and TIM13 global interrupt"] TIM8_UP_TIM13 = 44 , # [doc = "45 - TIM8 Trigger and Commutation interrupts and TIM14 global interrupt"] TIM8_TRG_COM_TIM14 = 45 , # [doc = "46 - TIM8 Capture Compare interrupt"] TIM8_CC = 46 , # [doc = "47 - DMA1 Stream7 global interrupt"] DMA1_Stream7 = 47 , # [doc = "48 - FSMC global interrupt"] FSMC = 48 , # [doc = "49 - SDIO global interrupt"] SDIO = 49 , # [doc = "50 - TIM5 global interrupt"] TIM5 = 50 , # [doc = "51 - SPI3 global interrupt"] SPI3 = 51 , # [doc = "52 - UART4 global interrupt"] UART4 = 52 , # [doc = "53 - UART5 global interrupt"] UART5 = 53 , # [doc = "54 - TIM6 global interrupt, DAC1 and DAC2 underrun error interrupt"] TIM6_DAC = 54 , # [doc = "55 - TIM7 global interrupt"] TIM7 = 55 , # [doc = "56 - DMA2 Stream0 global interrupt"] DMA2_Stream0 = 56 , # [doc = "57 - DMA2 Stream1 global interrupt"] DMA2_Stream1 = 57 , # [doc = "58 - DMA2 Stream2 global interrupt"] DMA2_Stream2 = 58 , # [doc = "59 - DMA2 Stream3 global interrupt"] DMA2_Stream3 = 59 , # [doc = "60 - DMA2 Stream4 global interrupt"] DMA2_Stream4 = 60 , # [doc = "61 - Ethernet global interrupt"] ETH = 61 , # [doc = "62 - Ethernet Wakeup through EXTI line interrupt"] ETH_WKUP = 62 , # [doc = "63 - CAN2 TX interrupts"] CAN2_TX = 63 , # [doc = "64 - CAN2 RX0 interrupts"] CAN2_RX0 = 64 , # [doc = "65 - CAN2 RX1 interrupts"] CAN2_RX1 = 65 , # [doc = "66 - CAN2 SCE interrupt"] CAN2_SCE = 66 , # [doc = "67 - USB On The Go FS global interrupt"] OTG_FS = 67 , # [doc = "68 - DMA2 Stream5 global interrupt"] DMA2_Stream5 = 68 , # [doc = "69 - DMA2 Stream6 global interrupt"] DMA2_Stream6 = 69 , # [doc = "70 - DMA2 Stream7 global interrupt"] DMA2_Stream7 = 70 , # [doc = "71 - USART6 global interrupt"] USART6 = 71 , # [doc = "72 - I2C3 event interrupt"] I2C3_EV = 72 , # [doc = "73 - I2C3 error interrupt"] I2C3_ER = 73 , # [doc = "74 - USB On The Go HS End Point 1 Out global interrupt"] OTG_HS_EP1_OUT = 74 , # [doc = "75 - USB On The Go HS End Point 1 In global interrupt"] OTG_HS_EP1_IN = 75 , # [doc = "76 - USB On The Go HS Wakeup through EXTI interrupt"] OTG_HS_WKUP = 76 , # [doc = "77 - USB On The Go HS global interrupt"] OTG_HS = 77 , # [doc = "78 - DCMI global interrupt"] DCMI = 78 , # [doc = "79 - CRYP crypto global interrupt"] CRYP = 79 , # [doc = "80 - Hash and Rng global interrupt"] HASH_RNG = 80 , # [doc = "81 - Floating point unit interrupt"] FPU = 81 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [doc = "Random number generator"] pub type Rng = crate :: Periph < rng :: RegisterBlock , 0x5006_0800 > ; impl core :: fmt :: Debug for Rng { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rng") . finish () } } # [doc = "Random number generator"] pub mod rng ; # [doc = "Digital camera interface"] pub type Dcmi = crate :: Periph < dcmi :: RegisterBlock , 0x5005_0000 > ; impl core :: fmt :: Debug for Dcmi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dcmi") . finish () } } # [doc = "Digital camera interface"] pub mod dcmi ; # [doc = "Flexible memory controller"] pub type Fsmc = crate :: Periph < fsmc :: RegisterBlock , 0xa000_0000 > ; impl core :: fmt :: Debug for Fsmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fsmc") . finish () } } # [doc = "Flexible memory controller"] pub mod fsmc ; # [doc = "Debug support"] pub type Dbgmcu = crate :: Periph < dbgmcu :: RegisterBlock , 0xe004_2000 > ; impl core :: fmt :: Debug for Dbgmcu { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dbgmcu") . finish () } } # [doc = "Debug support"] pub mod dbgmcu ; # [doc = "DMA controller"] pub type Dma2 = crate :: Periph < dma2 :: RegisterBlock , 0x4002_6400 > ; impl core :: fmt :: Debug for Dma2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma2") . finish () } } # [doc = "DMA controller"] pub mod dma2 ; # [doc = "DMA controller"] pub type Dma1 = crate :: Periph < dma2 :: RegisterBlock , 0x4002_6000 > ; impl core :: fmt :: Debug for Dma1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma1") . finish () } } # [doc = "DMA controller"] pub use self :: dma2 as dma1 ; # [doc = "Reset and clock control"] pub type Rcc = crate :: Periph < rcc :: RegisterBlock , 0x4002_3800 > ; impl core :: fmt :: Debug for Rcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcc") . finish () } } # [doc = "Reset and clock control"] pub mod rcc ; # [doc = "General-purpose I/Os"] pub type Gpioi = crate :: Periph < gpioi :: RegisterBlock , 0x4002_2000 > ; impl core :: fmt :: Debug for Gpioi { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioi") . finish () } } # [doc = "General-purpose I/Os"] pub mod gpioi ; # [doc = "General-purpose I/Os"] pub type Gpioh = crate :: Periph < gpioi :: RegisterBlock , 0x4002_1c00 > ; impl core :: fmt :: Debug for Gpioh { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioh") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpioh ; # [doc = "General-purpose I/Os"] pub type Gpiog = crate :: Periph < gpioi :: RegisterBlock , 0x4002_1800 > ; impl core :: fmt :: Debug for Gpiog { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiog") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpiog ; # [doc = "General-purpose I/Os"] pub type Gpiof = crate :: Periph < gpioi :: RegisterBlock , 0x4002_1400 > ; impl core :: fmt :: Debug for Gpiof { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiof") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpiof ; # [doc = "General-purpose I/Os"] pub type Gpioe = crate :: Periph < gpioi :: RegisterBlock , 0x4002_1000 > ; impl core :: fmt :: Debug for Gpioe { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioe") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpioe ; # [doc = "General-purpose I/Os"] pub type Gpiod = crate :: Periph < gpioi :: RegisterBlock , 0x4002_0c00 > ; impl core :: fmt :: Debug for Gpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiod") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpiod ; # [doc = "General-purpose I/Os"] pub type Gpioc = crate :: Periph < gpioi :: RegisterBlock , 0x4002_0800 > ; impl core :: fmt :: Debug for Gpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioc") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpioc ; # [doc = "General-purpose I/Os"] pub type Gpioj = crate :: Periph < gpioi :: RegisterBlock , 0x4002_2400 > ; impl core :: fmt :: Debug for Gpioj { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioj") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpioj ; # [doc = "General-purpose I/Os"] pub type Gpiok = crate :: Periph < gpioi :: RegisterBlock , 0x4002_2800 > ; impl core :: fmt :: Debug for Gpiok { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiok") . finish () } } # [doc = "General-purpose I/Os"] pub use self :: gpioi as gpiok ; # [doc = "General-purpose I/Os"] pub type Gpiob = crate :: Periph < gpiob :: RegisterBlock , 0x4002_0400 > ; impl core :: fmt :: Debug for Gpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiob") . finish () } } # [doc = "General-purpose I/Os"] pub mod gpiob ; # [doc = "General-purpose I/Os"] pub type Gpioa = crate :: Periph < gpioa :: RegisterBlock , 0x4002_0000 > ; impl core :: fmt :: Debug for Gpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioa") . finish () } } # [doc = "General-purpose I/Os"] pub mod gpioa ; # [doc = "System configuration controller"] pub type Syscfg = crate :: Periph < syscfg :: RegisterBlock , 0x4001_3800 > ; impl core :: fmt :: Debug for Syscfg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Syscfg") . finish () } } # [doc = "System configuration controller"] pub mod syscfg ; # [doc = "Serial peripheral interface"] pub type Spi1 = crate :: Periph < spi1 :: RegisterBlock , 0x4001_3000 > ; impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } } # [doc = "Serial peripheral interface"] pub mod spi1 ; # [doc = "Serial peripheral interface"] pub type Spi2 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3800 > ; impl core :: fmt :: Debug for Spi2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi2") . finish () } } # [doc = "Serial peripheral interface"] pub use self :: spi1 as spi2 ; # [doc = "Serial peripheral interface"] pub type Spi3 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3c00 > ; impl core :: fmt :: Debug for Spi3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi3") . finish () } } # [doc = "Serial peripheral interface"] pub use self :: spi1 as spi3 ; # [doc = "Serial peripheral interface"] pub type I2s2ext = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3400 > ; impl core :: fmt :: Debug for I2s2ext { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2s2ext") . finish () } } # [doc = "Serial peripheral interface"] pub use self :: spi1 as i2s2ext ; # [doc = "Serial peripheral interface"] pub type I2s3ext = crate :: Periph < spi1 :: RegisterBlock , 0x4000_4000 > ; impl core :: fmt :: Debug for I2s3ext { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2s3ext") . finish () } } # [doc = "Serial peripheral interface"] pub use self :: spi1 as i2s3ext ; # [doc = "Secure digital input/output interface"] pub type Sdio = crate :: Periph < sdio :: RegisterBlock , 0x4001_2c00 > ; impl core :: fmt :: Debug for Sdio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdio") . finish () } } # [doc = "Secure digital input/output interface"] pub mod sdio ; # [doc = "Analog-to-digital converter"] pub type Adc1 = crate :: Periph < adc1 :: RegisterBlock , 0x4001_2000 > ; impl core :: fmt :: Debug for Adc1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc1") . finish () } } # [doc = "Analog-to-digital converter"] pub mod adc1 ; # [doc = "Analog-to-digital converter"] pub type Adc2 = crate :: Periph < adc1 :: RegisterBlock , 0x4001_2100 > ; impl core :: fmt :: Debug for Adc2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc2") . finish () } } # [doc = "Analog-to-digital converter"] pub use self :: adc1 as adc2 ; # [doc = "Analog-to-digital converter"] pub type Adc3 = crate :: Periph < adc1 :: RegisterBlock , 0x4001_2200 > ; impl core :: fmt :: Debug for Adc3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc3") . finish () } } # [doc = "Analog-to-digital converter"] pub use self :: adc1 as adc3 ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart1 = crate :: Periph < usart1 :: RegisterBlock , 0x4001_1000 > ; impl core :: fmt :: Debug for Usart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart1") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub mod usart1 ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart6 = crate :: Periph < usart1 :: RegisterBlock , 0x4001_1400 > ; impl core :: fmt :: Debug for Usart6 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart6") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as usart6 ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart2 = crate :: Periph < usart1 :: RegisterBlock , 0x4000_4400 > ; impl core :: fmt :: Debug for Usart2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart2") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as usart2 ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Usart3 = crate :: Periph < usart1 :: RegisterBlock , 0x4000_4800 > ; impl core :: fmt :: Debug for Usart3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart3") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: usart1 as usart3 ; # [doc = "Digital-to-analog converter"] pub type Dac = crate :: Periph < dac :: RegisterBlock , 0x4000_7400 > ; impl core :: fmt :: Debug for Dac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac") . finish () } } # [doc = "Digital-to-analog converter"] pub mod dac ; # [doc = "Power control"] pub type Pwr = crate :: Periph < pwr :: RegisterBlock , 0x4000_7000 > ; impl core :: fmt :: Debug for Pwr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwr") . finish () } } # [doc = "Power control"] pub mod pwr ; # [doc = "Inter-integrated circuit"] pub type I2c1 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5400 > ; impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } } # [doc = "Inter-integrated circuit"] pub mod i2c1 ; # [doc = "Inter-integrated circuit"] pub type I2c3 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5c00 > ; impl core :: fmt :: Debug for I2c3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c3") . finish () } } # [doc = "Inter-integrated circuit"] pub use self :: i2c1 as i2c3 ; # [doc = "Inter-integrated circuit"] pub type I2c2 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5800 > ; impl core :: fmt :: Debug for I2c2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c2") . finish () } } # [doc = "Inter-integrated circuit"] pub use self :: i2c1 as i2c2 ; # [doc = "Independent watchdog"] pub type Iwdg = crate :: Periph < iwdg :: RegisterBlock , 0x4000_3000 > ; impl core :: fmt :: Debug for Iwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Iwdg") . finish () } } # [doc = "Independent watchdog"] pub mod iwdg ; # [doc = "Window watchdog"] pub type Wwdg = crate :: Periph < wwdg :: RegisterBlock , 0x4000_2c00 > ; impl core :: fmt :: Debug for Wwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wwdg") . finish () } } # [doc = "Window watchdog"] pub mod wwdg ; # [doc = "Real-time clock"] pub type Rtc = crate :: Periph < rtc :: RegisterBlock , 0x4000_2800 > ; impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } } # [doc = "Real-time clock"] pub mod rtc ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Uart4 = crate :: Periph < uart4 :: RegisterBlock , 0x4000_4c00 > ; impl core :: fmt :: Debug for Uart4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart4") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub mod uart4 ; # [doc = "Universal synchronous asynchronous receiver transmitter"] pub type Uart5 = crate :: Periph < uart4 :: RegisterBlock , 0x4000_5000 > ; impl core :: fmt :: Debug for Uart5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart5") . finish () } } # [doc = "Universal synchronous asynchronous receiver transmitter"] pub use self :: uart4 as uart5 ; # [doc = "Common ADC registers"] pub type AdcCommon = crate :: Periph < adc_common :: RegisterBlock , 0x4001_2300 > ; impl core :: fmt :: Debug for AdcCommon { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AdcCommon") . finish () } } # [doc = "Common ADC registers"] pub mod adc_common ; # [doc = "Advanced-timers"] pub type Tim1 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_0000 > ; impl core :: fmt :: Debug for Tim1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim1") . finish () } } # [doc = "Advanced-timers"] pub mod tim1 ; # [doc = "Advanced-timers"] pub type Tim8 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_0400 > ; impl core :: fmt :: Debug for Tim8 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim8") . finish () } } # [doc = "Advanced-timers"] pub use self :: tim1 as tim8 ; # [doc = "General purpose timers"] pub type Tim2 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0000 > ; impl core :: fmt :: Debug for Tim2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim2") . finish () } } # [doc = "General purpose timers"] pub mod tim2 ; # [doc = "General purpose timers"] pub type Tim3 = crate :: Periph < tim3 :: RegisterBlock , 0x4000_0400 > ; impl core :: fmt :: Debug for Tim3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim3") . finish () } } # [doc = "General purpose timers"] pub mod tim3 ; # [doc = "General purpose timers"] pub type Tim4 = crate :: Periph < tim3 :: RegisterBlock , 0x4000_0800 > ; impl core :: fmt :: Debug for Tim4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim4") . finish () } } # [doc = "General purpose timers"] pub use self :: tim3 as tim4 ; # [doc = "General-purpose-timers"] pub type Tim5 = crate :: Periph < tim5 :: RegisterBlock , 0x4000_0c00 > ; impl core :: fmt :: Debug for Tim5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim5") . finish () } } # [doc = "General-purpose-timers"] pub mod tim5 ; # [doc = "General purpose timers"] pub type Tim9 = crate :: Periph < tim9 :: RegisterBlock , 0x4001_4000 > ; impl core :: fmt :: Debug for Tim9 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim9") . finish () } } # [doc = "General purpose timers"] pub mod tim9 ; # [doc = "General purpose timers"] pub type Tim12 = crate :: Periph < tim9 :: RegisterBlock , 0x4000_1800 > ; impl core :: fmt :: Debug for Tim12 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim12") . finish () } } # [doc = "General purpose timers"] pub use self :: tim9 as tim12 ; # [doc = "General-purpose-timers"] pub type Tim10 = crate :: Periph < tim10 :: RegisterBlock , 0x4001_4400 > ; impl core :: fmt :: Debug for Tim10 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim10") . finish () } } # [doc = "General-purpose-timers"] pub mod tim10 ; # [doc = "General-purpose-timers"] pub type Tim13 = crate :: Periph < tim10 :: RegisterBlock , 0x4000_1c00 > ; impl core :: fmt :: Debug for Tim13 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim13") . finish () } } # [doc = "General-purpose-timers"] pub use self :: tim10 as tim13 ; # [doc = "General-purpose-timers"] pub type Tim14 = crate :: Periph < tim10 :: RegisterBlock , 0x4000_2000 > ; impl core :: fmt :: Debug for Tim14 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim14") . finish () } } # [doc = "General-purpose-timers"] pub use self :: tim10 as tim14 ; # [doc = "General-purpose-timers"] pub type Tim11 = crate :: Periph < tim11 :: RegisterBlock , 0x4001_4800 > ; impl core :: fmt :: Debug for Tim11 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim11") . finish () } } # [doc = "General-purpose-timers"] pub mod tim11 ; # [doc = "Basic timers"] pub type Tim6 = crate :: Periph < tim6 :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for Tim6 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim6") . finish () } } # [doc = "Basic timers"] pub mod tim6 ; # [doc = "Basic timers"] pub type Tim7 = crate :: Periph < tim6 :: RegisterBlock , 0x4000_1400 > ; impl core :: fmt :: Debug for Tim7 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim7") . finish () } } # [doc = "Basic timers"] pub use self :: tim6 as tim7 ; # [doc = "Ethernet: media access control (MAC)"] pub type EthernetMac = crate :: Periph < ethernet_mac :: RegisterBlock , 0x4002_8000 > ; impl core :: fmt :: Debug for EthernetMac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetMac") . finish () } } # [doc = "Ethernet: media access control (MAC)"] pub mod ethernet_mac ; # [doc = "Ethernet: MAC management counters"] pub type EthernetMmc = crate :: Periph < ethernet_mmc :: RegisterBlock , 0x4002_8100 > ; impl core :: fmt :: Debug for EthernetMmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetMmc") . finish () } } # [doc = "Ethernet: MAC management counters"] pub mod ethernet_mmc ; # [doc = "Ethernet: Precision time protocol"] pub type EthernetPtp = crate :: Periph < ethernet_ptp :: RegisterBlock , 0x4002_8700 > ; impl core :: fmt :: Debug for EthernetPtp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetPtp") . finish () } } # [doc = "Ethernet: Precision time protocol"] pub mod ethernet_ptp ; # [doc = "Ethernet: DMA controller operation"] pub type EthernetDma = crate :: Periph < ethernet_dma :: RegisterBlock , 0x4002_9000 > ; impl core :: fmt :: Debug for EthernetDma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EthernetDma") . finish () } } # [doc = "Ethernet: DMA controller operation"] pub mod ethernet_dma ; # [doc = "Cryptographic processor"] pub type Crc = crate :: Periph < crc :: RegisterBlock , 0x4002_3000 > ; impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } } # [doc = "Cryptographic processor"] pub mod crc ; # [doc = "USB on the go full speed"] pub type OtgFsGlobal = crate :: Periph < otg_fs_global :: RegisterBlock , 0x5000_0000 > ; impl core :: fmt :: Debug for OtgFsGlobal { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsGlobal") . finish () } } # [doc = "USB on the go full speed"] pub mod otg_fs_global ; # [doc = "USB on the go full speed"] pub type OtgFsHost = crate :: Periph < otg_fs_host :: RegisterBlock , 0x5000_0400 > ; impl core :: fmt :: Debug for OtgFsHost { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsHost") . finish () } } # [doc = "USB on the go full speed"] pub mod otg_fs_host ; # [doc = "USB on the go full speed"] pub type OtgFsDevice = crate :: Periph < otg_fs_device :: RegisterBlock , 0x5000_0800 > ; impl core :: fmt :: Debug for OtgFsDevice { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsDevice") . finish () } } # [doc = "USB on the go full speed"] pub mod otg_fs_device ; # [doc = "USB on the go full speed"] pub type OtgFsPwrclk = crate :: Periph < otg_fs_pwrclk :: RegisterBlock , 0x5000_0e00 > ; impl core :: fmt :: Debug for OtgFsPwrclk { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgFsPwrclk") . finish () } } # [doc = "USB on the go full speed"] pub mod otg_fs_pwrclk ; # [doc = "Controller area network"] pub type Can1 = crate :: Periph < can1 :: RegisterBlock , 0x4000_6400 > ; impl core :: fmt :: Debug for Can1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can1") . finish () } } # [doc = "Controller area network"] pub mod can1 ; # [doc = "Controller area network"] pub type Can2 = crate :: Periph < can1 :: RegisterBlock , 0x4000_6800 > ; impl core :: fmt :: Debug for Can2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can2") . finish () } } # [doc = "Controller area network"] pub use self :: can1 as can2 ; # [doc = "FLASH"] pub type Flash = crate :: Periph < flash :: RegisterBlock , 0x4002_3c00 > ; impl core :: fmt :: Debug for Flash { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flash") . finish () } } # [doc = "FLASH"] pub mod flash ; # [doc = "External interrupt/event controller"] pub type Exti = crate :: Periph < exti :: RegisterBlock , 0x4001_3c00 > ; impl core :: fmt :: Debug for Exti { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Exti") . finish () } } # [doc = "External interrupt/event controller"] pub mod exti ; # [doc = "USB on the go high speed"] pub type OtgHsGlobal = crate :: Periph < otg_hs_global :: RegisterBlock , 0x4004_0000 > ; impl core :: fmt :: Debug for OtgHsGlobal { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgHsGlobal") . finish () } } # [doc = "USB on the go high speed"] pub mod otg_hs_global ; # [doc = "USB on the go high speed"] pub type OtgHsHost = crate :: Periph < otg_hs_host :: RegisterBlock , 0x4004_0400 > ; impl core :: fmt :: Debug for OtgHsHost { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgHsHost") . finish () } } # [doc = "USB on the go high speed"] pub mod otg_hs_host ; # [doc = "USB on the go high speed"] pub type OtgHsDevice = crate :: Periph < otg_hs_device :: RegisterBlock , 0x4004_0800 > ; impl core :: fmt :: Debug for OtgHsDevice { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgHsDevice") . finish () } } # [doc = "USB on the go high speed"] pub mod otg_hs_device ; # [doc = "USB on the go high speed"] pub type OtgHsPwrclk = crate :: Periph < otg_hs_pwrclk :: RegisterBlock , 0x4004_0e00 > ; impl core :: fmt :: Debug for OtgHsPwrclk { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OtgHsPwrclk") . finish () } } # [doc = "USB on the go high speed"] pub mod otg_hs_pwrclk ; # [doc = "Hash processor"] pub type Hash = crate :: Periph < hash :: RegisterBlock , 0x5006_0400 > ; impl core :: fmt :: Debug for Hash { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hash") . finish () } } # [doc = "Hash processor"] pub mod hash ; # [doc = "Cryptographic processor"] pub type Cryp = crate :: Periph < cryp :: RegisterBlock , 0x5006_0000 > ; impl core :: fmt :: Debug for Cryp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cryp") . finish () } } # [doc = "Cryptographic processor"] pub mod cryp ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "RNG"] pub rng : Rng , # [doc = "DCMI"] pub dcmi : Dcmi , # [doc = "FSMC"] pub fsmc : Fsmc , # [doc = "DBGMCU"] pub dbgmcu : Dbgmcu , # [doc = "DMA2"] pub dma2 : Dma2 , # [doc = "DMA1"] pub dma1 : Dma1 , # [doc = "RCC"] pub rcc : Rcc , # [doc = "GPIOI"] pub gpioi : Gpioi , # [doc = "GPIOH"] pub gpioh : Gpioh , # [doc = "GPIOG"] pub gpiog : Gpiog , # [doc = "GPIOF"] pub gpiof : Gpiof , # [doc = "GPIOE"] pub gpioe : Gpioe , # [doc = "GPIOD"] pub gpiod : Gpiod , # [doc = "GPIOC"] pub gpioc : Gpioc , # [doc = "GPIOJ"] pub gpioj : Gpioj , # [doc = "GPIOK"] pub gpiok : Gpiok , # [doc = "GPIOB"] pub gpiob : Gpiob , # [doc = "GPIOA"] pub gpioa : Gpioa , # [doc = "SYSCFG"] pub syscfg : Syscfg , # [doc = "SPI1"] pub spi1 : Spi1 , # [doc = "SPI2"] pub spi2 : Spi2 , # [doc = "SPI3"] pub spi3 : Spi3 , # [doc = "I2S2ext"] pub i2s2ext : I2s2ext , # [doc = "I2S3ext"] pub i2s3ext : I2s3ext , # [doc = "SDIO"] pub sdio : Sdio , # [doc = "ADC1"] pub adc1 : Adc1 , # [doc = "ADC2"] pub adc2 : Adc2 , # [doc = "ADC3"] pub adc3 : Adc3 , # [doc = "USART1"] pub usart1 : Usart1 , # [doc = "USART6"] pub usart6 : Usart6 , # [doc = "USART2"] pub usart2 : Usart2 , # [doc = "USART3"] pub usart3 : Usart3 , # [doc = "DAC"] pub dac : Dac , # [doc = "PWR"] pub pwr : Pwr , # [doc = "I2C1"] pub i2c1 : I2c1 , # [doc = "I2C3"] pub i2c3 : I2c3 , # [doc = "I2C2"] pub i2c2 : I2c2 , # [doc = "IWDG"] pub iwdg : Iwdg , # [doc = "WWDG"] pub wwdg : Wwdg , # [doc = "RTC"] pub rtc : Rtc , # [doc = "UART4"] pub uart4 : Uart4 , # [doc = "UART5"] pub uart5 : Uart5 , # [doc = "ADC_Common"] pub adc_common : AdcCommon , # [doc = "TIM1"] pub tim1 : Tim1 , # [doc = "TIM8"] pub tim8 : Tim8 , # [doc = "TIM2"] pub tim2 : Tim2 , # [doc = "TIM3"] pub tim3 : Tim3 , # [doc = "TIM4"] pub tim4 : Tim4 , # [doc = "TIM5"] pub tim5 : Tim5 , # [doc = "TIM9"] pub tim9 : Tim9 , # [doc = "TIM12"] pub tim12 : Tim12 , # [doc = "TIM10"] pub tim10 : Tim10 , # [doc = "TIM13"] pub tim13 : Tim13 , # [doc = "TIM14"] pub tim14 : Tim14 , # [doc = "TIM11"] pub tim11 : Tim11 , # [doc = "TIM6"] pub tim6 : Tim6 , # [doc = "TIM7"] pub tim7 : Tim7 , # [doc = "Ethernet_MAC"] pub ethernet_mac : EthernetMac , # [doc = "Ethernet_MMC"] pub ethernet_mmc : EthernetMmc , # [doc = "Ethernet_PTP"] pub ethernet_ptp : EthernetPtp , # [doc = "Ethernet_DMA"] pub ethernet_dma : EthernetDma , # [doc = "CRC"] pub crc : Crc , # [doc = "OTG_FS_GLOBAL"] pub otg_fs_global : OtgFsGlobal , # [doc = "OTG_FS_HOST"] pub otg_fs_host : OtgFsHost , # [doc = "OTG_FS_DEVICE"] pub otg_fs_device : OtgFsDevice , # [doc = "OTG_FS_PWRCLK"] pub otg_fs_pwrclk : OtgFsPwrclk , # [doc = "CAN1"] pub can1 : Can1 , # [doc = "CAN2"] pub can2 : Can2 , # [doc = "FLASH"] pub flash : Flash , # [doc = "EXTI"] pub exti : Exti , # [doc = "OTG_HS_GLOBAL"] pub otg_hs_global : OtgHsGlobal , # [doc = "OTG_HS_HOST"] pub otg_hs_host : OtgHsHost , # [doc = "OTG_HS_DEVICE"] pub otg_hs_device : OtgHsDevice , # [doc = "OTG_HS_PWRCLK"] pub otg_hs_pwrclk : OtgHsPwrclk , # [doc = "HASH"] pub hash : Hash , # [doc = "CRYP"] pub cryp : Cryp , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { rng : Rng :: steal () , dcmi : Dcmi :: steal () , fsmc : Fsmc :: steal () , dbgmcu : Dbgmcu :: steal () , dma2 : Dma2 :: steal () , dma1 : Dma1 :: steal () , rcc : Rcc :: steal () , gpioi : Gpioi :: steal () , gpioh : Gpioh :: steal () , gpiog : Gpiog :: steal () , gpiof : Gpiof :: steal () , gpioe : Gpioe :: steal () , gpiod : Gpiod :: steal () , gpioc : Gpioc :: steal () , gpioj : Gpioj :: steal () , gpiok : Gpiok :: steal () , gpiob : Gpiob :: steal () , gpioa : Gpioa :: steal () , syscfg : Syscfg :: steal () , spi1 : Spi1 :: steal () , spi2 : Spi2 :: steal () , spi3 : Spi3 :: steal () , i2s2ext : I2s2ext :: steal () , i2s3ext : I2s3ext :: steal () , sdio : Sdio :: steal () , adc1 : Adc1 :: steal () , adc2 : Adc2 :: steal () , adc3 : Adc3 :: steal () , usart1 : Usart1 :: steal () , usart6 : Usart6 :: steal () , usart2 : Usart2 :: steal () , usart3 : Usart3 :: steal () , dac : Dac :: steal () , pwr : Pwr :: steal () , i2c1 : I2c1 :: steal () , i2c3 : I2c3 :: steal () , i2c2 : I2c2 :: steal () , iwdg : Iwdg :: steal () , wwdg : Wwdg :: steal () , rtc : Rtc :: steal () , uart4 : Uart4 :: steal () , uart5 : Uart5 :: steal () , adc_common : AdcCommon :: steal () , tim1 : Tim1 :: steal () , tim8 : Tim8 :: steal () , tim2 : Tim2 :: steal () , tim3 : Tim3 :: steal () , tim4 : Tim4 :: steal () , tim5 : Tim5 :: steal () , tim9 : Tim9 :: steal () , tim12 : Tim12 :: steal () , tim10 : Tim10 :: steal () , tim13 : Tim13 :: steal () , tim14 : Tim14 :: steal () , tim11 : Tim11 :: steal () , tim6 : Tim6 :: steal () , tim7 : Tim7 :: steal () , ethernet_mac : EthernetMac :: steal () , ethernet_mmc : EthernetMmc :: steal () , ethernet_ptp : EthernetPtp :: steal () , ethernet_dma : EthernetDma :: steal () , crc : Crc :: steal () , otg_fs_global : OtgFsGlobal :: steal () , otg_fs_host : OtgFsHost :: steal () , otg_fs_device : OtgFsDevice :: steal () , otg_fs_pwrclk : OtgFsPwrclk :: steal () , can1 : Can1 :: steal () , can2 : Can2 :: steal () , flash : Flash :: steal () , exti : Exti :: steal () , otg_hs_global : OtgHsGlobal :: steal () , otg_hs_host : OtgHsHost :: steal () , otg_hs_device : OtgHsDevice :: steal () , otg_hs_pwrclk : OtgHsPwrclk :: steal () , hash : Hash :: steal () , cryp : Cryp :: steal () , } } }
# [doc = "Register `SR1` reader"] pub type R = crate :: R < Sr1Spec > ; # [doc = "Register `SR1` writer"] pub type W = crate :: W < Sr1Spec > ; # [doc = "Start bit (Master mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sb { # [doc = "0: No Start condition"] NoStart = 0 , # [doc = "1: Start condition generated"] Start = 1 , } impl From < Sb > for bool { # [inline (always)] fn from (variant : Sb) -> Self { variant as u8 != 0 } } # [doc = "Field `SB` reader - Start bit (Master mode)"] pub type SbR = crate :: BitReader < Sb > ; impl SbR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sb { match self . bits { false => Sb :: NoStart , true => Sb :: Start , } } # [doc = "No Start condition"] # [inline (always)] pub fn is_no_start (& self) -> bool { * self == Sb :: NoStart } # [doc = "Start condition generated"] # [inline (always)] pub fn is_start (& self) -> bool { * self == Sb :: Start } } # [doc = "Address sent (master mode)/matched (slave mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Addr { # [doc = "0: Adress mismatched or not received"] NotMatch = 0 , # [doc = "1: Received slave address matched with one of the enabled slave addresses"] Match = 1 , } impl From < Addr > for bool { # [inline (always)] fn from (variant : Addr) -> Self { variant as u8 != 0 } } # [doc = "Field `ADDR` reader - Address sent (master mode)/matched (slave mode)"] pub type AddrR = crate :: BitReader < Addr > ; impl AddrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Addr { match self . bits { false => Addr :: NotMatch , true => Addr :: Match , } } # [doc = "Adress mismatched or not received"] # [inline (always)] pub fn is_not_match (& self) -> bool { * self == Addr :: NotMatch } # [doc = "Received slave address matched with one of the enabled slave addresses"] # [inline (always)] pub fn is_match (& self) -> bool { * self == Addr :: Match } } # [doc = "Byte transfer finished\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Btf { # [doc = "0: Data byte transfer not done"] NotFinished = 0 , # [doc = "1: Data byte transfer successful"] Finished = 1 , } impl From < Btf > for bool { # [inline (always)] fn from (variant : Btf) -> Self { variant as u8 != 0 } } # [doc = "Field `BTF` reader - Byte transfer finished"] pub type BtfR = crate :: BitReader < Btf > ; impl BtfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Btf { match self . bits { false => Btf :: NotFinished , true => Btf :: Finished , } } # [doc = "Data byte transfer not done"] # [inline (always)] pub fn is_not_finished (& self) -> bool { * self == Btf :: NotFinished } # [doc = "Data byte transfer successful"] # [inline (always)] pub fn is_finished (& self) -> bool { * self == Btf :: Finished } } # [doc = "Field `ADD10` reader - 10-bit header sent (Master mode)"] pub type Add10R = crate :: BitReader ; # [doc = "Stop detection (slave mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Stopf { # [doc = "0: No Stop condition detected"] NoStop = 0 , # [doc = "1: Stop condition detected"] Stop = 1 , } impl From < Stopf > for bool { # [inline (always)] fn from (variant : Stopf) -> Self { variant as u8 != 0 } } # [doc = "Field `STOPF` reader - Stop detection (slave mode)"] pub type StopfR = crate :: BitReader < Stopf > ; impl StopfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Stopf { match self . bits { false => Stopf :: NoStop , true => Stopf :: Stop , } } # [doc = "No Stop condition detected"] # [inline (always)] pub fn is_no_stop (& self) -> bool { * self == Stopf :: NoStop } # [doc = "Stop condition detected"] # [inline (always)] pub fn is_stop (& self) -> bool { * self == Stopf :: Stop } } # [doc = "Data register not empty (receivers)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RxNe { # [doc = "0: Data register empty"] Empty = 0 , # [doc = "1: Data register not empty"] NotEmpty = 1 , } impl From < RxNe > for bool { # [inline (always)] fn from (variant : RxNe) -> Self { variant as u8 != 0 } } # [doc = "Field `RxNE` reader - Data register not empty (receivers)"] pub type RxNeR = crate :: BitReader < RxNe > ; impl RxNeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> RxNe { match self . bits { false => RxNe :: Empty , true => RxNe :: NotEmpty , } } # [doc = "Data register empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == RxNe :: Empty } # [doc = "Data register not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == RxNe :: NotEmpty } } # [doc = "Data register empty (transmitters)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum TxE { # [doc = "0: Data register not empty"] NotEmpty = 0 , # [doc = "1: Data register empty"] Empty = 1 , } impl From < TxE > for bool { # [inline (always)] fn from (variant : TxE) -> Self { variant as u8 != 0 } } # [doc = "Field `TxE` reader - Data register empty (transmitters)"] pub type TxER = crate :: BitReader < TxE > ; impl TxER { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> TxE { match self . bits { false => TxE :: NotEmpty , true => TxE :: Empty , } } # [doc = "Data register not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == TxE :: NotEmpty } # [doc = "Data register empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == TxE :: Empty } } # [doc = "Bus error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Berrr { # [doc = "0: No misplaced Start or Stop condition"] NoError = 0 , # [doc = "1: Misplaced Start or Stop condition"] Error = 1 , } impl From < Berrr > for bool { # [inline (always)] fn from (variant : Berrr) -> Self { variant as u8 != 0 } } # [doc = "Field `BERR` reader - Bus error"] pub type BerrR = crate :: BitReader < Berrr > ; impl BerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Berrr { match self . bits { false => Berrr :: NoError , true => Berrr :: Error , } } # [doc = "No misplaced Start or Stop condition"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Berrr :: NoError } # [doc = "Misplaced Start or Stop condition"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Berrr :: Error } } # [doc = "Bus error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum BerrwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < BerrwWO > for bool { # [inline (always)] fn from (variant : BerrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `BERR` writer - Bus error"] pub type BerrW < 'a , REG > = crate :: BitWriter0C < 'a , REG , BerrwWO > ; impl < 'a , REG > BerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (BerrwWO :: Clear) } } # [doc = "Arbitration lost (master mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Arlor { # [doc = "0: No Arbitration Lost detected"] NoLost = 0 , # [doc = "1: Arbitration Lost detected"] Lost = 1 , } impl From < Arlor > for bool { # [inline (always)] fn from (variant : Arlor) -> Self { variant as u8 != 0 } } # [doc = "Field `ARLO` reader - Arbitration lost (master mode)"] pub type ArloR = crate :: BitReader < Arlor > ; impl ArloR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Arlor { match self . bits { false => Arlor :: NoLost , true => Arlor :: Lost , } } # [doc = "No Arbitration Lost detected"] # [inline (always)] pub fn is_no_lost (& self) -> bool { * self == Arlor :: NoLost } # [doc = "Arbitration Lost detected"] # [inline (always)] pub fn is_lost (& self) -> bool { * self == Arlor :: Lost } } # [doc = "Arbitration lost (master mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum ArlowWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < ArlowWO > for bool { # [inline (always)] fn from (variant : ArlowWO) -> Self { variant as u8 != 0 } } # [doc = "Field `ARLO` writer - Arbitration lost (master mode)"] pub type ArloW < 'a , REG > = crate :: BitWriter0C < 'a , REG , ArlowWO > ; impl < 'a , REG > ArloW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (ArlowWO :: Clear) } } # [doc = "Acknowledge failure\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Afr { # [doc = "0: No acknowledge failure"] NoFailure = 0 , # [doc = "1: Acknowledge failure"] Failure = 1 , } impl From < Afr > for bool { # [inline (always)] fn from (variant : Afr) -> Self { variant as u8 != 0 } } # [doc = "Field `AF` reader - Acknowledge failure"] pub type AfR = crate :: BitReader < Afr > ; impl AfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Afr { match self . bits { false => Afr :: NoFailure , true => Afr :: Failure , } } # [doc = "No acknowledge failure"] # [inline (always)] pub fn is_no_failure (& self) -> bool { * self == Afr :: NoFailure } # [doc = "Acknowledge failure"] # [inline (always)] pub fn is_failure (& self) -> bool { * self == Afr :: Failure } } # [doc = "Acknowledge failure\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum AfwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < AfwWO > for bool { # [inline (always)] fn from (variant : AfwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `AF` writer - Acknowledge failure"] pub type AfW < 'a , REG > = crate :: BitWriter0C < 'a , REG , AfwWO > ; impl < 'a , REG > AfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (AfwWO :: Clear) } } # [doc = "Overrun/Underrun\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ovrr { # [doc = "0: No overrun/underrun occured"] NoOverrun = 0 , # [doc = "1: Overrun/underrun occured"] Overrun = 1 , } impl From < Ovrr > for bool { # [inline (always)] fn from (variant : Ovrr) -> Self { variant as u8 != 0 } } # [doc = "Field `OVR` reader - Overrun/Underrun"] pub type OvrR = crate :: BitReader < Ovrr > ; impl OvrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ovrr { match self . bits { false => Ovrr :: NoOverrun , true => Ovrr :: Overrun , } } # [doc = "No overrun/underrun occured"] # [inline (always)] pub fn is_no_overrun (& self) -> bool { * self == Ovrr :: NoOverrun } # [doc = "Overrun/underrun occured"] # [inline (always)] pub fn is_overrun (& self) -> bool { * self == Ovrr :: Overrun } } # [doc = "Overrun/Underrun\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum OvrwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < OvrwWO > for bool { # [inline (always)] fn from (variant : OvrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `OVR` writer - Overrun/Underrun"] pub type OvrW < 'a , REG > = crate :: BitWriter0C < 'a , REG , OvrwWO > ; impl < 'a , REG > OvrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (OvrwWO :: Clear) } } # [doc = "PEC Error in reception\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pecerrr { # [doc = "0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)"] NoError = 0 , # [doc = "1: PEC error: receiver returns NACK after PEC reception (whatever ACK)"] Error = 1 , } impl From < Pecerrr > for bool { # [inline (always)] fn from (variant : Pecerrr) -> Self { variant as u8 != 0 } } # [doc = "Field `PECERR` reader - PEC Error in reception"] pub type PecerrR = crate :: BitReader < Pecerrr > ; impl PecerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pecerrr { match self . bits { false => Pecerrr :: NoError , true => Pecerrr :: Error , } } # [doc = "no PEC error: receiver returns ACK after PEC reception (if ACK=1)"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Pecerrr :: NoError } # [doc = "PEC error: receiver returns NACK after PEC reception (whatever ACK)"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Pecerrr :: Error } } # [doc = "PEC Error in reception\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum PecerrwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < PecerrwWO > for bool { # [inline (always)] fn from (variant : PecerrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PECERR` writer - PEC Error in reception"] pub type PecerrW < 'a , REG > = crate :: BitWriter0C < 'a , REG , PecerrwWO > ; impl < 'a , REG > PecerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (PecerrwWO :: Clear) } } # [doc = "Timeout or Tlow error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Timeoutr { # [doc = "0: No Timeout error"] NoTimeout = 0 , # [doc = "1: SCL remained LOW for 25 ms"] Timeout = 1 , } impl From < Timeoutr > for bool { # [inline (always)] fn from (variant : Timeoutr) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMEOUT` reader - Timeout or Tlow error"] pub type TimeoutR = crate :: BitReader < Timeoutr > ; impl TimeoutR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Timeoutr { match self . bits { false => Timeoutr :: NoTimeout , true => Timeoutr :: Timeout , } } # [doc = "No Timeout error"] # [inline (always)] pub fn is_no_timeout (& self) -> bool { * self == Timeoutr :: NoTimeout } # [doc = "SCL remained LOW for 25 ms"] # [inline (always)] pub fn is_timeout (& self) -> bool { * self == Timeoutr :: Timeout } } # [doc = "Timeout or Tlow error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum TimeoutwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < TimeoutwWO > for bool { # [inline (always)] fn from (variant : TimeoutwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMEOUT` writer - Timeout or Tlow error"] pub type TimeoutW < 'a , REG > = crate :: BitWriter0C < 'a , REG , TimeoutwWO > ; impl < 'a , REG > TimeoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (TimeoutwWO :: Clear) } } # [doc = "SMBus alert\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Smbalertr { # [doc = "0: No SMBALERT occured"] NoAlert = 0 , # [doc = "1: SMBALERT occurred"] Alert = 1 , } impl From < Smbalertr > for bool { # [inline (always)] fn from (variant : Smbalertr) -> Self { variant as u8 != 0 } } # [doc = "Field `SMBALERT` reader - SMBus alert"] pub type SmbalertR = crate :: BitReader < Smbalertr > ; impl SmbalertR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Smbalertr { match self . bits { false => Smbalertr :: NoAlert , true => Smbalertr :: Alert , } } # [doc = "No SMBALERT occured"] # [inline (always)] pub fn is_no_alert (& self) -> bool { * self == Smbalertr :: NoAlert } # [doc = "SMBALERT occurred"] # [inline (always)] pub fn is_alert (& self) -> bool { * self == Smbalertr :: Alert } } # [doc = "SMBus alert\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum SmbalertwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < SmbalertwWO > for bool { # [inline (always)] fn from (variant : SmbalertwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `SMBALERT` writer - SMBus alert"] pub type SmbalertW < 'a , REG > = crate :: BitWriter0C < 'a , REG , SmbalertwWO > ; impl < 'a , REG > SmbalertW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (SmbalertwWO :: Clear) } } impl R { # [doc = "Bit 0 - Start bit (Master mode)"] # [inline (always)] pub fn sb (& self) -> SbR { SbR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Address sent (master mode)/matched (slave mode)"] # [inline (always)] pub fn addr (& self) -> AddrR { AddrR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Byte transfer finished"] # [inline (always)] pub fn btf (& self) -> BtfR { BtfR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - 10-bit header sent (Master mode)"] # [inline (always)] pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Stop detection (slave mode)"] # [inline (always)] pub fn stopf (& self) -> StopfR { StopfR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Data register not empty (receivers)"] # [inline (always)] pub fn rx_ne (& self) -> RxNeR { RxNeR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Data register empty (transmitters)"] # [inline (always)] pub fn tx_e (& self) -> TxER { TxER :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Bus error"] # [inline (always)] pub fn berr (& self) -> BerrR { BerrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Arbitration lost (master mode)"] # [inline (always)] pub fn arlo (& self) -> ArloR { ArloR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Acknowledge failure"] # [inline (always)] pub fn af (& self) -> AfR { AfR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Overrun/Underrun"] # [inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - PEC Error in reception"] # [inline (always)] pub fn pecerr (& self) -> PecerrR { PecerrR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 14 - Timeout or Tlow error"] # [inline (always)] pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - SMBus alert"] # [inline (always)] pub fn smbalert (& self) -> SmbalertR { SmbalertR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 8 - Bus error"] # [inline (always)] pub fn berr (& mut self) -> BerrW < Sr1Spec > { BerrW :: new (self , 8) } # [doc = "Bit 9 - Arbitration lost (master mode)"] # [inline (always)] pub fn arlo (& mut self) -> ArloW < Sr1Spec > { ArloW :: new (self , 9) } # [doc = "Bit 10 - Acknowledge failure"] # [inline (always)] pub fn af (& mut self) -> AfW < Sr1Spec > { AfW :: new (self , 10) } # [doc = "Bit 11 - Overrun/Underrun"] # [inline (always)] pub fn ovr (& mut self) -> OvrW < Sr1Spec > { OvrW :: new (self , 11) } # [doc = "Bit 12 - PEC Error in reception"] # [inline (always)] pub fn pecerr (& mut self) -> PecerrW < Sr1Spec > { PecerrW :: new (self , 12) } # [doc = "Bit 14 - Timeout or Tlow error"] # [inline (always)] pub fn timeout (& mut self) -> TimeoutW < Sr1Spec > { TimeoutW :: new (self , 14) } # [doc = "Bit 15 - SMBus alert"] # [inline (always)] pub fn smbalert (& mut self) -> SmbalertW < Sr1Spec > { SmbalertW :: new (self , 15) } } # [doc = "Status register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`sr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Sr1Spec ; impl crate :: RegisterSpec for Sr1Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`sr1::R`](R) reader structure"] impl crate :: Readable for Sr1Spec { } # [doc = "`write(|w| ..)` method takes [`sr1::W`](W) writer structure"] impl crate :: Writable for Sr1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0xdf00 ; } # [doc = "`reset()` method sets SR1 to value 0"] impl crate :: Resettable for Sr1Spec { }
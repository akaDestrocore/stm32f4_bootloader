# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Peripheral enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pe { # [doc = "0: Peripheral disabled"] Disabled = 0 , # [doc = "1: Peripheral enabled"] Enabled = 1 , } impl From < Pe > for bool { # [inline (always)] fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Peripheral enable"] pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: Disabled , true => Pe :: Enabled , } } # [doc = "Peripheral disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pe :: Disabled } # [doc = "Peripheral enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pe :: Enabled } } # [doc = "Field `PE` writer - Peripheral enable"] pub type PeW < 'a , REG > = crate :: BitWriter < 'a , REG , Pe > ; impl < 'a , REG > PeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Peripheral disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Disabled) } # [doc = "Peripheral enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Enabled) } } # [doc = "SMBus mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Smbus { # [doc = "0: I2C Mode"] I2c = 0 , # [doc = "1: SMBus"] Smbus = 1 , } impl From < Smbus > for bool { # [inline (always)] fn from (variant : Smbus) -> Self { variant as u8 != 0 } } # [doc = "Field `SMBUS` reader - SMBus mode"] pub type SmbusR = crate :: BitReader < Smbus > ; impl SmbusR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Smbus { match self . bits { false => Smbus :: I2c , true => Smbus :: Smbus , } } # [doc = "I2C Mode"] # [inline (always)] pub fn is_i2c (& self) -> bool { * self == Smbus :: I2c } # [doc = "SMBus"] # [inline (always)] pub fn is_smbus (& self) -> bool { * self == Smbus :: Smbus } } # [doc = "Field `SMBUS` writer - SMBus mode"] pub type SmbusW < 'a , REG > = crate :: BitWriter < 'a , REG , Smbus > ; impl < 'a , REG > SmbusW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "I2C Mode"] # [inline (always)] pub fn i2c (self) -> & 'a mut crate :: W < REG > { self . variant (Smbus :: I2c) } # [doc = "SMBus"] # [inline (always)] pub fn smbus (self) -> & 'a mut crate :: W < REG > { self . variant (Smbus :: Smbus) } } # [doc = "SMBus type\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Smbtype { # [doc = "0: SMBus Device"] Device = 0 , # [doc = "1: SMBus Host"] Host = 1 , } impl From < Smbtype > for bool { # [inline (always)] fn from (variant : Smbtype) -> Self { variant as u8 != 0 } } # [doc = "Field `SMBTYPE` reader - SMBus type"] pub type SmbtypeR = crate :: BitReader < Smbtype > ; impl SmbtypeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Smbtype { match self . bits { false => Smbtype :: Device , true => Smbtype :: Host , } } # [doc = "SMBus Device"] # [inline (always)] pub fn is_device (& self) -> bool { * self == Smbtype :: Device } # [doc = "SMBus Host"] # [inline (always)] pub fn is_host (& self) -> bool { * self == Smbtype :: Host } } # [doc = "Field `SMBTYPE` writer - SMBus type"] pub type SmbtypeW < 'a , REG > = crate :: BitWriter < 'a , REG , Smbtype > ; impl < 'a , REG > SmbtypeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SMBus Device"] # [inline (always)] pub fn device (self) -> & 'a mut crate :: W < REG > { self . variant (Smbtype :: Device) } # [doc = "SMBus Host"] # [inline (always)] pub fn host (self) -> & 'a mut crate :: W < REG > { self . variant (Smbtype :: Host) } } # [doc = "ARP enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enarp { # [doc = "0: ARP disabled"] Disabled = 0 , # [doc = "1: ARP enabled"] Enabled = 1 , } impl From < Enarp > for bool { # [inline (always)] fn from (variant : Enarp) -> Self { variant as u8 != 0 } } # [doc = "Field `ENARP` reader - ARP enable"] pub type EnarpR = crate :: BitReader < Enarp > ; impl EnarpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enarp { match self . bits { false => Enarp :: Disabled , true => Enarp :: Enabled , } } # [doc = "ARP disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enarp :: Disabled } # [doc = "ARP enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enarp :: Enabled } } # [doc = "Field `ENARP` writer - ARP enable"] pub type EnarpW < 'a , REG > = crate :: BitWriter < 'a , REG , Enarp > ; impl < 'a , REG > EnarpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "ARP disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enarp :: Disabled) } # [doc = "ARP enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enarp :: Enabled) } } # [doc = "PEC enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enpec { # [doc = "0: PEC calculation disabled"] Disabled = 0 , # [doc = "1: PEC calculation enabled"] Enabled = 1 , } impl From < Enpec > for bool { # [inline (always)] fn from (variant : Enpec) -> Self { variant as u8 != 0 } } # [doc = "Field `ENPEC` reader - PEC enable"] pub type EnpecR = crate :: BitReader < Enpec > ; impl EnpecR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enpec { match self . bits { false => Enpec :: Disabled , true => Enpec :: Enabled , } } # [doc = "PEC calculation disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enpec :: Disabled } # [doc = "PEC calculation enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enpec :: Enabled } } # [doc = "Field `ENPEC` writer - PEC enable"] pub type EnpecW < 'a , REG > = crate :: BitWriter < 'a , REG , Enpec > ; impl < 'a , REG > EnpecW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PEC calculation disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enpec :: Disabled) } # [doc = "PEC calculation enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enpec :: Enabled) } } # [doc = "General call enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Engc { # [doc = "0: General call disabled"] Disabled = 0 , # [doc = "1: General call enabled"] Enabled = 1 , } impl From < Engc > for bool { # [inline (always)] fn from (variant : Engc) -> Self { variant as u8 != 0 } } # [doc = "Field `ENGC` reader - General call enable"] pub type EngcR = crate :: BitReader < Engc > ; impl EngcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Engc { match self . bits { false => Engc :: Disabled , true => Engc :: Enabled , } } # [doc = "General call disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Engc :: Disabled } # [doc = "General call enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Engc :: Enabled } } # [doc = "Field `ENGC` writer - General call enable"] pub type EngcW < 'a , REG > = crate :: BitWriter < 'a , REG , Engc > ; impl < 'a , REG > EngcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "General call disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Engc :: Disabled) } # [doc = "General call enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Engc :: Enabled) } } # [doc = "Clock stretching disable (Slave mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Nostretch { # [doc = "0: Clock stretching enabled"] Enabled = 0 , # [doc = "1: Clock stretching disabled"] Disabled = 1 , } impl From < Nostretch > for bool { # [inline (always)] fn from (variant : Nostretch) -> Self { variant as u8 != 0 } } # [doc = "Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)"] pub type NostretchR = crate :: BitReader < Nostretch > ; impl NostretchR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Nostretch { match self . bits { false => Nostretch :: Enabled , true => Nostretch :: Disabled , } } # [doc = "Clock stretching enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Nostretch :: Enabled } # [doc = "Clock stretching disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Nostretch :: Disabled } } # [doc = "Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)"] pub type NostretchW < 'a , REG > = crate :: BitWriter < 'a , REG , Nostretch > ; impl < 'a , REG > NostretchW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clock stretching enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: Enabled) } # [doc = "Clock stretching disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: Disabled) } } # [doc = "Start generation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Start { # [doc = "0: No Start generation"] NoStart = 0 , # [doc = "1: In master mode: repeated start generation, in slave mode: start generation when bus is free"] Start = 1 , } impl From < Start > for bool { # [inline (always)] fn from (variant : Start) -> Self { variant as u8 != 0 } } # [doc = "Field `START` reader - Start generation"] pub type StartR = crate :: BitReader < Start > ; impl StartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Start { match self . bits { false => Start :: NoStart , true => Start :: Start , } } # [doc = "No Start generation"] # [inline (always)] pub fn is_no_start (& self) -> bool { * self == Start :: NoStart } # [doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"] # [inline (always)] pub fn is_start (& self) -> bool { * self == Start :: Start } } # [doc = "Field `START` writer - Start generation"] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG , Start > ; impl < 'a , REG > StartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No Start generation"] # [inline (always)] pub fn no_start (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: NoStart) } # [doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"] # [inline (always)] pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: Start) } } # [doc = "Stop generation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Stop { # [doc = "0: No Stop generation"] NoStop = 0 , # [doc = "1: In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"] Stop = 1 , } impl From < Stop > for bool { # [inline (always)] fn from (variant : Stop) -> Self { variant as u8 != 0 } } # [doc = "Field `STOP` reader - Stop generation"] pub type StopR = crate :: BitReader < Stop > ; impl StopR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Stop { match self . bits { false => Stop :: NoStop , true => Stop :: Stop , } } # [doc = "No Stop generation"] # [inline (always)] pub fn is_no_stop (& self) -> bool { * self == Stop :: NoStop } # [doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"] # [inline (always)] pub fn is_stop (& self) -> bool { * self == Stop :: Stop } } # [doc = "Field `STOP` writer - Stop generation"] pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG , Stop > ; impl < 'a , REG > StopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No Stop generation"] # [inline (always)] pub fn no_stop (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: NoStop) } # [doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"] # [inline (always)] pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: Stop) } } # [doc = "Acknowledge enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ack { # [doc = "0: No acknowledge returned"] Nak = 0 , # [doc = "1: Acknowledge returned after a byte is received"] Ack = 1 , } impl From < Ack > for bool { # [inline (always)] fn from (variant : Ack) -> Self { variant as u8 != 0 } } # [doc = "Field `ACK` reader - Acknowledge enable"] pub type AckR = crate :: BitReader < Ack > ; impl AckR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ack { match self . bits { false => Ack :: Nak , true => Ack :: Ack , } } # [doc = "No acknowledge returned"] # [inline (always)] pub fn is_nak (& self) -> bool { * self == Ack :: Nak } # [doc = "Acknowledge returned after a byte is received"] # [inline (always)] pub fn is_ack (& self) -> bool { * self == Ack :: Ack } } # [doc = "Field `ACK` writer - Acknowledge enable"] pub type AckW < 'a , REG > = crate :: BitWriter < 'a , REG , Ack > ; impl < 'a , REG > AckW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No acknowledge returned"] # [inline (always)] pub fn nak (self) -> & 'a mut crate :: W < REG > { self . variant (Ack :: Nak) } # [doc = "Acknowledge returned after a byte is received"] # [inline (always)] pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Ack :: Ack) } } # [doc = "Acknowledge/PEC Position (for data reception)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pos { # [doc = "0: ACK bit controls the (N)ACK of the current byte being received"] Current = 0 , # [doc = "1: ACK bit controls the (N)ACK of the next byte to be received"] Next = 1 , } impl From < Pos > for bool { # [inline (always)] fn from (variant : Pos) -> Self { variant as u8 != 0 } } # [doc = "Field `POS` reader - Acknowledge/PEC Position (for data reception)"] pub type PosR = crate :: BitReader < Pos > ; impl PosR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pos { match self . bits { false => Pos :: Current , true => Pos :: Next , } } # [doc = "ACK bit controls the (N)ACK of the current byte being received"] # [inline (always)] pub fn is_current (& self) -> bool { * self == Pos :: Current } # [doc = "ACK bit controls the (N)ACK of the next byte to be received"] # [inline (always)] pub fn is_next (& self) -> bool { * self == Pos :: Next } } # [doc = "Field `POS` writer - Acknowledge/PEC Position (for data reception)"] pub type PosW < 'a , REG > = crate :: BitWriter < 'a , REG , Pos > ; impl < 'a , REG > PosW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "ACK bit controls the (N)ACK of the current byte being received"] # [inline (always)] pub fn current (self) -> & 'a mut crate :: W < REG > { self . variant (Pos :: Current) } # [doc = "ACK bit controls the (N)ACK of the next byte to be received"] # [inline (always)] pub fn next (self) -> & 'a mut crate :: W < REG > { self . variant (Pos :: Next) } } # [doc = "Packet error checking\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pec { # [doc = "0: No PEC transfer"] Disabled = 0 , # [doc = "1: PEC transfer"] Enabled = 1 , } impl From < Pec > for bool { # [inline (always)] fn from (variant : Pec) -> Self { variant as u8 != 0 } } # [doc = "Field `PEC` reader - Packet error checking"] pub type PecR = crate :: BitReader < Pec > ; impl PecR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pec { match self . bits { false => Pec :: Disabled , true => Pec :: Enabled , } } # [doc = "No PEC transfer"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pec :: Disabled } # [doc = "PEC transfer"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pec :: Enabled } } # [doc = "Field `PEC` writer - Packet error checking"] pub type PecW < 'a , REG > = crate :: BitWriter < 'a , REG , Pec > ; impl < 'a , REG > PecW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No PEC transfer"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pec :: Disabled) } # [doc = "PEC transfer"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pec :: Enabled) } } # [doc = "SMBus alert\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Alert { # [doc = "0: SMBA pin released high"] Release = 0 , # [doc = "1: SMBA pin driven low"] Drive = 1 , } impl From < Alert > for bool { # [inline (always)] fn from (variant : Alert) -> Self { variant as u8 != 0 } } # [doc = "Field `ALERT` reader - SMBus alert"] pub type AlertR = crate :: BitReader < Alert > ; impl AlertR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Alert { match self . bits { false => Alert :: Release , true => Alert :: Drive , } } # [doc = "SMBA pin released high"] # [inline (always)] pub fn is_release (& self) -> bool { * self == Alert :: Release } # [doc = "SMBA pin driven low"] # [inline (always)] pub fn is_drive (& self) -> bool { * self == Alert :: Drive } } # [doc = "Field `ALERT` writer - SMBus alert"] pub type AlertW < 'a , REG > = crate :: BitWriter < 'a , REG , Alert > ; impl < 'a , REG > AlertW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SMBA pin released high"] # [inline (always)] pub fn release (self) -> & 'a mut crate :: W < REG > { self . variant (Alert :: Release) } # [doc = "SMBA pin driven low"] # [inline (always)] pub fn drive (self) -> & 'a mut crate :: W < REG > { self . variant (Alert :: Drive) } } # [doc = "Software reset\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Swrst { # [doc = "0: I2C peripheral not under reset"] NotReset = 0 , # [doc = "1: I2C peripheral under reset"] Reset = 1 , } impl From < Swrst > for bool { # [inline (always)] fn from (variant : Swrst) -> Self { variant as u8 != 0 } } # [doc = "Field `SWRST` reader - Software reset"] pub type SwrstR = crate :: BitReader < Swrst > ; impl SwrstR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Swrst { match self . bits { false => Swrst :: NotReset , true => Swrst :: Reset , } } # [doc = "I2C peripheral not under reset"] # [inline (always)] pub fn is_not_reset (& self) -> bool { * self == Swrst :: NotReset } # [doc = "I2C peripheral under reset"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == Swrst :: Reset } } # [doc = "Field `SWRST` writer - Software reset"] pub type SwrstW < 'a , REG > = crate :: BitWriter < 'a , REG , Swrst > ; impl < 'a , REG > SwrstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "I2C peripheral not under reset"] # [inline (always)] pub fn not_reset (self) -> & 'a mut crate :: W < REG > { self . variant (Swrst :: NotReset) } # [doc = "I2C peripheral under reset"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Swrst :: Reset) } } impl R { # [doc = "Bit 0 - Peripheral enable"] # [inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SMBus mode"] # [inline (always)] pub fn smbus (& self) -> SmbusR { SmbusR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - SMBus type"] # [inline (always)] pub fn smbtype (& self) -> SmbtypeR { SmbtypeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ARP enable"] # [inline (always)] pub fn enarp (& self) -> EnarpR { EnarpR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - PEC enable"] # [inline (always)] pub fn enpec (& self) -> EnpecR { EnpecR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - General call enable"] # [inline (always)] pub fn engc (& self) -> EngcR { EngcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Clock stretching disable (Slave mode)"] # [inline (always)] pub fn nostretch (& self) -> NostretchR { NostretchR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Start generation"] # [inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Stop generation"] # [inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Acknowledge enable"] # [inline (always)] pub fn ack (& self) -> AckR { AckR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"] # [inline (always)] pub fn pos (& self) -> PosR { PosR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Packet error checking"] # [inline (always)] pub fn pec (& self) -> PecR { PecR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - SMBus alert"] # [inline (always)] pub fn alert (& self) -> AlertR { AlertR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 15 - Software reset"] # [inline (always)] pub fn swrst (& self) -> SwrstR { SwrstR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Peripheral enable"] # [inline (always)] pub fn pe (& mut self) -> PeW < Cr1Spec > { PeW :: new (self , 0) } # [doc = "Bit 1 - SMBus mode"] # [inline (always)] pub fn smbus (& mut self) -> SmbusW < Cr1Spec > { SmbusW :: new (self , 1) } # [doc = "Bit 3 - SMBus type"] # [inline (always)] pub fn smbtype (& mut self) -> SmbtypeW < Cr1Spec > { SmbtypeW :: new (self , 3) } # [doc = "Bit 4 - ARP enable"] # [inline (always)] pub fn enarp (& mut self) -> EnarpW < Cr1Spec > { EnarpW :: new (self , 4) } # [doc = "Bit 5 - PEC enable"] # [inline (always)] pub fn enpec (& mut self) -> EnpecW < Cr1Spec > { EnpecW :: new (self , 5) } # [doc = "Bit 6 - General call enable"] # [inline (always)] pub fn engc (& mut self) -> EngcW < Cr1Spec > { EngcW :: new (self , 6) } # [doc = "Bit 7 - Clock stretching disable (Slave mode)"] # [inline (always)] pub fn nostretch (& mut self) -> NostretchW < Cr1Spec > { NostretchW :: new (self , 7) } # [doc = "Bit 8 - Start generation"] # [inline (always)] pub fn start (& mut self) -> StartW < Cr1Spec > { StartW :: new (self , 8) } # [doc = "Bit 9 - Stop generation"] # [inline (always)] pub fn stop (& mut self) -> StopW < Cr1Spec > { StopW :: new (self , 9) } # [doc = "Bit 10 - Acknowledge enable"] # [inline (always)] pub fn ack (& mut self) -> AckW < Cr1Spec > { AckW :: new (self , 10) } # [doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"] # [inline (always)] pub fn pos (& mut self) -> PosW < Cr1Spec > { PosW :: new (self , 11) } # [doc = "Bit 12 - Packet error checking"] # [inline (always)] pub fn pec (& mut self) -> PecW < Cr1Spec > { PecW :: new (self , 12) } # [doc = "Bit 13 - SMBus alert"] # [inline (always)] pub fn alert (& mut self) -> AlertW < Cr1Spec > { AlertW :: new (self , 13) } # [doc = "Bit 15 - Software reset"] # [inline (always)] pub fn swrst (& mut self) -> SwrstW < Cr1Spec > { SwrstW :: new (self , 15) } } # [doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
# [doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ; # [doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ; # [doc = "Field `FREQ` reader - Peripheral clock frequency"] pub type FreqR = crate :: FieldReader ; # [doc = "Field `FREQ` writer - Peripheral clock frequency"] pub type FreqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; # [doc = "Error interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iterren { # [doc = "0: Error interrupt disabled"] Disabled = 0 , # [doc = "1: Error interrupt enabled"] Enabled = 1 , } impl From < Iterren > for bool { # [inline (always)] fn from (variant : Iterren) -> Self { variant as u8 != 0 } } # [doc = "Field `ITERREN` reader - Error interrupt enable"] pub type IterrenR = crate :: BitReader < Iterren > ; impl IterrenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iterren { match self . bits { false => Iterren :: Disabled , true => Iterren :: Enabled , } } # [doc = "Error interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Iterren :: Disabled } # [doc = "Error interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Iterren :: Enabled } } # [doc = "Field `ITERREN` writer - Error interrupt enable"] pub type IterrenW < 'a , REG > = crate :: BitWriter < 'a , REG , Iterren > ; impl < 'a , REG > IterrenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Error interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iterren :: Disabled) } # [doc = "Error interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iterren :: Enabled) } } # [doc = "Event interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Itevten { # [doc = "0: Event interrupt disabled"] Disabled = 0 , # [doc = "1: Event interrupt enabled"] Enabled = 1 , } impl From < Itevten > for bool { # [inline (always)] fn from (variant : Itevten) -> Self { variant as u8 != 0 } } # [doc = "Field `ITEVTEN` reader - Event interrupt enable"] pub type ItevtenR = crate :: BitReader < Itevten > ; impl ItevtenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Itevten { match self . bits { false => Itevten :: Disabled , true => Itevten :: Enabled , } } # [doc = "Event interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Itevten :: Disabled } # [doc = "Event interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Itevten :: Enabled } } # [doc = "Field `ITEVTEN` writer - Event interrupt enable"] pub type ItevtenW < 'a , REG > = crate :: BitWriter < 'a , REG , Itevten > ; impl < 'a , REG > ItevtenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Event interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Itevten :: Disabled) } # [doc = "Event interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Itevten :: Enabled) } } # [doc = "Buffer interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Itbufen { # [doc = "0: TxE=1 or RxNE=1 does not generate any interrupt"] Disabled = 0 , # [doc = "1: TxE=1 or RxNE=1 generates Event interrupt"] Enabled = 1 , } impl From < Itbufen > for bool { # [inline (always)] fn from (variant : Itbufen) -> Self { variant as u8 != 0 } } # [doc = "Field `ITBUFEN` reader - Buffer interrupt enable"] pub type ItbufenR = crate :: BitReader < Itbufen > ; impl ItbufenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Itbufen { match self . bits { false => Itbufen :: Disabled , true => Itbufen :: Enabled , } } # [doc = "TxE=1 or RxNE=1 does not generate any interrupt"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Itbufen :: Disabled } # [doc = "TxE=1 or RxNE=1 generates Event interrupt"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Itbufen :: Enabled } } # [doc = "Field `ITBUFEN` writer - Buffer interrupt enable"] pub type ItbufenW < 'a , REG > = crate :: BitWriter < 'a , REG , Itbufen > ; impl < 'a , REG > ItbufenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TxE=1 or RxNE=1 does not generate any interrupt"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Itbufen :: Disabled) } # [doc = "TxE=1 or RxNE=1 generates Event interrupt"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Itbufen :: Enabled) } } # [doc = "DMA requests enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaen { # [doc = "0: DMA requests disabled"] Disabled = 0 , # [doc = "1: DMA request enabled when TxE=1 or RxNE=1"] Enabled = 1 , } impl From < Dmaen > for bool { # [inline (always)] fn from (variant : Dmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN` reader - DMA requests enable"] pub type DmaenR = crate :: BitReader < Dmaen > ; impl DmaenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaen { match self . bits { false => Dmaen :: Disabled , true => Dmaen :: Enabled , } } # [doc = "DMA requests disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmaen :: Disabled } # [doc = "DMA request enabled when TxE=1 or RxNE=1"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmaen :: Enabled } } # [doc = "Field `DMAEN` writer - DMA requests enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen > ; impl < 'a , REG > DmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DMA requests disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Disabled) } # [doc = "DMA request enabled when TxE=1 or RxNE=1"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Enabled) } } # [doc = "DMA last transfer\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Last { # [doc = "0: Next DMA EOT is not the last transfer"] NotLast = 0 , # [doc = "1: Next DMA EOT is the last transfer"] Last = 1 , } impl From < Last > for bool { # [inline (always)] fn from (variant : Last) -> Self { variant as u8 != 0 } } # [doc = "Field `LAST` reader - DMA last transfer"] pub type LastR = crate :: BitReader < Last > ; impl LastR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Last { match self . bits { false => Last :: NotLast , true => Last :: Last , } } # [doc = "Next DMA EOT is not the last transfer"] # [inline (always)] pub fn is_not_last (& self) -> bool { * self == Last :: NotLast } # [doc = "Next DMA EOT is the last transfer"] # [inline (always)] pub fn is_last (& self) -> bool { * self == Last :: Last } } # [doc = "Field `LAST` writer - DMA last transfer"] pub type LastW < 'a , REG > = crate :: BitWriter < 'a , REG , Last > ; impl < 'a , REG > LastW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Next DMA EOT is not the last transfer"] # [inline (always)] pub fn not_last (self) -> & 'a mut crate :: W < REG > { self . variant (Last :: NotLast) } # [doc = "Next DMA EOT is the last transfer"] # [inline (always)] pub fn last (self) -> & 'a mut crate :: W < REG > { self . variant (Last :: Last) } } impl R { # [doc = "Bits 0:5 - Peripheral clock frequency"] # [inline (always)] pub fn freq (& self) -> FreqR { FreqR :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 8 - Error interrupt enable"] # [inline (always)] pub fn iterren (& self) -> IterrenR { IterrenR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Event interrupt enable"] # [inline (always)] pub fn itevten (& self) -> ItevtenR { ItevtenR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Buffer interrupt enable"] # [inline (always)] pub fn itbufen (& self) -> ItbufenR { ItbufenR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - DMA requests enable"] # [inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - DMA last transfer"] # [inline (always)] pub fn last (& self) -> LastR { LastR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Peripheral clock frequency"] # [inline (always)] pub fn freq (& mut self) -> FreqW < Cr2Spec > { FreqW :: new (self , 0) } # [doc = "Bit 8 - Error interrupt enable"] # [inline (always)] pub fn iterren (& mut self) -> IterrenW < Cr2Spec > { IterrenW :: new (self , 8) } # [doc = "Bit 9 - Event interrupt enable"] # [inline (always)] pub fn itevten (& mut self) -> ItevtenW < Cr2Spec > { ItevtenW :: new (self , 9) } # [doc = "Bit 10 - Buffer interrupt enable"] # [inline (always)] pub fn itbufen (& mut self) -> ItbufenW < Cr2Spec > { ItbufenW :: new (self , 10) } # [doc = "Bit 11 - DMA requests enable"] # [inline (always)] pub fn dmaen (& mut self) -> DmaenW < Cr2Spec > { DmaenW :: new (self , 11) } # [doc = "Bit 12 - DMA last transfer"] # [inline (always)] pub fn last (& mut self) -> LastW < Cr2Spec > { LastW :: new (self , 12) } } # [doc = "Control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { } # [doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { }
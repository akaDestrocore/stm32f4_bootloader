# [doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ; # [doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ; # [doc = "System clock switch\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Sw { # [doc = "0: HSI selected as system clock"] Hsi = 0 , # [doc = "1: HSE selected as system clock"] Hse = 1 , # [doc = "2: PLL selected as system clock"] Pll = 2 , } impl From < Sw > for u8 { # [inline (always)] fn from (variant : Sw) -> Self { variant as _ } } impl crate :: FieldSpec for Sw { type Ux = u8 ; } impl crate :: IsEnum for Sw { } # [doc = "Field `SW` reader - System clock switch"] pub type SwR = crate :: FieldReader < Sw > ; impl SwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Sw > { match self . bits { 0 => Some (Sw :: Hsi) , 1 => Some (Sw :: Hse) , 2 => Some (Sw :: Pll) , _ => None , } } # [doc = "HSI selected as system clock"] # [inline (always)] pub fn is_hsi (& self) -> bool { * self == Sw :: Hsi } # [doc = "HSE selected as system clock"] # [inline (always)] pub fn is_hse (& self) -> bool { * self == Sw :: Hse } # [doc = "PLL selected as system clock"] # [inline (always)] pub fn is_pll (& self) -> bool { * self == Sw :: Pll } } # [doc = "Field `SW` writer - System clock switch"] pub type SwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Sw > ; impl < 'a , REG > SwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "HSI selected as system clock"] # [inline (always)] pub fn hsi (self) -> & 'a mut crate :: W < REG > { self . variant (Sw :: Hsi) } # [doc = "HSE selected as system clock"] # [inline (always)] pub fn hse (self) -> & 'a mut crate :: W < REG > { self . variant (Sw :: Hse) } # [doc = "PLL selected as system clock"] # [inline (always)] pub fn pll (self) -> & 'a mut crate :: W < REG > { self . variant (Sw :: Pll) } } # [doc = "System clock switch status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Swsr { # [doc = "0: HSI oscillator used as system clock"] Hsi = 0 , # [doc = "1: HSE oscillator used as system clock"] Hse = 1 , # [doc = "2: PLL used as system clock"] Pll = 2 , } impl From < Swsr > for u8 { # [inline (always)] fn from (variant : Swsr) -> Self { variant as _ } } impl crate :: FieldSpec for Swsr { type Ux = u8 ; } impl crate :: IsEnum for Swsr { } # [doc = "Field `SWS` reader - System clock switch status"] pub type SwsR = crate :: FieldReader < Swsr > ; impl SwsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Swsr > { match self . bits { 0 => Some (Swsr :: Hsi) , 1 => Some (Swsr :: Hse) , 2 => Some (Swsr :: Pll) , _ => None , } } # [doc = "HSI oscillator used as system clock"] # [inline (always)] pub fn is_hsi (& self) -> bool { * self == Swsr :: Hsi } # [doc = "HSE oscillator used as system clock"] # [inline (always)] pub fn is_hse (& self) -> bool { * self == Swsr :: Hse } # [doc = "PLL used as system clock"] # [inline (always)] pub fn is_pll (& self) -> bool { * self == Swsr :: Pll } } # [doc = "Field `SWS` writer - System clock switch status"] pub type SwsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Swsr > ; impl < 'a , REG > SwsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "HSI oscillator used as system clock"] # [inline (always)] pub fn hsi (self) -> & 'a mut crate :: W < REG > { self . variant (Swsr :: Hsi) } # [doc = "HSE oscillator used as system clock"] # [inline (always)] pub fn hse (self) -> & 'a mut crate :: W < REG > { self . variant (Swsr :: Hse) } # [doc = "PLL used as system clock"] # [inline (always)] pub fn pll (self) -> & 'a mut crate :: W < REG > { self . variant (Swsr :: Pll) } } # [doc = "AHB prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Hpre { # [doc = "8: SYSCLK divided by 2"] Div2 = 8 , # [doc = "9: SYSCLK divided by 4"] Div4 = 9 , # [doc = "10: SYSCLK divided by 8"] Div8 = 10 , # [doc = "11: SYSCLK divided by 16"] Div16 = 11 , # [doc = "12: SYSCLK divided by 64"] Div64 = 12 , # [doc = "13: SYSCLK divided by 128"] Div128 = 13 , # [doc = "14: SYSCLK divided by 256"] Div256 = 14 , # [doc = "15: SYSCLK divided by 512"] Div512 = 15 , # [doc = "0: SYSCLK not divided"] Div1 = 0 , } impl From < Hpre > for u8 { # [inline (always)] fn from (variant : Hpre) -> Self { variant as _ } } impl crate :: FieldSpec for Hpre { type Ux = u8 ; } impl crate :: IsEnum for Hpre { } # [doc = "Field `HPRE` reader - AHB prescaler"] pub type HpreR = crate :: FieldReader < Hpre > ; impl HpreR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hpre { match self . bits { 8 => Hpre :: Div2 , 9 => Hpre :: Div4 , 10 => Hpre :: Div8 , 11 => Hpre :: Div16 , 12 => Hpre :: Div64 , 13 => Hpre :: Div128 , 14 => Hpre :: Div256 , 15 => Hpre :: Div512 , _ => Hpre :: Div1 , } } # [doc = "SYSCLK divided by 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Hpre :: Div2 } # [doc = "SYSCLK divided by 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Hpre :: Div4 } # [doc = "SYSCLK divided by 8"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Hpre :: Div8 } # [doc = "SYSCLK divided by 16"] # [inline (always)] pub fn is_div16 (& self) -> bool { * self == Hpre :: Div16 } # [doc = "SYSCLK divided by 64"] # [inline (always)] pub fn is_div64 (& self) -> bool { * self == Hpre :: Div64 } # [doc = "SYSCLK divided by 128"] # [inline (always)] pub fn is_div128 (& self) -> bool { * self == Hpre :: Div128 } # [doc = "SYSCLK divided by 256"] # [inline (always)] pub fn is_div256 (& self) -> bool { * self == Hpre :: Div256 } # [doc = "SYSCLK divided by 512"] # [inline (always)] pub fn is_div512 (& self) -> bool { * self == Hpre :: Div512 } # [doc = "SYSCLK not divided"] # [inline (always)] pub fn is_div1 (& self) -> bool { matches ! (self . variant () , Hpre :: Div1) } } # [doc = "Field `HPRE` writer - AHB prescaler"] pub type HpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Hpre , crate :: Safe > ; impl < 'a , REG > HpreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SYSCLK divided by 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div2) } # [doc = "SYSCLK divided by 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div4) } # [doc = "SYSCLK divided by 8"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div8) } # [doc = "SYSCLK divided by 16"] # [inline (always)] pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div16) } # [doc = "SYSCLK divided by 64"] # [inline (always)] pub fn div64 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div64) } # [doc = "SYSCLK divided by 128"] # [inline (always)] pub fn div128 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div128) } # [doc = "SYSCLK divided by 256"] # [inline (always)] pub fn div256 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div256) } # [doc = "SYSCLK divided by 512"] # [inline (always)] pub fn div512 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div512) } # [doc = "SYSCLK not divided"] # [inline (always)] pub fn div1 (self) -> & 'a mut crate :: W < REG > { self . variant (Hpre :: Div1) } } # [doc = "APB Low speed prescaler (APB1)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ppre1 { # [doc = "4: HCLK divided by 2"] Div2 = 4 , # [doc = "5: HCLK divided by 4"] Div4 = 5 , # [doc = "6: HCLK divided by 8"] Div8 = 6 , # [doc = "7: HCLK divided by 16"] Div16 = 7 , # [doc = "0: HCLK not divided"] Div1 = 0 , } impl From < Ppre1 > for u8 { # [inline (always)] fn from (variant : Ppre1) -> Self { variant as _ } } impl crate :: FieldSpec for Ppre1 { type Ux = u8 ; } impl crate :: IsEnum for Ppre1 { } # [doc = "Field `PPRE1` reader - APB Low speed prescaler (APB1)"] pub type Ppre1R = crate :: FieldReader < Ppre1 > ; impl Ppre1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ppre1 { match self . bits { 4 => Ppre1 :: Div2 , 5 => Ppre1 :: Div4 , 6 => Ppre1 :: Div8 , 7 => Ppre1 :: Div16 , _ => Ppre1 :: Div1 , } } # [doc = "HCLK divided by 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Ppre1 :: Div2 } # [doc = "HCLK divided by 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Ppre1 :: Div4 } # [doc = "HCLK divided by 8"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Ppre1 :: Div8 } # [doc = "HCLK divided by 16"] # [inline (always)] pub fn is_div16 (& self) -> bool { * self == Ppre1 :: Div16 } # [doc = "HCLK not divided"] # [inline (always)] pub fn is_div1 (& self) -> bool { matches ! (self . variant () , Ppre1 :: Div1) } } # [doc = "Field `PPRE1` writer - APB Low speed prescaler (APB1)"] pub type Ppre1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Ppre1 , crate :: Safe > ; impl < 'a , REG > Ppre1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "HCLK divided by 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Ppre1 :: Div2) } # [doc = "HCLK divided by 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Ppre1 :: Div4) } # [doc = "HCLK divided by 8"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Ppre1 :: Div8) } # [doc = "HCLK divided by 16"] # [inline (always)] pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (Ppre1 :: Div16) } # [doc = "HCLK not divided"] # [inline (always)] pub fn div1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ppre1 :: Div1) } } # [doc = "Field `PPRE2` reader - APB high-speed prescaler (APB2)"] pub use Ppre1R as Ppre2R ; # [doc = "Field `PPRE2` writer - APB high-speed prescaler (APB2)"] pub use Ppre1W as Ppre2W ; # [doc = "Field `RTCPRE` reader - HSE division factor for RTC clock"] pub type RtcpreR = crate :: FieldReader ; # [doc = "Field `RTCPRE` writer - HSE division factor for RTC clock"] pub type RtcpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 , u8 , crate :: Safe > ; # [doc = "Microcontroller clock output 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Mco1 { # [doc = "0: HSI clock selected"] Hsi = 0 , # [doc = "1: LSE oscillator selected"] Lse = 1 , # [doc = "2: HSE oscillator clock selected"] Hse = 2 , # [doc = "3: PLL clock selected"] Pll = 3 , } impl From < Mco1 > for u8 { # [inline (always)] fn from (variant : Mco1) -> Self { variant as _ } } impl crate :: FieldSpec for Mco1 { type Ux = u8 ; } impl crate :: IsEnum for Mco1 { } # [doc = "Field `MCO1` reader - Microcontroller clock output 1"] pub type Mco1R = crate :: FieldReader < Mco1 > ; impl Mco1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mco1 { match self . bits { 0 => Mco1 :: Hsi , 1 => Mco1 :: Lse , 2 => Mco1 :: Hse , 3 => Mco1 :: Pll , _ => unreachable ! () , } } # [doc = "HSI clock selected"] # [inline (always)] pub fn is_hsi (& self) -> bool { * self == Mco1 :: Hsi } # [doc = "LSE oscillator selected"] # [inline (always)] pub fn is_lse (& self) -> bool { * self == Mco1 :: Lse } # [doc = "HSE oscillator clock selected"] # [inline (always)] pub fn is_hse (& self) -> bool { * self == Mco1 :: Hse } # [doc = "PLL clock selected"] # [inline (always)] pub fn is_pll (& self) -> bool { * self == Mco1 :: Pll } } # [doc = "Field `MCO1` writer - Microcontroller clock output 1"] pub type Mco1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mco1 , crate :: Safe > ; impl < 'a , REG > Mco1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "HSI clock selected"] # [inline (always)] pub fn hsi (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1 :: Hsi) } # [doc = "LSE oscillator selected"] # [inline (always)] pub fn lse (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1 :: Lse) } # [doc = "HSE oscillator clock selected"] # [inline (always)] pub fn hse (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1 :: Hse) } # [doc = "PLL clock selected"] # [inline (always)] pub fn pll (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1 :: Pll) } } # [doc = "I2S clock selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum I2ssrc { # [doc = "0: PLLI2S clock used as I2S clock source"] Plli2s = 0 , # [doc = "1: External clock mapped on the I2S_CKIN pin used as I2S clock source"] Ckin = 1 , } impl From < I2ssrc > for bool { # [inline (always)] fn from (variant : I2ssrc) -> Self { variant as u8 != 0 } } # [doc = "Field `I2SSRC` reader - I2S clock selection"] pub type I2ssrcR = crate :: BitReader < I2ssrc > ; impl I2ssrcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> I2ssrc { match self . bits { false => I2ssrc :: Plli2s , true => I2ssrc :: Ckin , } } # [doc = "PLLI2S clock used as I2S clock source"] # [inline (always)] pub fn is_plli2s (& self) -> bool { * self == I2ssrc :: Plli2s } # [doc = "External clock mapped on the I2S_CKIN pin used as I2S clock source"] # [inline (always)] pub fn is_ckin (& self) -> bool { * self == I2ssrc :: Ckin } } # [doc = "Field `I2SSRC` writer - I2S clock selection"] pub type I2ssrcW < 'a , REG > = crate :: BitWriter < 'a , REG , I2ssrc > ; impl < 'a , REG > I2ssrcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PLLI2S clock used as I2S clock source"] # [inline (always)] pub fn plli2s (self) -> & 'a mut crate :: W < REG > { self . variant (I2ssrc :: Plli2s) } # [doc = "External clock mapped on the I2S_CKIN pin used as I2S clock source"] # [inline (always)] pub fn ckin (self) -> & 'a mut crate :: W < REG > { self . variant (I2ssrc :: Ckin) } } # [doc = "MCO1 prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Mco1pre { # [doc = "4: Division by 2"] Div2 = 4 , # [doc = "5: Division by 3"] Div3 = 5 , # [doc = "6: Division by 4"] Div4 = 6 , # [doc = "7: Division by 5"] Div5 = 7 , # [doc = "0: No division"] Div1 = 0 , } impl From < Mco1pre > for u8 { # [inline (always)] fn from (variant : Mco1pre) -> Self { variant as _ } } impl crate :: FieldSpec for Mco1pre { type Ux = u8 ; } impl crate :: IsEnum for Mco1pre { } # [doc = "Field `MCO1PRE` reader - MCO1 prescaler"] pub type Mco1preR = crate :: FieldReader < Mco1pre > ; impl Mco1preR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mco1pre { match self . bits { 4 => Mco1pre :: Div2 , 5 => Mco1pre :: Div3 , 6 => Mco1pre :: Div4 , 7 => Mco1pre :: Div5 , _ => Mco1pre :: Div1 , } } # [doc = "Division by 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Mco1pre :: Div2 } # [doc = "Division by 3"] # [inline (always)] pub fn is_div3 (& self) -> bool { * self == Mco1pre :: Div3 } # [doc = "Division by 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Mco1pre :: Div4 } # [doc = "Division by 5"] # [inline (always)] pub fn is_div5 (& self) -> bool { * self == Mco1pre :: Div5 } # [doc = "No division"] # [inline (always)] pub fn is_div1 (& self) -> bool { matches ! (self . variant () , Mco1pre :: Div1) } } # [doc = "Field `MCO1PRE` writer - MCO1 prescaler"] pub type Mco1preW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Mco1pre , crate :: Safe > ; impl < 'a , REG > Mco1preW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Division by 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1pre :: Div2) } # [doc = "Division by 3"] # [inline (always)] pub fn div3 (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1pre :: Div3) } # [doc = "Division by 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1pre :: Div4) } # [doc = "Division by 5"] # [inline (always)] pub fn div5 (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1pre :: Div5) } # [doc = "No division"] # [inline (always)] pub fn div1 (self) -> & 'a mut crate :: W < REG > { self . variant (Mco1pre :: Div1) } } # [doc = "Field `MCO2PRE` reader - MCO2 prescaler"] pub use Mco1preR as Mco2preR ; # [doc = "Field `MCO2PRE` writer - MCO2 prescaler"] pub use Mco1preW as Mco2preW ; # [doc = "Microcontroller clock output 2\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Mco2 { # [doc = "0: System clock (SYSCLK) selected"] Sysclk = 0 , # [doc = "1: PLLI2S clock selected"] Plli2s = 1 , # [doc = "2: HSE oscillator clock selected"] Hse = 2 , # [doc = "3: PLL clock selected"] Pll = 3 , } impl From < Mco2 > for u8 { # [inline (always)] fn from (variant : Mco2) -> Self { variant as _ } } impl crate :: FieldSpec for Mco2 { type Ux = u8 ; } impl crate :: IsEnum for Mco2 { } # [doc = "Field `MCO2` reader - Microcontroller clock output 2"] pub type Mco2R = crate :: FieldReader < Mco2 > ; impl Mco2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mco2 { match self . bits { 0 => Mco2 :: Sysclk , 1 => Mco2 :: Plli2s , 2 => Mco2 :: Hse , 3 => Mco2 :: Pll , _ => unreachable ! () , } } # [doc = "System clock (SYSCLK) selected"] # [inline (always)] pub fn is_sysclk (& self) -> bool { * self == Mco2 :: Sysclk } # [doc = "PLLI2S clock selected"] # [inline (always)] pub fn is_plli2s (& self) -> bool { * self == Mco2 :: Plli2s } # [doc = "HSE oscillator clock selected"] # [inline (always)] pub fn is_hse (& self) -> bool { * self == Mco2 :: Hse } # [doc = "PLL clock selected"] # [inline (always)] pub fn is_pll (& self) -> bool { * self == Mco2 :: Pll } } # [doc = "Field `MCO2` writer - Microcontroller clock output 2"] pub type Mco2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mco2 , crate :: Safe > ; impl < 'a , REG > Mco2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "System clock (SYSCLK) selected"] # [inline (always)] pub fn sysclk (self) -> & 'a mut crate :: W < REG > { self . variant (Mco2 :: Sysclk) } # [doc = "PLLI2S clock selected"] # [inline (always)] pub fn plli2s (self) -> & 'a mut crate :: W < REG > { self . variant (Mco2 :: Plli2s) } # [doc = "HSE oscillator clock selected"] # [inline (always)] pub fn hse (self) -> & 'a mut crate :: W < REG > { self . variant (Mco2 :: Hse) } # [doc = "PLL clock selected"] # [inline (always)] pub fn pll (self) -> & 'a mut crate :: W < REG > { self . variant (Mco2 :: Pll) } } impl R { # [doc = "Bits 0:1 - System clock switch"] # [inline (always)] pub fn sw (& self) -> SwR { SwR :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - System clock switch status"] # [inline (always)] pub fn sws (& self) -> SwsR { SwsR :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:7 - AHB prescaler"] # [inline (always)] pub fn hpre (& self) -> HpreR { HpreR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 10:12 - APB Low speed prescaler (APB1)"] # [inline (always)] pub fn ppre1 (& self) -> Ppre1R { Ppre1R :: new (((self . bits >> 10) & 7) as u8) } # [doc = "Bits 13:15 - APB high-speed prescaler (APB2)"] # [inline (always)] pub fn ppre2 (& self) -> Ppre2R { Ppre2R :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 16:20 - HSE division factor for RTC clock"] # [inline (always)] pub fn rtcpre (& self) -> RtcpreR { RtcpreR :: new (((self . bits >> 16) & 0x1f) as u8) } # [doc = "Bits 21:22 - Microcontroller clock output 1"] # [inline (always)] pub fn mco1 (& self) -> Mco1R { Mco1R :: new (((self . bits >> 21) & 3) as u8) } # [doc = "Bit 23 - I2S clock selection"] # [inline (always)] pub fn i2ssrc (& self) -> I2ssrcR { I2ssrcR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:26 - MCO1 prescaler"] # [inline (always)] pub fn mco1pre (& self) -> Mco1preR { Mco1preR :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bits 27:29 - MCO2 prescaler"] # [inline (always)] pub fn mco2pre (& self) -> Mco2preR { Mco2preR :: new (((self . bits >> 27) & 7) as u8) } # [doc = "Bits 30:31 - Microcontroller clock output 2"] # [inline (always)] pub fn mco2 (& self) -> Mco2R { Mco2R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - System clock switch"] # [inline (always)] pub fn sw (& mut self) -> SwW < CfgrSpec > { SwW :: new (self , 0) } # [doc = "Bits 2:3 - System clock switch status"] # [inline (always)] pub fn sws (& mut self) -> SwsW < CfgrSpec > { SwsW :: new (self , 2) } # [doc = "Bits 4:7 - AHB prescaler"] # [inline (always)] pub fn hpre (& mut self) -> HpreW < CfgrSpec > { HpreW :: new (self , 4) } # [doc = "Bits 10:12 - APB Low speed prescaler (APB1)"] # [inline (always)] pub fn ppre1 (& mut self) -> Ppre1W < CfgrSpec > { Ppre1W :: new (self , 10) } # [doc = "Bits 13:15 - APB high-speed prescaler (APB2)"] # [inline (always)] pub fn ppre2 (& mut self) -> Ppre2W < CfgrSpec > { Ppre2W :: new (self , 13) } # [doc = "Bits 16:20 - HSE division factor for RTC clock"] # [inline (always)] pub fn rtcpre (& mut self) -> RtcpreW < CfgrSpec > { RtcpreW :: new (self , 16) } # [doc = "Bits 21:22 - Microcontroller clock output 1"] # [inline (always)] pub fn mco1 (& mut self) -> Mco1W < CfgrSpec > { Mco1W :: new (self , 21) } # [doc = "Bit 23 - I2S clock selection"] # [inline (always)] pub fn i2ssrc (& mut self) -> I2ssrcW < CfgrSpec > { I2ssrcW :: new (self , 23) } # [doc = "Bits 24:26 - MCO1 prescaler"] # [inline (always)] pub fn mco1pre (& mut self) -> Mco1preW < CfgrSpec > { Mco1preW :: new (self , 24) } # [doc = "Bits 27:29 - MCO2 prescaler"] # [inline (always)] pub fn mco2pre (& mut self) -> Mco2preW < CfgrSpec > { Mco2preW :: new (self , 27) } # [doc = "Bits 30:31 - Microcontroller clock output 2"] # [inline (always)] pub fn mco2 (& mut self) -> Mco2W < CfgrSpec > { Mco2W :: new (self , 30) } } # [doc = "clock configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { } # [doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { }
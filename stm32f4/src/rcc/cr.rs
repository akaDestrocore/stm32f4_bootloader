# [doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ; # [doc = "Internal high-speed clock enable\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hsion { # [doc = "0: Clock Off"] Off = 0 , # [doc = "1: Clock On"] On = 1 , } impl From < Hsion > for bool { # [inline (always)] fn from (variant : Hsion) -> Self { variant as u8 != 0 } } # [doc = "Field `HSION` reader - Internal high-speed clock enable"] pub type HsionR = crate :: BitReader < Hsion > ; impl HsionR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hsion { match self . bits { false => Hsion :: Off , true => Hsion :: On , } } # [doc = "Clock Off"] # [inline (always)] pub fn is_off (& self) -> bool { * self == Hsion :: Off } # [doc = "Clock On"] # [inline (always)] pub fn is_on (& self) -> bool { * self == Hsion :: On } } # [doc = "Field `HSION` writer - Internal high-speed clock enable"] pub type HsionW < 'a , REG > = crate :: BitWriter < 'a , REG , Hsion > ; impl < 'a , REG > HsionW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clock Off"] # [inline (always)] pub fn off (self) -> & 'a mut crate :: W < REG > { self . variant (Hsion :: Off) } # [doc = "Clock On"] # [inline (always)] pub fn on (self) -> & 'a mut crate :: W < REG > { self . variant (Hsion :: On) } } # [doc = "Internal high-speed clock ready flag\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hsirdyr { # [doc = "0: Clock not ready"] NotReady = 0 , # [doc = "1: Clock ready"] Ready = 1 , } impl From < Hsirdyr > for bool { # [inline (always)] fn from (variant : Hsirdyr) -> Self { variant as u8 != 0 } } # [doc = "Field `HSIRDY` reader - Internal high-speed clock ready flag"] pub type HsirdyR = crate :: BitReader < Hsirdyr > ; impl HsirdyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hsirdyr { match self . bits { false => Hsirdyr :: NotReady , true => Hsirdyr :: Ready , } } # [doc = "Clock not ready"] # [inline (always)] pub fn is_not_ready (& self) -> bool { * self == Hsirdyr :: NotReady } # [doc = "Clock ready"] # [inline (always)] pub fn is_ready (& self) -> bool { * self == Hsirdyr :: Ready } } # [doc = "Field `HSITRIM` reader - Internal high-speed clock trimming"] pub type HsitrimR = crate :: FieldReader ; # [doc = "Field `HSITRIM` writer - Internal high-speed clock trimming"] pub type HsitrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 , u8 , crate :: Safe > ; # [doc = "Field `HSICAL` reader - Internal high-speed clock calibration"] pub type HsicalR = crate :: FieldReader ; # [doc = "Field `HSEON` reader - HSE clock enable"] pub use HsionR as HseonR ; # [doc = "Field `HSEON` writer - HSE clock enable"] pub use HsionW as HseonW ; # [doc = "Field `HSERDY` reader - HSE clock ready flag"] pub use HsirdyR as HserdyR ; # [doc = "HSE clock bypass\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hsebyp { # [doc = "0: HSE crystal oscillator not bypassed"] NotBypassed = 0 , # [doc = "1: HSE crystal oscillator bypassed with external clock"] Bypassed = 1 , } impl From < Hsebyp > for bool { # [inline (always)] fn from (variant : Hsebyp) -> Self { variant as u8 != 0 } } # [doc = "Field `HSEBYP` reader - HSE clock bypass"] pub type HsebypR = crate :: BitReader < Hsebyp > ; impl HsebypR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hsebyp { match self . bits { false => Hsebyp :: NotBypassed , true => Hsebyp :: Bypassed , } } # [doc = "HSE crystal oscillator not bypassed"] # [inline (always)] pub fn is_not_bypassed (& self) -> bool { * self == Hsebyp :: NotBypassed } # [doc = "HSE crystal oscillator bypassed with external clock"] # [inline (always)] pub fn is_bypassed (& self) -> bool { * self == Hsebyp :: Bypassed } } # [doc = "Field `HSEBYP` writer - HSE clock bypass"] pub type HsebypW < 'a , REG > = crate :: BitWriter < 'a , REG , Hsebyp > ; impl < 'a , REG > HsebypW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "HSE crystal oscillator not bypassed"] # [inline (always)] pub fn not_bypassed (self) -> & 'a mut crate :: W < REG > { self . variant (Hsebyp :: NotBypassed) } # [doc = "HSE crystal oscillator bypassed with external clock"] # [inline (always)] pub fn bypassed (self) -> & 'a mut crate :: W < REG > { self . variant (Hsebyp :: Bypassed) } } # [doc = "Clock security system enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Csson { # [doc = "0: Clock security system disabled (clock detector OFF)"] Off = 0 , # [doc = "1: Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"] On = 1 , } impl From < Csson > for bool { # [inline (always)] fn from (variant : Csson) -> Self { variant as u8 != 0 } } # [doc = "Field `CSSON` reader - Clock security system enable"] pub type CssonR = crate :: BitReader < Csson > ; impl CssonR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Csson { match self . bits { false => Csson :: Off , true => Csson :: On , } } # [doc = "Clock security system disabled (clock detector OFF)"] # [inline (always)] pub fn is_off (& self) -> bool { * self == Csson :: Off } # [doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"] # [inline (always)] pub fn is_on (& self) -> bool { * self == Csson :: On } } # [doc = "Field `CSSON` writer - Clock security system enable"] pub type CssonW < 'a , REG > = crate :: BitWriter < 'a , REG , Csson > ; impl < 'a , REG > CssonW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clock security system disabled (clock detector OFF)"] # [inline (always)] pub fn off (self) -> & 'a mut crate :: W < REG > { self . variant (Csson :: Off) } # [doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"] # [inline (always)] pub fn on (self) -> & 'a mut crate :: W < REG > { self . variant (Csson :: On) } } # [doc = "Field `PLLON` reader - Main PLL (PLL) enable"] pub use HsionR as PllonR ; # [doc = "Field `PLLON` writer - Main PLL (PLL) enable"] pub use HsionW as PllonW ; # [doc = "Field `PLLRDY` reader - Main PLL (PLL) clock ready flag"] pub use HsirdyR as PllrdyR ; # [doc = "Field `PLLI2SON` reader - PLLI2S enable"] pub use HsionR as Plli2sonR ; # [doc = "Field `PLLI2SON` writer - PLLI2S enable"] pub use HsionW as Plli2sonW ; # [doc = "Field `PLLI2SRDY` reader - PLLI2S clock ready flag"] pub use HsirdyR as Plli2srdyR ; impl R { # [doc = "Bit 0 - Internal high-speed clock enable"] # [inline (always)] pub fn hsion (& self) -> HsionR { HsionR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Internal high-speed clock ready flag"] # [inline (always)] pub fn hsirdy (& self) -> HsirdyR { HsirdyR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 3:7 - Internal high-speed clock trimming"] # [inline (always)] pub fn hsitrim (& self) -> HsitrimR { HsitrimR :: new (((self . bits >> 3) & 0x1f) as u8) } # [doc = "Bits 8:15 - Internal high-speed clock calibration"] # [inline (always)] pub fn hsical (& self) -> HsicalR { HsicalR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bit 16 - HSE clock enable"] # [inline (always)] pub fn hseon (& self) -> HseonR { HseonR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - HSE clock ready flag"] # [inline (always)] pub fn hserdy (& self) -> HserdyR { HserdyR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - HSE clock bypass"] # [inline (always)] pub fn hsebyp (& self) -> HsebypR { HsebypR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Clock security system enable"] # [inline (always)] pub fn csson (& self) -> CssonR { CssonR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Main PLL (PLL) enable"] # [inline (always)] pub fn pllon (& self) -> PllonR { PllonR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Main PLL (PLL) clock ready flag"] # [inline (always)] pub fn pllrdy (& self) -> PllrdyR { PllrdyR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - PLLI2S enable"] # [inline (always)] pub fn plli2son (& self) -> Plli2sonR { Plli2sonR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - PLLI2S clock ready flag"] # [inline (always)] pub fn plli2srdy (& self) -> Plli2srdyR { Plli2srdyR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Internal high-speed clock enable"] # [inline (always)] pub fn hsion (& mut self) -> HsionW < CrSpec > { HsionW :: new (self , 0) } # [doc = "Bits 3:7 - Internal high-speed clock trimming"] # [inline (always)] pub fn hsitrim (& mut self) -> HsitrimW < CrSpec > { HsitrimW :: new (self , 3) } # [doc = "Bit 16 - HSE clock enable"] # [inline (always)] pub fn hseon (& mut self) -> HseonW < CrSpec > { HseonW :: new (self , 16) } # [doc = "Bit 18 - HSE clock bypass"] # [inline (always)] pub fn hsebyp (& mut self) -> HsebypW < CrSpec > { HsebypW :: new (self , 18) } # [doc = "Bit 19 - Clock security system enable"] # [inline (always)] pub fn csson (& mut self) -> CssonW < CrSpec > { CssonW :: new (self , 19) } # [doc = "Bit 24 - Main PLL (PLL) enable"] # [inline (always)] pub fn pllon (& mut self) -> PllonW < CrSpec > { PllonW :: new (self , 24) } # [doc = "Bit 26 - PLLI2S enable"] # [inline (always)] pub fn plli2son (& mut self) -> Plli2sonW < CrSpec > { Plli2sonW :: new (self , 26) } } # [doc = "clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR to value 0x83"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x83 ; }
# [doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ; # [doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ; # [doc = "Internal low-speed oscillator enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lsion { # [doc = "0: LSI oscillator Off"] Off = 0 , # [doc = "1: LSI oscillator On"] On = 1 , } impl From < Lsion > for bool { # [inline (always)] fn from (variant : Lsion) -> Self { variant as u8 != 0 } } # [doc = "Field `LSION` reader - Internal low-speed oscillator enable"] pub type LsionR = crate :: BitReader < Lsion > ; impl LsionR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lsion { match self . bits { false => Lsion :: Off , true => Lsion :: On , } } # [doc = "LSI oscillator Off"] # [inline (always)] pub fn is_off (& self) -> bool { * self == Lsion :: Off } # [doc = "LSI oscillator On"] # [inline (always)] pub fn is_on (& self) -> bool { * self == Lsion :: On } } # [doc = "Field `LSION` writer - Internal low-speed oscillator enable"] pub type LsionW < 'a , REG > = crate :: BitWriter < 'a , REG , Lsion > ; impl < 'a , REG > LsionW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "LSI oscillator Off"] # [inline (always)] pub fn off (self) -> & 'a mut crate :: W < REG > { self . variant (Lsion :: Off) } # [doc = "LSI oscillator On"] # [inline (always)] pub fn on (self) -> & 'a mut crate :: W < REG > { self . variant (Lsion :: On) } } # [doc = "Internal low-speed oscillator ready\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lsirdyr { # [doc = "0: LSI oscillator not ready"] NotReady = 0 , # [doc = "1: LSI oscillator ready"] Ready = 1 , } impl From < Lsirdyr > for bool { # [inline (always)] fn from (variant : Lsirdyr) -> Self { variant as u8 != 0 } } # [doc = "Field `LSIRDY` reader - Internal low-speed oscillator ready"] pub type LsirdyR = crate :: BitReader < Lsirdyr > ; impl LsirdyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lsirdyr { match self . bits { false => Lsirdyr :: NotReady , true => Lsirdyr :: Ready , } } # [doc = "LSI oscillator not ready"] # [inline (always)] pub fn is_not_ready (& self) -> bool { * self == Lsirdyr :: NotReady } # [doc = "LSI oscillator ready"] # [inline (always)] pub fn is_ready (& self) -> bool { * self == Lsirdyr :: Ready } } # [doc = "Remove reset flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rmvfw { # [doc = "1: Clears the reset flag"] Clear = 1 , } impl From < Rmvfw > for bool { # [inline (always)] fn from (variant : Rmvfw) -> Self { variant as u8 != 0 } } # [doc = "Field `RMVF` reader - Remove reset flag"] pub type RmvfR = crate :: BitReader < Rmvfw > ; impl RmvfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Rmvfw > { match self . bits { true => Some (Rmvfw :: Clear) , _ => None , } } # [doc = "Clears the reset flag"] # [inline (always)] pub fn is_clear (& self) -> bool { * self == Rmvfw :: Clear } } # [doc = "Field `RMVF` writer - Remove reset flag"] pub type RmvfW < 'a , REG > = crate :: BitWriter < 'a , REG , Rmvfw > ; impl < 'a , REG > RmvfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clears the reset flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (Rmvfw :: Clear) } } # [doc = "BOR reset flag\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Borrstfr { # [doc = "0: No reset has occured"] NoReset = 0 , # [doc = "1: A reset has occured"] Reset = 1 , } impl From < Borrstfr > for bool { # [inline (always)] fn from (variant : Borrstfr) -> Self { variant as u8 != 0 } } # [doc = "Field `BORRSTF` reader - BOR reset flag"] pub type BorrstfR = crate :: BitReader < Borrstfr > ; impl BorrstfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Borrstfr { match self . bits { false => Borrstfr :: NoReset , true => Borrstfr :: Reset , } } # [doc = "No reset has occured"] # [inline (always)] pub fn is_no_reset (& self) -> bool { * self == Borrstfr :: NoReset } # [doc = "A reset has occured"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == Borrstfr :: Reset } } # [doc = "Field `BORRSTF` writer - BOR reset flag"] pub type BorrstfW < 'a , REG > = crate :: BitWriter < 'a , REG , Borrstfr > ; impl < 'a , REG > BorrstfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No reset has occured"] # [inline (always)] pub fn no_reset (self) -> & 'a mut crate :: W < REG > { self . variant (Borrstfr :: NoReset) } # [doc = "A reset has occured"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Borrstfr :: Reset) } } # [doc = "Field `PADRSTF` reader - PIN reset flag"] pub use BorrstfR as PadrstfR ; # [doc = "Field `PADRSTF` writer - PIN reset flag"] pub use BorrstfW as PadrstfW ; # [doc = "Field `PORRSTF` reader - POR/PDR reset flag"] pub use BorrstfR as PorrstfR ; # [doc = "Field `PORRSTF` writer - POR/PDR reset flag"] pub use BorrstfW as PorrstfW ; # [doc = "Field `SFTRSTF` reader - Software reset flag"] pub use BorrstfR as SftrstfR ; # [doc = "Field `SFTRSTF` writer - Software reset flag"] pub use BorrstfW as SftrstfW ; # [doc = "Field `WDGRSTF` reader - Independent watchdog reset flag"] pub use BorrstfR as WdgrstfR ; # [doc = "Field `WDGRSTF` writer - Independent watchdog reset flag"] pub use BorrstfW as WdgrstfW ; # [doc = "Field `WWDGRSTF` reader - Window watchdog reset flag"] pub use BorrstfR as WwdgrstfR ; # [doc = "Field `WWDGRSTF` writer - Window watchdog reset flag"] pub use BorrstfW as WwdgrstfW ; # [doc = "Field `LPWRRSTF` reader - Low-power reset flag"] pub use BorrstfR as LpwrrstfR ; # [doc = "Field `LPWRRSTF` writer - Low-power reset flag"] pub use BorrstfW as LpwrrstfW ; impl R { # [doc = "Bit 0 - Internal low-speed oscillator enable"] # [inline (always)] pub fn lsion (& self) -> LsionR { LsionR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Internal low-speed oscillator ready"] # [inline (always)] pub fn lsirdy (& self) -> LsirdyR { LsirdyR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 24 - Remove reset flag"] # [inline (always)] pub fn rmvf (& self) -> RmvfR { RmvfR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - BOR reset flag"] # [inline (always)] pub fn borrstf (& self) -> BorrstfR { BorrstfR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - PIN reset flag"] # [inline (always)] pub fn padrstf (& self) -> PadrstfR { PadrstfR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - POR/PDR reset flag"] # [inline (always)] pub fn porrstf (& self) -> PorrstfR { PorrstfR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Software reset flag"] # [inline (always)] pub fn sftrstf (& self) -> SftrstfR { SftrstfR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Independent watchdog reset flag"] # [inline (always)] pub fn wdgrstf (& self) -> WdgrstfR { WdgrstfR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Window watchdog reset flag"] # [inline (always)] pub fn wwdgrstf (& self) -> WwdgrstfR { WwdgrstfR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Low-power reset flag"] # [inline (always)] pub fn lpwrrstf (& self) -> LpwrrstfR { LpwrrstfR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 0 - Internal low-speed oscillator enable"] # [inline (always)] pub fn lsion (& mut self) -> LsionW < CsrSpec > { LsionW :: new (self , 0) } # [doc = "Bit 24 - Remove reset flag"] # [inline (always)] pub fn rmvf (& mut self) -> RmvfW < CsrSpec > { RmvfW :: new (self , 24) } # [doc = "Bit 25 - BOR reset flag"] # [inline (always)] pub fn borrstf (& mut self) -> BorrstfW < CsrSpec > { BorrstfW :: new (self , 25) } # [doc = "Bit 26 - PIN reset flag"] # [inline (always)] pub fn padrstf (& mut self) -> PadrstfW < CsrSpec > { PadrstfW :: new (self , 26) } # [doc = "Bit 27 - POR/PDR reset flag"] # [inline (always)] pub fn porrstf (& mut self) -> PorrstfW < CsrSpec > { PorrstfW :: new (self , 27) } # [doc = "Bit 28 - Software reset flag"] # [inline (always)] pub fn sftrstf (& mut self) -> SftrstfW < CsrSpec > { SftrstfW :: new (self , 28) } # [doc = "Bit 29 - Independent watchdog reset flag"] # [inline (always)] pub fn wdgrstf (& mut self) -> WdgrstfW < CsrSpec > { WdgrstfW :: new (self , 29) } # [doc = "Bit 30 - Window watchdog reset flag"] # [inline (always)] pub fn wwdgrstf (& mut self) -> WwdgrstfW < CsrSpec > { WwdgrstfW :: new (self , 30) } # [doc = "Bit 31 - Low-power reset flag"] # [inline (always)] pub fn lpwrrstf (& mut self) -> LpwrrstfW < CsrSpec > { LpwrrstfW :: new (self , 31) } } # [doc = "clock control & status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { } # [doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CSR to value 0x0e00_0000"] impl crate :: Resettable for CsrSpec { const RESET_VALUE : u32 = 0x0e00_0000 ; }
# [doc = "Register `MMCCR` reader"] pub type R = crate :: R < MmccrSpec > ; # [doc = "Register `MMCCR` writer"] pub type W = crate :: W < MmccrSpec > ; # [doc = "Counter reset\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cr { # [doc = "1: Reset all counters. Cleared automatically"] Reset = 1 , } impl From < Cr > for bool { # [inline (always)] fn from (variant : Cr) -> Self { variant as u8 != 0 } } # [doc = "Field `CR` reader - Counter reset"] pub type CrR = crate :: BitReader < Cr > ; impl CrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Cr > { match self . bits { true => Some (Cr :: Reset) , _ => None , } } # [doc = "Reset all counters. Cleared automatically"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == Cr :: Reset } } # [doc = "Field `CR` writer - Counter reset"] pub type CrW < 'a , REG > = crate :: BitWriter < 'a , REG , Cr > ; impl < 'a , REG > CrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Reset all counters. Cleared automatically"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Cr :: Reset) } } # [doc = "Counter stop rollover\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Csr { # [doc = "0: Counters roll over to zero after reaching the maximum value"] Disabled = 0 , # [doc = "1: Counters do not roll over to zero after reaching the maximum value"] Enabled = 1 , } impl From < Csr > for bool { # [inline (always)] fn from (variant : Csr) -> Self { variant as u8 != 0 } } # [doc = "Field `CSR` reader - Counter stop rollover"] pub type CsrR = crate :: BitReader < Csr > ; impl CsrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Csr { match self . bits { false => Csr :: Disabled , true => Csr :: Enabled , } } # [doc = "Counters roll over to zero after reaching the maximum value"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Csr :: Disabled } # [doc = "Counters do not roll over to zero after reaching the maximum value"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Csr :: Enabled } } # [doc = "Field `CSR` writer - Counter stop rollover"] pub type CsrW < 'a , REG > = crate :: BitWriter < 'a , REG , Csr > ; impl < 'a , REG > CsrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counters roll over to zero after reaching the maximum value"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Csr :: Disabled) } # [doc = "Counters do not roll over to zero after reaching the maximum value"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Csr :: Enabled) } } # [doc = "Reset on read\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ror { # [doc = "0: MMC counters do not reset on read"] Disabled = 0 , # [doc = "1: MMC counters reset to zero after read"] Enabled = 1 , } impl From < Ror > for bool { # [inline (always)] fn from (variant : Ror) -> Self { variant as u8 != 0 } } # [doc = "Field `ROR` reader - Reset on read"] pub type RorR = crate :: BitReader < Ror > ; impl RorR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ror { match self . bits { false => Ror :: Disabled , true => Ror :: Enabled , } } # [doc = "MMC counters do not reset on read"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ror :: Disabled } # [doc = "MMC counters reset to zero after read"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ror :: Enabled } } # [doc = "Field `ROR` writer - Reset on read"] pub type RorW < 'a , REG > = crate :: BitWriter < 'a , REG , Ror > ; impl < 'a , REG > RorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MMC counters do not reset on read"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ror :: Disabled) } # [doc = "MMC counters reset to zero after read"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ror :: Enabled) } } # [doc = "MMC counter freeze\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mcf { # [doc = "0: All MMC counters update normally"] Unfrozen = 0 , # [doc = "1: All MMC counters frozen to their current value"] Frozen = 1 , } impl From < Mcf > for bool { # [inline (always)] fn from (variant : Mcf) -> Self { variant as u8 != 0 } } # [doc = "Field `MCF` reader - MMC counter freeze"] pub type McfR = crate :: BitReader < Mcf > ; impl McfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mcf { match self . bits { false => Mcf :: Unfrozen , true => Mcf :: Frozen , } } # [doc = "All MMC counters update normally"] # [inline (always)] pub fn is_unfrozen (& self) -> bool { * self == Mcf :: Unfrozen } # [doc = "All MMC counters frozen to their current value"] # [inline (always)] pub fn is_frozen (& self) -> bool { * self == Mcf :: Frozen } } # [doc = "Field `MCF` writer - MMC counter freeze"] pub type McfW < 'a , REG > = crate :: BitWriter < 'a , REG , Mcf > ; impl < 'a , REG > McfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "All MMC counters update normally"] # [inline (always)] pub fn unfrozen (self) -> & 'a mut crate :: W < REG > { self . variant (Mcf :: Unfrozen) } # [doc = "All MMC counters frozen to their current value"] # [inline (always)] pub fn frozen (self) -> & 'a mut crate :: W < REG > { self . variant (Mcf :: Frozen) } } # [doc = "MMC counter preset\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mcp { # [doc = "1: MMC counters will be preset to almost full or almost half. Cleared automatically"] Preset = 1 , } impl From < Mcp > for bool { # [inline (always)] fn from (variant : Mcp) -> Self { variant as u8 != 0 } } # [doc = "Field `MCP` reader - MMC counter preset"] pub type McpR = crate :: BitReader < Mcp > ; impl McpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Mcp > { match self . bits { true => Some (Mcp :: Preset) , _ => None , } } # [doc = "MMC counters will be preset to almost full or almost half. Cleared automatically"] # [inline (always)] pub fn is_preset (& self) -> bool { * self == Mcp :: Preset } } # [doc = "Field `MCP` writer - MMC counter preset"] pub type McpW < 'a , REG > = crate :: BitWriter < 'a , REG , Mcp > ; impl < 'a , REG > McpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MMC counters will be preset to almost full or almost half. Cleared automatically"] # [inline (always)] pub fn preset (self) -> & 'a mut crate :: W < REG > { self . variant (Mcp :: Preset) } } # [doc = "MMC counter Full-Half preset\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mcfhp { # [doc = "0: When MCP is set, MMC counters are preset to almost-half value 0x7FFF_FFF0"] AlmostHalf = 0 , # [doc = "1: When MCP is set, MMC counters are preset to almost-full value 0xFFFF_FFF0"] AlmostFull = 1 , } impl From < Mcfhp > for bool { # [inline (always)] fn from (variant : Mcfhp) -> Self { variant as u8 != 0 } } # [doc = "Field `MCFHP` reader - MMC counter Full-Half preset"] pub type McfhpR = crate :: BitReader < Mcfhp > ; impl McfhpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mcfhp { match self . bits { false => Mcfhp :: AlmostHalf , true => Mcfhp :: AlmostFull , } } # [doc = "When MCP is set, MMC counters are preset to almost-half value 0x7FFF_FFF0"] # [inline (always)] pub fn is_almost_half (& self) -> bool { * self == Mcfhp :: AlmostHalf } # [doc = "When MCP is set, MMC counters are preset to almost-full value 0xFFFF_FFF0"] # [inline (always)] pub fn is_almost_full (& self) -> bool { * self == Mcfhp :: AlmostFull } } # [doc = "Field `MCFHP` writer - MMC counter Full-Half preset"] pub type McfhpW < 'a , REG > = crate :: BitWriter < 'a , REG , Mcfhp > ; impl < 'a , REG > McfhpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "When MCP is set, MMC counters are preset to almost-half value 0x7FFF_FFF0"] # [inline (always)] pub fn almost_half (self) -> & 'a mut crate :: W < REG > { self . variant (Mcfhp :: AlmostHalf) } # [doc = "When MCP is set, MMC counters are preset to almost-full value 0xFFFF_FFF0"] # [inline (always)] pub fn almost_full (self) -> & 'a mut crate :: W < REG > { self . variant (Mcfhp :: AlmostFull) } } impl R { # [doc = "Bit 0 - Counter reset"] # [inline (always)] pub fn cr (& self) -> CrR { CrR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Counter stop rollover"] # [inline (always)] pub fn csr (& self) -> CsrR { CsrR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Reset on read"] # [inline (always)] pub fn ror (& self) -> RorR { RorR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - MMC counter freeze"] # [inline (always)] pub fn mcf (& self) -> McfR { McfR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - MMC counter preset"] # [inline (always)] pub fn mcp (& self) -> McpR { McpR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - MMC counter Full-Half preset"] # [inline (always)] pub fn mcfhp (& self) -> McfhpR { McfhpR :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Counter reset"] # [inline (always)] pub fn cr (& mut self) -> CrW < MmccrSpec > { CrW :: new (self , 0) } # [doc = "Bit 1 - Counter stop rollover"] # [inline (always)] pub fn csr (& mut self) -> CsrW < MmccrSpec > { CsrW :: new (self , 1) } # [doc = "Bit 2 - Reset on read"] # [inline (always)] pub fn ror (& mut self) -> RorW < MmccrSpec > { RorW :: new (self , 2) } # [doc = "Bit 3 - MMC counter freeze"] # [inline (always)] pub fn mcf (& mut self) -> McfW < MmccrSpec > { McfW :: new (self , 3) } # [doc = "Bit 4 - MMC counter preset"] # [inline (always)] pub fn mcp (& mut self) -> McpW < MmccrSpec > { McpW :: new (self , 4) } # [doc = "Bit 5 - MMC counter Full-Half preset"] # [inline (always)] pub fn mcfhp (& mut self) -> McfhpW < MmccrSpec > { McfhpW :: new (self , 5) } } # [doc = "Ethernet MMC control register\n\nYou can [`read`](crate::Reg::read) this register and get [`mmccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mmccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MmccrSpec ; impl crate :: RegisterSpec for MmccrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mmccr::R`](R) reader structure"] impl crate :: Readable for MmccrSpec { } # [doc = "`write(|w| ..)` method takes [`mmccr::W`](W) writer structure"] impl crate :: Writable for MmccrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets MMCCR to value 0"] impl crate :: Resettable for MmccrSpec { }
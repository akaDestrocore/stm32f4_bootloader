# [doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ; # [doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ; # [doc = "Capture/Compare 1 selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Cc1s { # [doc = "1: CC1 channel is configured as input, IC1 is mapped on TI1"] Ti1 = 1 , # [doc = "2: CC1 channel is configured as input, IC1 is mapped on TI2"] Ti2 = 2 , # [doc = "3: CC1 channel is configured as input, IC1 is mapped on TRC"] Trc = 3 , } impl From < Cc1s > for u8 { # [inline (always)] fn from (variant : Cc1s) -> Self { variant as _ } } impl crate :: FieldSpec for Cc1s { type Ux = u8 ; } impl crate :: IsEnum for Cc1s { } # [doc = "Field `CC1S` reader - Capture/Compare 1 selection"] pub type Cc1sR = crate :: FieldReader < Cc1s > ; impl Cc1sR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Cc1s > { match self . bits { 1 => Some (Cc1s :: Ti1) , 2 => Some (Cc1s :: Ti2) , 3 => Some (Cc1s :: Trc) , _ => None , } } # [doc = "CC1 channel is configured as input, IC1 is mapped on TI1"] # [inline (always)] pub fn is_ti1 (& self) -> bool { * self == Cc1s :: Ti1 } # [doc = "CC1 channel is configured as input, IC1 is mapped on TI2"] # [inline (always)] pub fn is_ti2 (& self) -> bool { * self == Cc1s :: Ti2 } # [doc = "CC1 channel is configured as input, IC1 is mapped on TRC"] # [inline (always)] pub fn is_trc (& self) -> bool { * self == Cc1s :: Trc } } # [doc = "Field `CC1S` writer - Capture/Compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Cc1s > ; impl < 'a , REG > Cc1sW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CC1 channel is configured as input, IC1 is mapped on TI1"] # [inline (always)] pub fn ti1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cc1s :: Ti1) } # [doc = "CC1 channel is configured as input, IC1 is mapped on TI2"] # [inline (always)] pub fn ti2 (self) -> & 'a mut crate :: W < REG > { self . variant (Cc1s :: Ti2) } # [doc = "CC1 channel is configured as input, IC1 is mapped on TRC"] # [inline (always)] pub fn trc (self) -> & 'a mut crate :: W < REG > { self . variant (Cc1s :: Trc) } } # [doc = "Input capture %s prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Icprescaler { # [doc = "0: No prescaler, capture is done each time an edge is detected on the capture input"] NoPrescaler = 0 , # [doc = "1: Capture is done once every 2 events"] TwoEvents = 1 , # [doc = "2: Capture is done once every 4 events"] FourEvents = 2 , # [doc = "3: Capture is done once every 8 events"] EightEvents = 3 , } impl From < Icprescaler > for u8 { # [inline (always)] fn from (variant : Icprescaler) -> Self { variant as _ } } impl crate :: FieldSpec for Icprescaler { type Ux = u8 ; } impl crate :: IsEnum for Icprescaler { } # [doc = "Field `ICPSC(1-2)` reader - Input capture %s prescaler"] pub type IcpscR = crate :: FieldReader < Icprescaler > ; impl IcpscR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Icprescaler { match self . bits { 0 => Icprescaler :: NoPrescaler , 1 => Icprescaler :: TwoEvents , 2 => Icprescaler :: FourEvents , 3 => Icprescaler :: EightEvents , _ => unreachable ! () , } } # [doc = "No prescaler, capture is done each time an edge is detected on the capture input"] # [inline (always)] pub fn is_no_prescaler (& self) -> bool { * self == Icprescaler :: NoPrescaler } # [doc = "Capture is done once every 2 events"] # [inline (always)] pub fn is_two_events (& self) -> bool { * self == Icprescaler :: TwoEvents } # [doc = "Capture is done once every 4 events"] # [inline (always)] pub fn is_four_events (& self) -> bool { * self == Icprescaler :: FourEvents } # [doc = "Capture is done once every 8 events"] # [inline (always)] pub fn is_eight_events (& self) -> bool { * self == Icprescaler :: EightEvents } } # [doc = "Field `ICPSC(1-2)` writer - Input capture %s prescaler"] pub type IcpscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Icprescaler , crate :: Safe > ; impl < 'a , REG > IcpscW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No prescaler, capture is done each time an edge is detected on the capture input"] # [inline (always)] pub fn no_prescaler (self) -> & 'a mut crate :: W < REG > { self . variant (Icprescaler :: NoPrescaler) } # [doc = "Capture is done once every 2 events"] # [inline (always)] pub fn two_events (self) -> & 'a mut crate :: W < REG > { self . variant (Icprescaler :: TwoEvents) } # [doc = "Capture is done once every 4 events"] # [inline (always)] pub fn four_events (self) -> & 'a mut crate :: W < REG > { self . variant (Icprescaler :: FourEvents) } # [doc = "Capture is done once every 8 events"] # [inline (always)] pub fn eight_events (self) -> & 'a mut crate :: W < REG > { self . variant (Icprescaler :: EightEvents) } } # [doc = "Input capture %s filter\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Icfilter { # [doc = "0: No filter, sampling is done at fDTS"] NoFilter = 0 , # [doc = "1: fSAMPLING=fCK_INT, N=2"] FckIntN2 = 1 , # [doc = "2: fSAMPLING=fCK_INT, N=4"] FckIntN4 = 2 , # [doc = "3: fSAMPLING=fCK_INT, N=8"] FckIntN8 = 3 , # [doc = "4: fSAMPLING=fDTS/2, N=6"] FdtsDiv2N6 = 4 , # [doc = "5: fSAMPLING=fDTS/2, N=8"] FdtsDiv2N8 = 5 , # [doc = "6: fSAMPLING=fDTS/4, N=6"] FdtsDiv4N6 = 6 , # [doc = "7: fSAMPLING=fDTS/4, N=8"] FdtsDiv4N8 = 7 , # [doc = "8: fSAMPLING=fDTS/8, N=6"] FdtsDiv8N6 = 8 , # [doc = "9: fSAMPLING=fDTS/8, N=8"] FdtsDiv8N8 = 9 , # [doc = "10: fSAMPLING=fDTS/16, N=5"] FdtsDiv16N5 = 10 , # [doc = "11: fSAMPLING=fDTS/16, N=6"] FdtsDiv16N6 = 11 , # [doc = "12: fSAMPLING=fDTS/16, N=8"] FdtsDiv16N8 = 12 , # [doc = "13: fSAMPLING=fDTS/32, N=5"] FdtsDiv32N5 = 13 , # [doc = "14: fSAMPLING=fDTS/32, N=6"] FdtsDiv32N6 = 14 , # [doc = "15: fSAMPLING=fDTS/32, N=8"] FdtsDiv32N8 = 15 , } impl From < Icfilter > for u8 { # [inline (always)] fn from (variant : Icfilter) -> Self { variant as _ } } impl crate :: FieldSpec for Icfilter { type Ux = u8 ; } impl crate :: IsEnum for Icfilter { } # [doc = "Field `ICF(1-2)` reader - Input capture %s filter"] pub type IcfR = crate :: FieldReader < Icfilter > ; impl IcfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Icfilter { match self . bits { 0 => Icfilter :: NoFilter , 1 => Icfilter :: FckIntN2 , 2 => Icfilter :: FckIntN4 , 3 => Icfilter :: FckIntN8 , 4 => Icfilter :: FdtsDiv2N6 , 5 => Icfilter :: FdtsDiv2N8 , 6 => Icfilter :: FdtsDiv4N6 , 7 => Icfilter :: FdtsDiv4N8 , 8 => Icfilter :: FdtsDiv8N6 , 9 => Icfilter :: FdtsDiv8N8 , 10 => Icfilter :: FdtsDiv16N5 , 11 => Icfilter :: FdtsDiv16N6 , 12 => Icfilter :: FdtsDiv16N8 , 13 => Icfilter :: FdtsDiv32N5 , 14 => Icfilter :: FdtsDiv32N6 , 15 => Icfilter :: FdtsDiv32N8 , _ => unreachable ! () , } } # [doc = "No filter, sampling is done at fDTS"] # [inline (always)] pub fn is_no_filter (& self) -> bool { * self == Icfilter :: NoFilter } # [doc = "fSAMPLING=fCK_INT, N=2"] # [inline (always)] pub fn is_fck_int_n2 (& self) -> bool { * self == Icfilter :: FckIntN2 } # [doc = "fSAMPLING=fCK_INT, N=4"] # [inline (always)] pub fn is_fck_int_n4 (& self) -> bool { * self == Icfilter :: FckIntN4 } # [doc = "fSAMPLING=fCK_INT, N=8"] # [inline (always)] pub fn is_fck_int_n8 (& self) -> bool { * self == Icfilter :: FckIntN8 } # [doc = "fSAMPLING=fDTS/2, N=6"] # [inline (always)] pub fn is_fdts_div2_n6 (& self) -> bool { * self == Icfilter :: FdtsDiv2N6 } # [doc = "fSAMPLING=fDTS/2, N=8"] # [inline (always)] pub fn is_fdts_div2_n8 (& self) -> bool { * self == Icfilter :: FdtsDiv2N8 } # [doc = "fSAMPLING=fDTS/4, N=6"] # [inline (always)] pub fn is_fdts_div4_n6 (& self) -> bool { * self == Icfilter :: FdtsDiv4N6 } # [doc = "fSAMPLING=fDTS/4, N=8"] # [inline (always)] pub fn is_fdts_div4_n8 (& self) -> bool { * self == Icfilter :: FdtsDiv4N8 } # [doc = "fSAMPLING=fDTS/8, N=6"] # [inline (always)] pub fn is_fdts_div8_n6 (& self) -> bool { * self == Icfilter :: FdtsDiv8N6 } # [doc = "fSAMPLING=fDTS/8, N=8"] # [inline (always)] pub fn is_fdts_div8_n8 (& self) -> bool { * self == Icfilter :: FdtsDiv8N8 } # [doc = "fSAMPLING=fDTS/16, N=5"] # [inline (always)] pub fn is_fdts_div16_n5 (& self) -> bool { * self == Icfilter :: FdtsDiv16N5 } # [doc = "fSAMPLING=fDTS/16, N=6"] # [inline (always)] pub fn is_fdts_div16_n6 (& self) -> bool { * self == Icfilter :: FdtsDiv16N6 } # [doc = "fSAMPLING=fDTS/16, N=8"] # [inline (always)] pub fn is_fdts_div16_n8 (& self) -> bool { * self == Icfilter :: FdtsDiv16N8 } # [doc = "fSAMPLING=fDTS/32, N=5"] # [inline (always)] pub fn is_fdts_div32_n5 (& self) -> bool { * self == Icfilter :: FdtsDiv32N5 } # [doc = "fSAMPLING=fDTS/32, N=6"] # [inline (always)] pub fn is_fdts_div32_n6 (& self) -> bool { * self == Icfilter :: FdtsDiv32N6 } # [doc = "fSAMPLING=fDTS/32, N=8"] # [inline (always)] pub fn is_fdts_div32_n8 (& self) -> bool { * self == Icfilter :: FdtsDiv32N8 } } # [doc = "Field `ICF(1-2)` writer - Input capture %s filter"] pub type IcfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Icfilter , crate :: Safe > ; impl < 'a , REG > IcfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No filter, sampling is done at fDTS"] # [inline (always)] pub fn no_filter (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: NoFilter) } # [doc = "fSAMPLING=fCK_INT, N=2"] # [inline (always)] pub fn fck_int_n2 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FckIntN2) } # [doc = "fSAMPLING=fCK_INT, N=4"] # [inline (always)] pub fn fck_int_n4 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FckIntN4) } # [doc = "fSAMPLING=fCK_INT, N=8"] # [inline (always)] pub fn fck_int_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FckIntN8) } # [doc = "fSAMPLING=fDTS/2, N=6"] # [inline (always)] pub fn fdts_div2_n6 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv2N6) } # [doc = "fSAMPLING=fDTS/2, N=8"] # [inline (always)] pub fn fdts_div2_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv2N8) } # [doc = "fSAMPLING=fDTS/4, N=6"] # [inline (always)] pub fn fdts_div4_n6 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv4N6) } # [doc = "fSAMPLING=fDTS/4, N=8"] # [inline (always)] pub fn fdts_div4_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv4N8) } # [doc = "fSAMPLING=fDTS/8, N=6"] # [inline (always)] pub fn fdts_div8_n6 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv8N6) } # [doc = "fSAMPLING=fDTS/8, N=8"] # [inline (always)] pub fn fdts_div8_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv8N8) } # [doc = "fSAMPLING=fDTS/16, N=5"] # [inline (always)] pub fn fdts_div16_n5 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv16N5) } # [doc = "fSAMPLING=fDTS/16, N=6"] # [inline (always)] pub fn fdts_div16_n6 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv16N6) } # [doc = "fSAMPLING=fDTS/16, N=8"] # [inline (always)] pub fn fdts_div16_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv16N8) } # [doc = "fSAMPLING=fDTS/32, N=5"] # [inline (always)] pub fn fdts_div32_n5 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv32N5) } # [doc = "fSAMPLING=fDTS/32, N=6"] # [inline (always)] pub fn fdts_div32_n6 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv32N6) } # [doc = "fSAMPLING=fDTS/32, N=8"] # [inline (always)] pub fn fdts_div32_n8 (self) -> & 'a mut crate :: W < REG > { self . variant (Icfilter :: FdtsDiv32N8) } } # [doc = "Capture/Compare 2 selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Cc2s { # [doc = "1: CC2 channel is configured as input, IC2 is mapped on TI2"] Ti2 = 1 , # [doc = "2: CC2 channel is configured as input, IC2 is mapped on TI1"] Ti1 = 2 , # [doc = "3: CC2 channel is configured as input, IC2 is mapped on TRC"] Trc = 3 , } impl From < Cc2s > for u8 { # [inline (always)] fn from (variant : Cc2s) -> Self { variant as _ } } impl crate :: FieldSpec for Cc2s { type Ux = u8 ; } impl crate :: IsEnum for Cc2s { } # [doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader < Cc2s > ; impl Cc2sR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Cc2s > { match self . bits { 1 => Some (Cc2s :: Ti2) , 2 => Some (Cc2s :: Ti1) , 3 => Some (Cc2s :: Trc) , _ => None , } } # [doc = "CC2 channel is configured as input, IC2 is mapped on TI2"] # [inline (always)] pub fn is_ti2 (& self) -> bool { * self == Cc2s :: Ti2 } # [doc = "CC2 channel is configured as input, IC2 is mapped on TI1"] # [inline (always)] pub fn is_ti1 (& self) -> bool { * self == Cc2s :: Ti1 } # [doc = "CC2 channel is configured as input, IC2 is mapped on TRC"] # [inline (always)] pub fn is_trc (& self) -> bool { * self == Cc2s :: Trc } } # [doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Cc2s > ; impl < 'a , REG > Cc2sW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "CC2 channel is configured as input, IC2 is mapped on TI2"] # [inline (always)] pub fn ti2 (self) -> & 'a mut crate :: W < REG > { self . variant (Cc2s :: Ti2) } # [doc = "CC2 channel is configured as input, IC2 is mapped on TI1"] # [inline (always)] pub fn ti1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cc2s :: Ti1) } # [doc = "CC2 channel is configured as input, IC2 is mapped on TRC"] # [inline (always)] pub fn trc (self) -> & 'a mut crate :: W < REG > { self . variant (Cc2s :: Trc) } } impl R { # [doc = "Bits 0:1 - Capture/Compare 1 selection"] # [inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) } # [doc = "Input capture (1-2) prescaler"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `IC1PSC` field.</div>"] # [inline (always)] pub fn icpsc (& self , n : u8) -> IcpscR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; IcpscR :: new (((self . bits >> (n * 8 + 2)) & 3) as u8) } # [doc = "Iterator for array of:"] # [doc = "Input capture (1-2) prescaler"] # [inline (always)] pub fn icpsc_iter (& self) -> impl Iterator < Item = IcpscR > + '_ { (0 .. 2) . map (move | n | IcpscR :: new (((self . bits >> (n * 8 + 2)) & 3) as u8)) } # [doc = "Bits 2:3 - Input capture 1 prescaler"] # [inline (always)] pub fn ic1psc (& self) -> IcpscR { IcpscR :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 10:11 - Input capture 2 prescaler"] # [inline (always)] pub fn ic2psc (& self) -> IcpscR { IcpscR :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Input capture (1-2) filter"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `IC1F` field.</div>"] # [inline (always)] pub fn icf (& self , n : u8) -> IcfR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; IcfR :: new (((self . bits >> (n * 8 + 4)) & 0x0f) as u8) } # [doc = "Iterator for array of:"] # [doc = "Input capture (1-2) filter"] # [inline (always)] pub fn icf_iter (& self) -> impl Iterator < Item = IcfR > + '_ { (0 .. 2) . map (move | n | IcfR :: new (((self . bits >> (n * 8 + 4)) & 0x0f) as u8)) } # [doc = "Bits 4:7 - Input capture 1 filter"] # [inline (always)] pub fn ic1f (& self) -> IcfR { IcfR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 12:15 - Input capture 2 filter"] # [inline (always)] pub fn ic2f (& self) -> IcfR { IcfR :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 8:9 - Capture/Compare 2 selection"] # [inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Capture/Compare 1 selection"] # [inline (always)] pub fn cc1s (& mut self) -> Cc1sW < Ccmr1InputSpec > { Cc1sW :: new (self , 0) } # [doc = "Input capture (1-2) prescaler"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `IC1PSC` field.</div>"] # [inline (always)] pub fn icpsc (& mut self , n : u8) -> IcpscW < Ccmr1InputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; IcpscW :: new (self , n * 8 + 2) } # [doc = "Bits 2:3 - Input capture 1 prescaler"] # [inline (always)] pub fn ic1psc (& mut self) -> IcpscW < Ccmr1InputSpec > { IcpscW :: new (self , 2) } # [doc = "Bits 10:11 - Input capture 2 prescaler"] # [inline (always)] pub fn ic2psc (& mut self) -> IcpscW < Ccmr1InputSpec > { IcpscW :: new (self , 10) } # [doc = "Input capture (1-2) filter"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `IC1F` field.</div>"] # [inline (always)] pub fn icf (& mut self , n : u8) -> IcfW < Ccmr1InputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; IcfW :: new (self , n * 8 + 4) } # [doc = "Bits 4:7 - Input capture 1 filter"] # [inline (always)] pub fn ic1f (& mut self) -> IcfW < Ccmr1InputSpec > { IcfW :: new (self , 4) } # [doc = "Bits 12:15 - Input capture 2 filter"] # [inline (always)] pub fn ic2f (& mut self) -> IcfW < Ccmr1InputSpec > { IcfW :: new (self , 12) } # [doc = "Bits 8:9 - Capture/Compare 2 selection"] # [inline (always)] pub fn cc2s (& mut self) -> Cc2sW < Ccmr1InputSpec > { Cc2sW :: new (self , 8) } } # [doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { } # [doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { }
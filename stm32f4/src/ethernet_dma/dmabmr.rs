# [doc = "Register `DMABMR` reader"] pub type R = crate :: R < DmabmrSpec > ; # [doc = "Register `DMABMR` writer"] pub type W = crate :: W < DmabmrSpec > ; # [doc = "Software reset\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sr { # [doc = "1: Reset all MAC subsystem internal registers and logic. Cleared automatically"] Reset = 1 , } impl From < Sr > for bool { # [inline (always)] fn from (variant : Sr) -> Self { variant as u8 != 0 } } # [doc = "Field `SR` reader - Software reset"] pub type SrR = crate :: BitReader < Sr > ; impl SrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Sr > { match self . bits { true => Some (Sr :: Reset) , _ => None , } } # [doc = "Reset all MAC subsystem internal registers and logic. Cleared automatically"] # [inline (always)] pub fn is_reset (& self) -> bool { * self == Sr :: Reset } } # [doc = "Field `SR` writer - Software reset"] pub type SrW < 'a , REG > = crate :: BitWriter < 'a , REG , Sr > ; impl < 'a , REG > SrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Reset all MAC subsystem internal registers and logic. Cleared automatically"] # [inline (always)] pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Sr :: Reset) } } # [doc = "DMA arbitration\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Da { # [doc = "0: Round-robin with Rx:Tx priority given by PM"] RoundRobin = 0 , # [doc = "1: Rx has priority over Tx"] RxPriority = 1 , } impl From < Da > for bool { # [inline (always)] fn from (variant : Da) -> Self { variant as u8 != 0 } } # [doc = "Field `DA` reader - DMA arbitration"] pub type DaR = crate :: BitReader < Da > ; impl DaR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Da { match self . bits { false => Da :: RoundRobin , true => Da :: RxPriority , } } # [doc = "Round-robin with Rx:Tx priority given by PM"] # [inline (always)] pub fn is_round_robin (& self) -> bool { * self == Da :: RoundRobin } # [doc = "Rx has priority over Tx"] # [inline (always)] pub fn is_rx_priority (& self) -> bool { * self == Da :: RxPriority } } # [doc = "Field `DA` writer - DMA arbitration"] pub type DaW < 'a , REG > = crate :: BitWriter < 'a , REG , Da > ; impl < 'a , REG > DaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Round-robin with Rx:Tx priority given by PM"] # [inline (always)] pub fn round_robin (self) -> & 'a mut crate :: W < REG > { self . variant (Da :: RoundRobin) } # [doc = "Rx has priority over Tx"] # [inline (always)] pub fn rx_priority (self) -> & 'a mut crate :: W < REG > { self . variant (Da :: RxPriority) } } # [doc = "Field `DSL` reader - Descriptor skip length"] pub type DslR = crate :: FieldReader ; # [doc = "Field `DSL` writer - Descriptor skip length"] pub type DslW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 , u8 , crate :: Safe > ; # [doc = "Enhanced descriptor format enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Edfe { # [doc = "0: Normal descriptor format"] Disabled = 0 , # [doc = "1: Enhanced 32-byte descriptor format, required for timestamping and IPv4 checksum offload"] Enabled = 1 , } impl From < Edfe > for bool { # [inline (always)] fn from (variant : Edfe) -> Self { variant as u8 != 0 } } # [doc = "Field `EDFE` reader - Enhanced descriptor format enable"] pub type EdfeR = crate :: BitReader < Edfe > ; impl EdfeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Edfe { match self . bits { false => Edfe :: Disabled , true => Edfe :: Enabled , } } # [doc = "Normal descriptor format"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Edfe :: Disabled } # [doc = "Enhanced 32-byte descriptor format, required for timestamping and IPv4 checksum offload"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Edfe :: Enabled } } # [doc = "Field `EDFE` writer - Enhanced descriptor format enable"] pub type EdfeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edfe > ; impl < 'a , REG > EdfeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal descriptor format"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Edfe :: Disabled) } # [doc = "Enhanced 32-byte descriptor format, required for timestamping and IPv4 checksum offload"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Edfe :: Enabled) } } # [doc = "Programmable burst length\n\nValue on reset: 33"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pbl { # [doc = "1: Maximum of 1 beat per DMA transaction"] Pbl1 = 1 , # [doc = "2: Maximum of 2 beats per DMA transaction"] Pbl2 = 2 , # [doc = "4: Maximum of 4 beats per DMA transaction"] Pbl4 = 4 , # [doc = "8: Maximum of 8 beats per DMA transaction"] Pbl8 = 8 , # [doc = "16: Maximum of 16 beats per DMA transaction"] Pbl16 = 16 , # [doc = "32: Maximum of 32 beats per DMA transaction"] Pbl32 = 32 , } impl From < Pbl > for u8 { # [inline (always)] fn from (variant : Pbl) -> Self { variant as _ } } impl crate :: FieldSpec for Pbl { type Ux = u8 ; } impl crate :: IsEnum for Pbl { } # [doc = "Field `PBL` reader - Programmable burst length"] pub type PblR = crate :: FieldReader < Pbl > ; impl PblR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Pbl > { match self . bits { 1 => Some (Pbl :: Pbl1) , 2 => Some (Pbl :: Pbl2) , 4 => Some (Pbl :: Pbl4) , 8 => Some (Pbl :: Pbl8) , 16 => Some (Pbl :: Pbl16) , 32 => Some (Pbl :: Pbl32) , _ => None , } } # [doc = "Maximum of 1 beat per DMA transaction"] # [inline (always)] pub fn is_pbl1 (& self) -> bool { * self == Pbl :: Pbl1 } # [doc = "Maximum of 2 beats per DMA transaction"] # [inline (always)] pub fn is_pbl2 (& self) -> bool { * self == Pbl :: Pbl2 } # [doc = "Maximum of 4 beats per DMA transaction"] # [inline (always)] pub fn is_pbl4 (& self) -> bool { * self == Pbl :: Pbl4 } # [doc = "Maximum of 8 beats per DMA transaction"] # [inline (always)] pub fn is_pbl8 (& self) -> bool { * self == Pbl :: Pbl8 } # [doc = "Maximum of 16 beats per DMA transaction"] # [inline (always)] pub fn is_pbl16 (& self) -> bool { * self == Pbl :: Pbl16 } # [doc = "Maximum of 32 beats per DMA transaction"] # [inline (always)] pub fn is_pbl32 (& self) -> bool { * self == Pbl :: Pbl32 } } # [doc = "Field `PBL` writer - Programmable burst length"] pub type PblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 , Pbl > ; impl < 'a , REG > PblW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Maximum of 1 beat per DMA transaction"] # [inline (always)] pub fn pbl1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl1) } # [doc = "Maximum of 2 beats per DMA transaction"] # [inline (always)] pub fn pbl2 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl2) } # [doc = "Maximum of 4 beats per DMA transaction"] # [inline (always)] pub fn pbl4 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl4) } # [doc = "Maximum of 8 beats per DMA transaction"] # [inline (always)] pub fn pbl8 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl8) } # [doc = "Maximum of 16 beats per DMA transaction"] # [inline (always)] pub fn pbl16 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl16) } # [doc = "Maximum of 32 beats per DMA transaction"] # [inline (always)] pub fn pbl32 (self) -> & 'a mut crate :: W < REG > { self . variant (Pbl :: Pbl32) } } # [doc = "Rx-Tx priority ratio\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pm { # [doc = "0: RxDMA priority over TxDMA is 1:1"] OneToOne = 0 , # [doc = "1: RxDMA priority over TxDMA is 2:1"] TwoToOne = 1 , # [doc = "2: RxDMA priority over TxDMA is 3:1"] ThreeToOne = 2 , # [doc = "3: RxDMA priority over TxDMA is 4:1"] FourToOne = 3 , } impl From < Pm > for u8 { # [inline (always)] fn from (variant : Pm) -> Self { variant as _ } } impl crate :: FieldSpec for Pm { type Ux = u8 ; } impl crate :: IsEnum for Pm { } # [doc = "Field `PM` reader - Rx-Tx priority ratio"] pub type PmR = crate :: FieldReader < Pm > ; impl PmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pm { match self . bits { 0 => Pm :: OneToOne , 1 => Pm :: TwoToOne , 2 => Pm :: ThreeToOne , 3 => Pm :: FourToOne , _ => unreachable ! () , } } # [doc = "RxDMA priority over TxDMA is 1:1"] # [inline (always)] pub fn is_one_to_one (& self) -> bool { * self == Pm :: OneToOne } # [doc = "RxDMA priority over TxDMA is 2:1"] # [inline (always)] pub fn is_two_to_one (& self) -> bool { * self == Pm :: TwoToOne } # [doc = "RxDMA priority over TxDMA is 3:1"] # [inline (always)] pub fn is_three_to_one (& self) -> bool { * self == Pm :: ThreeToOne } # [doc = "RxDMA priority over TxDMA is 4:1"] # [inline (always)] pub fn is_four_to_one (& self) -> bool { * self == Pm :: FourToOne } } # [doc = "Field `PM` writer - Rx-Tx priority ratio"] pub type PmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Pm , crate :: Safe > ; impl < 'a , REG > PmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "RxDMA priority over TxDMA is 1:1"] # [inline (always)] pub fn one_to_one (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: OneToOne) } # [doc = "RxDMA priority over TxDMA is 2:1"] # [inline (always)] pub fn two_to_one (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: TwoToOne) } # [doc = "RxDMA priority over TxDMA is 3:1"] # [inline (always)] pub fn three_to_one (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: ThreeToOne) } # [doc = "RxDMA priority over TxDMA is 4:1"] # [inline (always)] pub fn four_to_one (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: FourToOne) } } # [doc = "Fixed burst\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fb { # [doc = "0: AHB uses SINGLE and INCR burst transfers"] Variable = 0 , # [doc = "1: AHB uses only fixed burst transfers"] Fixed = 1 , } impl From < Fb > for bool { # [inline (always)] fn from (variant : Fb) -> Self { variant as u8 != 0 } } # [doc = "Field `FB` reader - Fixed burst"] pub type FbR = crate :: BitReader < Fb > ; impl FbR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fb { match self . bits { false => Fb :: Variable , true => Fb :: Fixed , } } # [doc = "AHB uses SINGLE and INCR burst transfers"] # [inline (always)] pub fn is_variable (& self) -> bool { * self == Fb :: Variable } # [doc = "AHB uses only fixed burst transfers"] # [inline (always)] pub fn is_fixed (& self) -> bool { * self == Fb :: Fixed } } # [doc = "Field `FB` writer - Fixed burst"] pub type FbW < 'a , REG > = crate :: BitWriter < 'a , REG , Fb > ; impl < 'a , REG > FbW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "AHB uses SINGLE and INCR burst transfers"] # [inline (always)] pub fn variable (self) -> & 'a mut crate :: W < REG > { self . variant (Fb :: Variable) } # [doc = "AHB uses only fixed burst transfers"] # [inline (always)] pub fn fixed (self) -> & 'a mut crate :: W < REG > { self . variant (Fb :: Fixed) } } # [doc = "Rx DMA PBL\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Rdp { # [doc = "1: 1 beat per RxDMA transaction"] Rdp1 = 1 , # [doc = "2: 2 beats per RxDMA transaction"] Rdp2 = 2 , # [doc = "4: 4 beats per RxDMA transaction"] Rdp4 = 4 , # [doc = "8: 8 beats per RxDMA transaction"] Rdp8 = 8 , # [doc = "16: 16 beats per RxDMA transaction"] Rdp16 = 16 , # [doc = "32: 32 beats per RxDMA transaction"] Rdp32 = 32 , } impl From < Rdp > for u8 { # [inline (always)] fn from (variant : Rdp) -> Self { variant as _ } } impl crate :: FieldSpec for Rdp { type Ux = u8 ; } impl crate :: IsEnum for Rdp { } # [doc = "Field `RDP` reader - Rx DMA PBL"] pub type RdpR = crate :: FieldReader < Rdp > ; impl RdpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Rdp > { match self . bits { 1 => Some (Rdp :: Rdp1) , 2 => Some (Rdp :: Rdp2) , 4 => Some (Rdp :: Rdp4) , 8 => Some (Rdp :: Rdp8) , 16 => Some (Rdp :: Rdp16) , 32 => Some (Rdp :: Rdp32) , _ => None , } } # [doc = "1 beat per RxDMA transaction"] # [inline (always)] pub fn is_rdp1 (& self) -> bool { * self == Rdp :: Rdp1 } # [doc = "2 beats per RxDMA transaction"] # [inline (always)] pub fn is_rdp2 (& self) -> bool { * self == Rdp :: Rdp2 } # [doc = "4 beats per RxDMA transaction"] # [inline (always)] pub fn is_rdp4 (& self) -> bool { * self == Rdp :: Rdp4 } # [doc = "8 beats per RxDMA transaction"] # [inline (always)] pub fn is_rdp8 (& self) -> bool { * self == Rdp :: Rdp8 } # [doc = "16 beats per RxDMA transaction"] # [inline (always)] pub fn is_rdp16 (& self) -> bool { * self == Rdp :: Rdp16 } # [doc = "32 beats per RxDMA transaction"] # [inline (always)] pub fn is_rdp32 (& self) -> bool { * self == Rdp :: Rdp32 } } # [doc = "Field `RDP` writer - Rx DMA PBL"] pub type RdpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 , Rdp > ; impl < 'a , REG > RdpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "1 beat per RxDMA transaction"] # [inline (always)] pub fn rdp1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp1) } # [doc = "2 beats per RxDMA transaction"] # [inline (always)] pub fn rdp2 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp2) } # [doc = "4 beats per RxDMA transaction"] # [inline (always)] pub fn rdp4 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp4) } # [doc = "8 beats per RxDMA transaction"] # [inline (always)] pub fn rdp8 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp8) } # [doc = "16 beats per RxDMA transaction"] # [inline (always)] pub fn rdp16 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp16) } # [doc = "32 beats per RxDMA transaction"] # [inline (always)] pub fn rdp32 (self) -> & 'a mut crate :: W < REG > { self . variant (Rdp :: Rdp32) } } # [doc = "Use separate PBL\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Usp { # [doc = "0: PBL value used for both Rx and Tx DMA"] Combined = 0 , # [doc = "1: RxDMA uses RDP value, TxDMA uses PBL value"] Separate = 1 , } impl From < Usp > for bool { # [inline (always)] fn from (variant : Usp) -> Self { variant as u8 != 0 } } # [doc = "Field `USP` reader - Use separate PBL"] pub type UspR = crate :: BitReader < Usp > ; impl UspR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Usp { match self . bits { false => Usp :: Combined , true => Usp :: Separate , } } # [doc = "PBL value used for both Rx and Tx DMA"] # [inline (always)] pub fn is_combined (& self) -> bool { * self == Usp :: Combined } # [doc = "RxDMA uses RDP value, TxDMA uses PBL value"] # [inline (always)] pub fn is_separate (& self) -> bool { * self == Usp :: Separate } } # [doc = "Field `USP` writer - Use separate PBL"] pub type UspW < 'a , REG > = crate :: BitWriter < 'a , REG , Usp > ; impl < 'a , REG > UspW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PBL value used for both Rx and Tx DMA"] # [inline (always)] pub fn combined (self) -> & 'a mut crate :: W < REG > { self . variant (Usp :: Combined) } # [doc = "RxDMA uses RDP value, TxDMA uses PBL value"] # [inline (always)] pub fn separate (self) -> & 'a mut crate :: W < REG > { self . variant (Usp :: Separate) } } # [doc = "4xPBL mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fpm { # [doc = "0: PBL values used as-is"] X1 = 0 , # [doc = "1: PBL values multiplied by 4"] X4 = 1 , } impl From < Fpm > for bool { # [inline (always)] fn from (variant : Fpm) -> Self { variant as u8 != 0 } } # [doc = "Field `FPM` reader - 4xPBL mode"] pub type FpmR = crate :: BitReader < Fpm > ; impl FpmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fpm { match self . bits { false => Fpm :: X1 , true => Fpm :: X4 , } } # [doc = "PBL values used as-is"] # [inline (always)] pub fn is_x1 (& self) -> bool { * self == Fpm :: X1 } # [doc = "PBL values multiplied by 4"] # [inline (always)] pub fn is_x4 (& self) -> bool { * self == Fpm :: X4 } } # [doc = "Field `FPM` writer - 4xPBL mode"] pub type FpmW < 'a , REG > = crate :: BitWriter < 'a , REG , Fpm > ; impl < 'a , REG > FpmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PBL values used as-is"] # [inline (always)] pub fn x1 (self) -> & 'a mut crate :: W < REG > { self . variant (Fpm :: X1) } # [doc = "PBL values multiplied by 4"] # [inline (always)] pub fn x4 (self) -> & 'a mut crate :: W < REG > { self . variant (Fpm :: X4) } } # [doc = "Address-aligned beats\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Aab { # [doc = "0: Bursts are not aligned"] Unaligned = 0 , # [doc = "1: Align bursts to start address LS bits. First burst alignment depends on FB bit"] Aligned = 1 , } impl From < Aab > for bool { # [inline (always)] fn from (variant : Aab) -> Self { variant as u8 != 0 } } # [doc = "Field `AAB` reader - Address-aligned beats"] pub type AabR = crate :: BitReader < Aab > ; impl AabR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Aab { match self . bits { false => Aab :: Unaligned , true => Aab :: Aligned , } } # [doc = "Bursts are not aligned"] # [inline (always)] pub fn is_unaligned (& self) -> bool { * self == Aab :: Unaligned } # [doc = "Align bursts to start address LS bits. First burst alignment depends on FB bit"] # [inline (always)] pub fn is_aligned (& self) -> bool { * self == Aab :: Aligned } } # [doc = "Field `AAB` writer - Address-aligned beats"] pub type AabW < 'a , REG > = crate :: BitWriter < 'a , REG , Aab > ; impl < 'a , REG > AabW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Bursts are not aligned"] # [inline (always)] pub fn unaligned (self) -> & 'a mut crate :: W < REG > { self . variant (Aab :: Unaligned) } # [doc = "Align bursts to start address LS bits. First burst alignment depends on FB bit"] # [inline (always)] pub fn aligned (self) -> & 'a mut crate :: W < REG > { self . variant (Aab :: Aligned) } } # [doc = "Mixed burst\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mb { # [doc = "0: Fixed burst transfers (INCRx and SINGLE) for burst lengths of 16 and below"] Normal = 0 , # [doc = "1: If FB is low, start all bursts greater than 16 with INCR (undefined burst)"] Mixed = 1 , } impl From < Mb > for bool { # [inline (always)] fn from (variant : Mb) -> Self { variant as u8 != 0 } } # [doc = "Field `MB` reader - Mixed burst"] pub type MbR = crate :: BitReader < Mb > ; impl MbR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mb { match self . bits { false => Mb :: Normal , true => Mb :: Mixed , } } # [doc = "Fixed burst transfers (INCRx and SINGLE) for burst lengths of 16 and below"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Mb :: Normal } # [doc = "If FB is low, start all bursts greater than 16 with INCR (undefined burst)"] # [inline (always)] pub fn is_mixed (& self) -> bool { * self == Mb :: Mixed } } # [doc = "Field `MB` writer - Mixed burst"] pub type MbW < 'a , REG > = crate :: BitWriter < 'a , REG , Mb > ; impl < 'a , REG > MbW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Fixed burst transfers (INCRx and SINGLE) for burst lengths of 16 and below"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Mb :: Normal) } # [doc = "If FB is low, start all bursts greater than 16 with INCR (undefined burst)"] # [inline (always)] pub fn mixed (self) -> & 'a mut crate :: W < REG > { self . variant (Mb :: Mixed) } } impl R { # [doc = "Bit 0 - Software reset"] # [inline (always)] pub fn sr (& self) -> SrR { SrR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DMA arbitration"] # [inline (always)] pub fn da (& self) -> DaR { DaR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:6 - Descriptor skip length"] # [inline (always)] pub fn dsl (& self) -> DslR { DslR :: new (((self . bits >> 2) & 0x1f) as u8) } # [doc = "Bit 7 - Enhanced descriptor format enable"] # [inline (always)] pub fn edfe (& self) -> EdfeR { EdfeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:13 - Programmable burst length"] # [inline (always)] pub fn pbl (& self) -> PblR { PblR :: new (((self . bits >> 8) & 0x3f) as u8) } # [doc = "Bits 14:15 - Rx-Tx priority ratio"] # [inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bit 16 - Fixed burst"] # [inline (always)] pub fn fb (& self) -> FbR { FbR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 17:22 - Rx DMA PBL"] # [inline (always)] pub fn rdp (& self) -> RdpR { RdpR :: new (((self . bits >> 17) & 0x3f) as u8) } # [doc = "Bit 23 - Use separate PBL"] # [inline (always)] pub fn usp (& self) -> UspR { UspR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - 4xPBL mode"] # [inline (always)] pub fn fpm (& self) -> FpmR { FpmR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Address-aligned beats"] # [inline (always)] pub fn aab (& self) -> AabR { AabR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Mixed burst"] # [inline (always)] pub fn mb (& self) -> MbR { MbR :: new (((self . bits >> 26) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software reset"] # [inline (always)] pub fn sr (& mut self) -> SrW < DmabmrSpec > { SrW :: new (self , 0) } # [doc = "Bit 1 - DMA arbitration"] # [inline (always)] pub fn da (& mut self) -> DaW < DmabmrSpec > { DaW :: new (self , 1) } # [doc = "Bits 2:6 - Descriptor skip length"] # [inline (always)] pub fn dsl (& mut self) -> DslW < DmabmrSpec > { DslW :: new (self , 2) } # [doc = "Bit 7 - Enhanced descriptor format enable"] # [inline (always)] pub fn edfe (& mut self) -> EdfeW < DmabmrSpec > { EdfeW :: new (self , 7) } # [doc = "Bits 8:13 - Programmable burst length"] # [inline (always)] pub fn pbl (& mut self) -> PblW < DmabmrSpec > { PblW :: new (self , 8) } # [doc = "Bits 14:15 - Rx-Tx priority ratio"] # [inline (always)] pub fn pm (& mut self) -> PmW < DmabmrSpec > { PmW :: new (self , 14) } # [doc = "Bit 16 - Fixed burst"] # [inline (always)] pub fn fb (& mut self) -> FbW < DmabmrSpec > { FbW :: new (self , 16) } # [doc = "Bits 17:22 - Rx DMA PBL"] # [inline (always)] pub fn rdp (& mut self) -> RdpW < DmabmrSpec > { RdpW :: new (self , 17) } # [doc = "Bit 23 - Use separate PBL"] # [inline (always)] pub fn usp (& mut self) -> UspW < DmabmrSpec > { UspW :: new (self , 23) } # [doc = "Bit 24 - 4xPBL mode"] # [inline (always)] pub fn fpm (& mut self) -> FpmW < DmabmrSpec > { FpmW :: new (self , 24) } # [doc = "Bit 25 - Address-aligned beats"] # [inline (always)] pub fn aab (& mut self) -> AabW < DmabmrSpec > { AabW :: new (self , 25) } # [doc = "Bit 26 - Mixed burst"] # [inline (always)] pub fn mb (& mut self) -> MbW < DmabmrSpec > { MbW :: new (self , 26) } } # [doc = "Ethernet DMA bus mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmabmr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmabmr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmabmrSpec ; impl crate :: RegisterSpec for DmabmrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dmabmr::R`](R) reader structure"] impl crate :: Readable for DmabmrSpec { } # [doc = "`write(|w| ..)` method takes [`dmabmr::W`](W) writer structure"] impl crate :: Writable for DmabmrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets DMABMR to value 0x2101"] impl crate :: Resettable for DmabmrSpec { const RESET_VALUE : u32 = 0x2101 ; }
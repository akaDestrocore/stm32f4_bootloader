# [doc = "Register `DMAOMR` reader"] pub type R = crate :: R < DmaomrSpec > ; # [doc = "Register `DMAOMR` writer"] pub type W = crate :: W < DmaomrSpec > ; # [doc = "Start/stop receive\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sr { # [doc = "0: Reception is stopped after transfer of the current frame"] Stopped = 0 , # [doc = "1: Reception is placed in the Running state"] Started = 1 , } impl From < Sr > for bool { # [inline (always)] fn from (variant : Sr) -> Self { variant as u8 != 0 } } # [doc = "Field `SR` reader - Start/stop receive"] pub type SrR = crate :: BitReader < Sr > ; impl SrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sr { match self . bits { false => Sr :: Stopped , true => Sr :: Started , } } # [doc = "Reception is stopped after transfer of the current frame"] # [inline (always)] pub fn is_stopped (& self) -> bool { * self == Sr :: Stopped } # [doc = "Reception is placed in the Running state"] # [inline (always)] pub fn is_started (& self) -> bool { * self == Sr :: Started } } # [doc = "Field `SR` writer - Start/stop receive"] pub type SrW < 'a , REG > = crate :: BitWriter < 'a , REG , Sr > ; impl < 'a , REG > SrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Reception is stopped after transfer of the current frame"] # [inline (always)] pub fn stopped (self) -> & 'a mut crate :: W < REG > { self . variant (Sr :: Stopped) } # [doc = "Reception is placed in the Running state"] # [inline (always)] pub fn started (self) -> & 'a mut crate :: W < REG > { self . variant (Sr :: Started) } } # [doc = "Field `OSF` reader - Operate on second frame"] pub type OsfR = crate :: BitReader ; # [doc = "Field `OSF` writer - Operate on second frame"] pub type OsfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Receive threshold control\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Rtc { # [doc = "0: 64 bytes"] Rtc64 = 0 , # [doc = "1: 32 bytes"] Rtc32 = 1 , # [doc = "2: 96 bytes"] Rtc96 = 2 , # [doc = "3: 128 bytes"] Rtc128 = 3 , } impl From < Rtc > for u8 { # [inline (always)] fn from (variant : Rtc) -> Self { variant as _ } } impl crate :: FieldSpec for Rtc { type Ux = u8 ; } impl crate :: IsEnum for Rtc { } # [doc = "Field `RTC` reader - Receive threshold control"] pub type RtcR = crate :: FieldReader < Rtc > ; impl RtcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rtc { match self . bits { 0 => Rtc :: Rtc64 , 1 => Rtc :: Rtc32 , 2 => Rtc :: Rtc96 , 3 => Rtc :: Rtc128 , _ => unreachable ! () , } } # [doc = "64 bytes"] # [inline (always)] pub fn is_rtc64 (& self) -> bool { * self == Rtc :: Rtc64 } # [doc = "32 bytes"] # [inline (always)] pub fn is_rtc32 (& self) -> bool { * self == Rtc :: Rtc32 } # [doc = "96 bytes"] # [inline (always)] pub fn is_rtc96 (& self) -> bool { * self == Rtc :: Rtc96 } # [doc = "128 bytes"] # [inline (always)] pub fn is_rtc128 (& self) -> bool { * self == Rtc :: Rtc128 } } # [doc = "Field `RTC` writer - Receive threshold control"] pub type RtcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Rtc , crate :: Safe > ; impl < 'a , REG > RtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "64 bytes"] # [inline (always)] pub fn rtc64 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Rtc64) } # [doc = "32 bytes"] # [inline (always)] pub fn rtc32 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Rtc32) } # [doc = "96 bytes"] # [inline (always)] pub fn rtc96 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Rtc96) } # [doc = "128 bytes"] # [inline (always)] pub fn rtc128 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Rtc128) } } # [doc = "Forward undersized good frames\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fugf { # [doc = "0: Rx FIFO drops all frames of less than 64 bytes"] Drop = 0 , # [doc = "1: Rx FIFO forwards undersized frames"] Forward = 1 , } impl From < Fugf > for bool { # [inline (always)] fn from (variant : Fugf) -> Self { variant as u8 != 0 } } # [doc = "Field `FUGF` reader - Forward undersized good frames"] pub type FugfR = crate :: BitReader < Fugf > ; impl FugfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fugf { match self . bits { false => Fugf :: Drop , true => Fugf :: Forward , } } # [doc = "Rx FIFO drops all frames of less than 64 bytes"] # [inline (always)] pub fn is_drop (& self) -> bool { * self == Fugf :: Drop } # [doc = "Rx FIFO forwards undersized frames"] # [inline (always)] pub fn is_forward (& self) -> bool { * self == Fugf :: Forward } } # [doc = "Field `FUGF` writer - Forward undersized good frames"] pub type FugfW < 'a , REG > = crate :: BitWriter < 'a , REG , Fugf > ; impl < 'a , REG > FugfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Rx FIFO drops all frames of less than 64 bytes"] # [inline (always)] pub fn drop (self) -> & 'a mut crate :: W < REG > { self . variant (Fugf :: Drop) } # [doc = "Rx FIFO forwards undersized frames"] # [inline (always)] pub fn forward (self) -> & 'a mut crate :: W < REG > { self . variant (Fugf :: Forward) } } # [doc = "Forward error frames\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fef { # [doc = "0: Rx FIFO drops frames with error status"] Drop = 0 , # [doc = "1: All frames except runt error frames are forwarded to the DMA"] Forward = 1 , } impl From < Fef > for bool { # [inline (always)] fn from (variant : Fef) -> Self { variant as u8 != 0 } } # [doc = "Field `FEF` reader - Forward error frames"] pub type FefR = crate :: BitReader < Fef > ; impl FefR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fef { match self . bits { false => Fef :: Drop , true => Fef :: Forward , } } # [doc = "Rx FIFO drops frames with error status"] # [inline (always)] pub fn is_drop (& self) -> bool { * self == Fef :: Drop } # [doc = "All frames except runt error frames are forwarded to the DMA"] # [inline (always)] pub fn is_forward (& self) -> bool { * self == Fef :: Forward } } # [doc = "Field `FEF` writer - Forward error frames"] pub type FefW < 'a , REG > = crate :: BitWriter < 'a , REG , Fef > ; impl < 'a , REG > FefW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Rx FIFO drops frames with error status"] # [inline (always)] pub fn drop (self) -> & 'a mut crate :: W < REG > { self . variant (Fef :: Drop) } # [doc = "All frames except runt error frames are forwarded to the DMA"] # [inline (always)] pub fn forward (self) -> & 'a mut crate :: W < REG > { self . variant (Fef :: Forward) } } # [doc = "Start/stop transmission\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum St { # [doc = "0: Transmission is placed in the Stopped state"] Stopped = 0 , # [doc = "1: Transmission is placed in Running state"] Started = 1 , } impl From < St > for bool { # [inline (always)] fn from (variant : St) -> Self { variant as u8 != 0 } } # [doc = "Field `ST` reader - Start/stop transmission"] pub type StR = crate :: BitReader < St > ; impl StR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> St { match self . bits { false => St :: Stopped , true => St :: Started , } } # [doc = "Transmission is placed in the Stopped state"] # [inline (always)] pub fn is_stopped (& self) -> bool { * self == St :: Stopped } # [doc = "Transmission is placed in Running state"] # [inline (always)] pub fn is_started (& self) -> bool { * self == St :: Started } } # [doc = "Field `ST` writer - Start/stop transmission"] pub type StW < 'a , REG > = crate :: BitWriter < 'a , REG , St > ; impl < 'a , REG > StW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Transmission is placed in the Stopped state"] # [inline (always)] pub fn stopped (self) -> & 'a mut crate :: W < REG > { self . variant (St :: Stopped) } # [doc = "Transmission is placed in Running state"] # [inline (always)] pub fn started (self) -> & 'a mut crate :: W < REG > { self . variant (St :: Started) } } # [doc = "Transmit threshold control\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ttc { # [doc = "0: 64 bytes"] Ttc64 = 0 , # [doc = "1: 128 bytes"] Ttc128 = 1 , # [doc = "2: 192 bytes"] Ttc192 = 2 , # [doc = "3: 256 bytes"] Ttc256 = 3 , # [doc = "4: 40 bytes"] Ttc40 = 4 , # [doc = "5: 32 bytes"] Ttc32 = 5 , # [doc = "6: 24 bytes"] Ttc24 = 6 , # [doc = "7: 16 bytes"] Ttc16 = 7 , } impl From < Ttc > for u8 { # [inline (always)] fn from (variant : Ttc) -> Self { variant as _ } } impl crate :: FieldSpec for Ttc { type Ux = u8 ; } impl crate :: IsEnum for Ttc { } # [doc = "Field `TTC` reader - Transmit threshold control"] pub type TtcR = crate :: FieldReader < Ttc > ; impl TtcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ttc { match self . bits { 0 => Ttc :: Ttc64 , 1 => Ttc :: Ttc128 , 2 => Ttc :: Ttc192 , 3 => Ttc :: Ttc256 , 4 => Ttc :: Ttc40 , 5 => Ttc :: Ttc32 , 6 => Ttc :: Ttc24 , 7 => Ttc :: Ttc16 , _ => unreachable ! () , } } # [doc = "64 bytes"] # [inline (always)] pub fn is_ttc64 (& self) -> bool { * self == Ttc :: Ttc64 } # [doc = "128 bytes"] # [inline (always)] pub fn is_ttc128 (& self) -> bool { * self == Ttc :: Ttc128 } # [doc = "192 bytes"] # [inline (always)] pub fn is_ttc192 (& self) -> bool { * self == Ttc :: Ttc192 } # [doc = "256 bytes"] # [inline (always)] pub fn is_ttc256 (& self) -> bool { * self == Ttc :: Ttc256 } # [doc = "40 bytes"] # [inline (always)] pub fn is_ttc40 (& self) -> bool { * self == Ttc :: Ttc40 } # [doc = "32 bytes"] # [inline (always)] pub fn is_ttc32 (& self) -> bool { * self == Ttc :: Ttc32 } # [doc = "24 bytes"] # [inline (always)] pub fn is_ttc24 (& self) -> bool { * self == Ttc :: Ttc24 } # [doc = "16 bytes"] # [inline (always)] pub fn is_ttc16 (& self) -> bool { * self == Ttc :: Ttc16 } } # [doc = "Field `TTC` writer - Transmit threshold control"] pub type TtcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Ttc , crate :: Safe > ; impl < 'a , REG > TtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "64 bytes"] # [inline (always)] pub fn ttc64 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc64) } # [doc = "128 bytes"] # [inline (always)] pub fn ttc128 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc128) } # [doc = "192 bytes"] # [inline (always)] pub fn ttc192 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc192) } # [doc = "256 bytes"] # [inline (always)] pub fn ttc256 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc256) } # [doc = "40 bytes"] # [inline (always)] pub fn ttc40 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc40) } # [doc = "32 bytes"] # [inline (always)] pub fn ttc32 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc32) } # [doc = "24 bytes"] # [inline (always)] pub fn ttc24 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc24) } # [doc = "16 bytes"] # [inline (always)] pub fn ttc16 (self) -> & 'a mut crate :: W < REG > { self . variant (Ttc :: Ttc16) } } # [doc = "Flush transmit FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ftf { # [doc = "1: Transmit FIFO controller logic is reset to its default values. Cleared automatically"] Flush = 1 , } impl From < Ftf > for bool { # [inline (always)] fn from (variant : Ftf) -> Self { variant as u8 != 0 } } # [doc = "Field `FTF` reader - Flush transmit FIFO"] pub type FtfR = crate :: BitReader < Ftf > ; impl FtfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Ftf > { match self . bits { true => Some (Ftf :: Flush) , _ => None , } } # [doc = "Transmit FIFO controller logic is reset to its default values. Cleared automatically"] # [inline (always)] pub fn is_flush (& self) -> bool { * self == Ftf :: Flush } } # [doc = "Field `FTF` writer - Flush transmit FIFO"] pub type FtfW < 'a , REG > = crate :: BitWriter < 'a , REG , Ftf > ; impl < 'a , REG > FtfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Transmit FIFO controller logic is reset to its default values. Cleared automatically"] # [inline (always)] pub fn flush (self) -> & 'a mut crate :: W < REG > { self . variant (Ftf :: Flush) } } # [doc = "Transmit store and forward\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tsf { # [doc = "0: Transmission starts when the frame size in the Tx FIFO exceeds TTC threshold"] CutThrough = 0 , # [doc = "1: Transmission starts when a full frame is in the Tx FIFO"] StoreForward = 1 , } impl From < Tsf > for bool { # [inline (always)] fn from (variant : Tsf) -> Self { variant as u8 != 0 } } # [doc = "Field `TSF` reader - Transmit store and forward"] pub type TsfR = crate :: BitReader < Tsf > ; impl TsfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsf { match self . bits { false => Tsf :: CutThrough , true => Tsf :: StoreForward , } } # [doc = "Transmission starts when the frame size in the Tx FIFO exceeds TTC threshold"] # [inline (always)] pub fn is_cut_through (& self) -> bool { * self == Tsf :: CutThrough } # [doc = "Transmission starts when a full frame is in the Tx FIFO"] # [inline (always)] pub fn is_store_forward (& self) -> bool { * self == Tsf :: StoreForward } } # [doc = "Field `TSF` writer - Transmit store and forward"] pub type TsfW < 'a , REG > = crate :: BitWriter < 'a , REG , Tsf > ; impl < 'a , REG > TsfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Transmission starts when the frame size in the Tx FIFO exceeds TTC threshold"] # [inline (always)] pub fn cut_through (self) -> & 'a mut crate :: W < REG > { self . variant (Tsf :: CutThrough) } # [doc = "Transmission starts when a full frame is in the Tx FIFO"] # [inline (always)] pub fn store_forward (self) -> & 'a mut crate :: W < REG > { self . variant (Tsf :: StoreForward) } } # [doc = "Field `DFRF` reader - Disable flushing of received frames"] pub type DfrfR = crate :: BitReader ; # [doc = "Field `DFRF` writer - Disable flushing of received frames"] pub type DfrfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Receive store and forward\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rsf { # [doc = "0: Rx FIFO operates in cut-through mode, subject to RTC bits"] CutThrough = 0 , # [doc = "1: Frames are read from Rx FIFO after complete frame has been written"] StoreForward = 1 , } impl From < Rsf > for bool { # [inline (always)] fn from (variant : Rsf) -> Self { variant as u8 != 0 } } # [doc = "Field `RSF` reader - Receive store and forward"] pub type RsfR = crate :: BitReader < Rsf > ; impl RsfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rsf { match self . bits { false => Rsf :: CutThrough , true => Rsf :: StoreForward , } } # [doc = "Rx FIFO operates in cut-through mode, subject to RTC bits"] # [inline (always)] pub fn is_cut_through (& self) -> bool { * self == Rsf :: CutThrough } # [doc = "Frames are read from Rx FIFO after complete frame has been written"] # [inline (always)] pub fn is_store_forward (& self) -> bool { * self == Rsf :: StoreForward } } # [doc = "Field `RSF` writer - Receive store and forward"] pub type RsfW < 'a , REG > = crate :: BitWriter < 'a , REG , Rsf > ; impl < 'a , REG > RsfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Rx FIFO operates in cut-through mode, subject to RTC bits"] # [inline (always)] pub fn cut_through (self) -> & 'a mut crate :: W < REG > { self . variant (Rsf :: CutThrough) } # [doc = "Frames are read from Rx FIFO after complete frame has been written"] # [inline (always)] pub fn store_forward (self) -> & 'a mut crate :: W < REG > { self . variant (Rsf :: StoreForward) } } # [doc = "Dropping of TCP/IP checksum error frames disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dtcefd { # [doc = "0: Drop frames with errors only in the receive checksum offload engine"] Enabled = 0 , # [doc = "1: Do not drop frames that only have errors in the receive checksum offload engine"] Disabled = 1 , } impl From < Dtcefd > for bool { # [inline (always)] fn from (variant : Dtcefd) -> Self { variant as u8 != 0 } } # [doc = "Field `DTCEFD` reader - Dropping of TCP/IP checksum error frames disable"] pub type DtcefdR = crate :: BitReader < Dtcefd > ; impl DtcefdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dtcefd { match self . bits { false => Dtcefd :: Enabled , true => Dtcefd :: Disabled , } } # [doc = "Drop frames with errors only in the receive checksum offload engine"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dtcefd :: Enabled } # [doc = "Do not drop frames that only have errors in the receive checksum offload engine"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dtcefd :: Disabled } } # [doc = "Field `DTCEFD` writer - Dropping of TCP/IP checksum error frames disable"] pub type DtcefdW < 'a , REG > = crate :: BitWriter < 'a , REG , Dtcefd > ; impl < 'a , REG > DtcefdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Drop frames with errors only in the receive checksum offload engine"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dtcefd :: Enabled) } # [doc = "Do not drop frames that only have errors in the receive checksum offload engine"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dtcefd :: Disabled) } } impl R { # [doc = "Bit 1 - Start/stop receive"] # [inline (always)] pub fn sr (& self) -> SrR { SrR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Operate on second frame"] # [inline (always)] pub fn osf (& self) -> OsfR { OsfR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:4 - Receive threshold control"] # [inline (always)] pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bit 6 - Forward undersized good frames"] # [inline (always)] pub fn fugf (& self) -> FugfR { FugfR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Forward error frames"] # [inline (always)] pub fn fef (& self) -> FefR { FefR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 13 - Start/stop transmission"] # [inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bits 14:16 - Transmit threshold control"] # [inline (always)] pub fn ttc (& self) -> TtcR { TtcR :: new (((self . bits >> 14) & 7) as u8) } # [doc = "Bit 20 - Flush transmit FIFO"] # [inline (always)] pub fn ftf (& self) -> FtfR { FtfR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Transmit store and forward"] # [inline (always)] pub fn tsf (& self) -> TsfR { TsfR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 24 - Disable flushing of received frames"] # [inline (always)] pub fn dfrf (& self) -> DfrfR { DfrfR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Receive store and forward"] # [inline (always)] pub fn rsf (& self) -> RsfR { RsfR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Dropping of TCP/IP checksum error frames disable"] # [inline (always)] pub fn dtcefd (& self) -> DtcefdR { DtcefdR :: new (((self . bits >> 26) & 1) != 0) } } impl W { # [doc = "Bit 1 - Start/stop receive"] # [inline (always)] pub fn sr (& mut self) -> SrW < DmaomrSpec > { SrW :: new (self , 1) } # [doc = "Bit 2 - Operate on second frame"] # [inline (always)] pub fn osf (& mut self) -> OsfW < DmaomrSpec > { OsfW :: new (self , 2) } # [doc = "Bits 3:4 - Receive threshold control"] # [inline (always)] pub fn rtc (& mut self) -> RtcW < DmaomrSpec > { RtcW :: new (self , 3) } # [doc = "Bit 6 - Forward undersized good frames"] # [inline (always)] pub fn fugf (& mut self) -> FugfW < DmaomrSpec > { FugfW :: new (self , 6) } # [doc = "Bit 7 - Forward error frames"] # [inline (always)] pub fn fef (& mut self) -> FefW < DmaomrSpec > { FefW :: new (self , 7) } # [doc = "Bit 13 - Start/stop transmission"] # [inline (always)] pub fn st (& mut self) -> StW < DmaomrSpec > { StW :: new (self , 13) } # [doc = "Bits 14:16 - Transmit threshold control"] # [inline (always)] pub fn ttc (& mut self) -> TtcW < DmaomrSpec > { TtcW :: new (self , 14) } # [doc = "Bit 20 - Flush transmit FIFO"] # [inline (always)] pub fn ftf (& mut self) -> FtfW < DmaomrSpec > { FtfW :: new (self , 20) } # [doc = "Bit 21 - Transmit store and forward"] # [inline (always)] pub fn tsf (& mut self) -> TsfW < DmaomrSpec > { TsfW :: new (self , 21) } # [doc = "Bit 24 - Disable flushing of received frames"] # [inline (always)] pub fn dfrf (& mut self) -> DfrfW < DmaomrSpec > { DfrfW :: new (self , 24) } # [doc = "Bit 25 - Receive store and forward"] # [inline (always)] pub fn rsf (& mut self) -> RsfW < DmaomrSpec > { RsfW :: new (self , 25) } # [doc = "Bit 26 - Dropping of TCP/IP checksum error frames disable"] # [inline (always)] pub fn dtcefd (& mut self) -> DtcefdW < DmaomrSpec > { DtcefdW :: new (self , 26) } } # [doc = "Ethernet DMA operation mode register\n\nYou can [`read`](crate::Reg::read) this register and get [`dmaomr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmaomr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmaomrSpec ; impl crate :: RegisterSpec for DmaomrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dmaomr::R`](R) reader structure"] impl crate :: Readable for DmaomrSpec { } # [doc = "`write(|w| ..)` method takes [`dmaomr::W`](W) writer structure"] impl crate :: Writable for DmaomrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets DMAOMR to value 0"] impl crate :: Resettable for DmaomrSpec { }
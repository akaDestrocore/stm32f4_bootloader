# [doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ; # [doc = "Low-power deep sleep\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lpds { # [doc = "0: Main voltage regulator ON during Stop mode"] Main = 0 , # [doc = "1: Low-power voltage regulator ON during Stop mode"] LowPower = 1 , } impl From < Lpds > for bool { # [inline (always)] fn from (variant : Lpds) -> Self { variant as u8 != 0 } } # [doc = "Field `LPDS` reader - Low-power deep sleep"] pub type LpdsR = crate :: BitReader < Lpds > ; impl LpdsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lpds { match self . bits { false => Lpds :: Main , true => Lpds :: LowPower , } } # [doc = "Main voltage regulator ON during Stop mode"] # [inline (always)] pub fn is_main (& self) -> bool { * self == Lpds :: Main } # [doc = "Low-power voltage regulator ON during Stop mode"] # [inline (always)] pub fn is_low_power (& self) -> bool { * self == Lpds :: LowPower } } # [doc = "Field `LPDS` writer - Low-power deep sleep"] pub type LpdsW < 'a , REG > = crate :: BitWriter < 'a , REG , Lpds > ; impl < 'a , REG > LpdsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Main voltage regulator ON during Stop mode"] # [inline (always)] pub fn main (self) -> & 'a mut crate :: W < REG > { self . variant (Lpds :: Main) } # [doc = "Low-power voltage regulator ON during Stop mode"] # [inline (always)] pub fn low_power (self) -> & 'a mut crate :: W < REG > { self . variant (Lpds :: LowPower) } } # [doc = "Power down deepsleep\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pdds { # [doc = "0: Enter Stop mode when the CPU enters deepsleep. The regulator status depends on the LPDS bit"] EnterStop = 0 , # [doc = "1: Enter Standby mode when the CPU enters deepsleep"] EnterStandby = 1 , } impl From < Pdds > for bool { # [inline (always)] fn from (variant : Pdds) -> Self { variant as u8 != 0 } } # [doc = "Field `PDDS` reader - Power down deepsleep"] pub type PddsR = crate :: BitReader < Pdds > ; impl PddsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pdds { match self . bits { false => Pdds :: EnterStop , true => Pdds :: EnterStandby , } } # [doc = "Enter Stop mode when the CPU enters deepsleep. The regulator status depends on the LPDS bit"] # [inline (always)] pub fn is_enter_stop (& self) -> bool { * self == Pdds :: EnterStop } # [doc = "Enter Standby mode when the CPU enters deepsleep"] # [inline (always)] pub fn is_enter_standby (& self) -> bool { * self == Pdds :: EnterStandby } } # [doc = "Field `PDDS` writer - Power down deepsleep"] pub type PddsW < 'a , REG > = crate :: BitWriter < 'a , REG , Pdds > ; impl < 'a , REG > PddsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Enter Stop mode when the CPU enters deepsleep. The regulator status depends on the LPDS bit"] # [inline (always)] pub fn enter_stop (self) -> & 'a mut crate :: W < REG > { self . variant (Pdds :: EnterStop) } # [doc = "Enter Standby mode when the CPU enters deepsleep"] # [inline (always)] pub fn enter_standby (self) -> & 'a mut crate :: W < REG > { self . variant (Pdds :: EnterStandby) } } # [doc = "Clear wakeup flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cwufr { # [doc = "0: This bit is always read as 0"] Zero = 0 , } impl From < Cwufr > for bool { # [inline (always)] fn from (variant : Cwufr) -> Self { variant as u8 != 0 } } # [doc = "Field `CWUF` reader - Clear wakeup flag"] pub type CwufR = crate :: BitReader < Cwufr > ; impl CwufR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Cwufr > { match self . bits { false => Some (Cwufr :: Zero) , _ => None , } } # [doc = "This bit is always read as 0"] # [inline (always)] pub fn is_zero (& self) -> bool { * self == Cwufr :: Zero } } # [doc = "Clear wakeup flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CwufwWO { # [doc = "1: Clear the WUPF Wakeup Flag **after 2 System clock cycles**"] Clear = 1 , } impl From < CwufwWO > for bool { # [inline (always)] fn from (variant : CwufwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CWUF` writer - Clear wakeup flag"] pub type CwufW < 'a , REG > = crate :: BitWriter < 'a , REG , CwufwWO > ; impl < 'a , REG > CwufW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear the WUPF Wakeup Flag **after 2 System clock cycles**"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (CwufwWO :: Clear) } } # [doc = "Clear standby flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Csbfr { # [doc = "0: This bit is always read as 0"] Zero = 0 , } impl From < Csbfr > for bool { # [inline (always)] fn from (variant : Csbfr) -> Self { variant as u8 != 0 } } # [doc = "Field `CSBF` reader - Clear standby flag"] pub type CsbfR = crate :: BitReader < Csbfr > ; impl CsbfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Csbfr > { match self . bits { false => Some (Csbfr :: Zero) , _ => None , } } # [doc = "This bit is always read as 0"] # [inline (always)] pub fn is_zero (& self) -> bool { * self == Csbfr :: Zero } } # [doc = "Clear standby flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CsbfwWO { # [doc = "1: Clear the SBF Standby Flag"] Clear = 1 , } impl From < CsbfwWO > for bool { # [inline (always)] fn from (variant : CsbfwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CSBF` writer - Clear standby flag"] pub type CsbfW < 'a , REG > = crate :: BitWriter < 'a , REG , CsbfwWO > ; impl < 'a , REG > CsbfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear the SBF Standby Flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (CsbfwWO :: Clear) } } # [doc = "Power voltage detector enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pvde { # [doc = "0: PVD disabled"] Disabled = 0 , # [doc = "1: PVD enabled"] Enabled = 1 , } impl From < Pvde > for bool { # [inline (always)] fn from (variant : Pvde) -> Self { variant as u8 != 0 } } # [doc = "Field `PVDE` reader - Power voltage detector enable"] pub type PvdeR = crate :: BitReader < Pvde > ; impl PvdeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pvde { match self . bits { false => Pvde :: Disabled , true => Pvde :: Enabled , } } # [doc = "PVD disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pvde :: Disabled } # [doc = "PVD enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pvde :: Enabled } } # [doc = "Field `PVDE` writer - Power voltage detector enable"] pub type PvdeW < 'a , REG > = crate :: BitWriter < 'a , REG , Pvde > ; impl < 'a , REG > PvdeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PVD disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pvde :: Disabled) } # [doc = "PVD enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pvde :: Enabled) } } # [doc = "Field `PLS` reader - PVD level selection"] pub type PlsR = crate :: FieldReader ; # [doc = "Field `PLS` writer - PVD level selection"] pub type PlsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , u8 , crate :: Safe > ; # [doc = "Disable backup domain write protection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dbp { # [doc = "0: Access to RTC and RTC Backup registers and backup SRAM disabled"] Protected = 0 , # [doc = "1: Access to RTC and RTC Backup registers and backup SRAM enabled"] Writable = 1 , } impl From < Dbp > for bool { # [inline (always)] fn from (variant : Dbp) -> Self { variant as u8 != 0 } } # [doc = "Field `DBP` reader - Disable backup domain write protection"] pub type DbpR = crate :: BitReader < Dbp > ; impl DbpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dbp { match self . bits { false => Dbp :: Protected , true => Dbp :: Writable , } } # [doc = "Access to RTC and RTC Backup registers and backup SRAM disabled"] # [inline (always)] pub fn is_protected (& self) -> bool { * self == Dbp :: Protected } # [doc = "Access to RTC and RTC Backup registers and backup SRAM enabled"] # [inline (always)] pub fn is_writable (& self) -> bool { * self == Dbp :: Writable } } # [doc = "Field `DBP` writer - Disable backup domain write protection"] pub type DbpW < 'a , REG > = crate :: BitWriter < 'a , REG , Dbp > ; impl < 'a , REG > DbpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Access to RTC and RTC Backup registers and backup SRAM disabled"] # [inline (always)] pub fn protected (self) -> & 'a mut crate :: W < REG > { self . variant (Dbp :: Protected) } # [doc = "Access to RTC and RTC Backup registers and backup SRAM enabled"] # [inline (always)] pub fn writable (self) -> & 'a mut crate :: W < REG > { self . variant (Dbp :: Writable) } } # [doc = "Flash power down in Stop mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fpds { # [doc = "0: Flash memory not in power-down when the device is in Stop mode"] Idle = 0 , # [doc = "1: Flash memory in power-down when the device is in Stop mode"] PowerDown = 1 , } impl From < Fpds > for bool { # [inline (always)] fn from (variant : Fpds) -> Self { variant as u8 != 0 } } # [doc = "Field `FPDS` reader - Flash power down in Stop mode"] pub type FpdsR = crate :: BitReader < Fpds > ; impl FpdsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fpds { match self . bits { false => Fpds :: Idle , true => Fpds :: PowerDown , } } # [doc = "Flash memory not in power-down when the device is in Stop mode"] # [inline (always)] pub fn is_idle (& self) -> bool { * self == Fpds :: Idle } # [doc = "Flash memory in power-down when the device is in Stop mode"] # [inline (always)] pub fn is_power_down (& self) -> bool { * self == Fpds :: PowerDown } } # [doc = "Field `FPDS` writer - Flash power down in Stop mode"] pub type FpdsW < 'a , REG > = crate :: BitWriter < 'a , REG , Fpds > ; impl < 'a , REG > FpdsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Flash memory not in power-down when the device is in Stop mode"] # [inline (always)] pub fn idle (self) -> & 'a mut crate :: W < REG > { self . variant (Fpds :: Idle) } # [doc = "Flash memory in power-down when the device is in Stop mode"] # [inline (always)] pub fn power_down (self) -> & 'a mut crate :: W < REG > { self . variant (Fpds :: PowerDown) } } # [doc = "Regulator voltage scaling output selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Vos { # [doc = "0: Scale 2 mode"] Scale2 = 0 , # [doc = "1: Scale 1 mode (default value at reset)"] Scale1 = 1 , } impl From < Vos > for bool { # [inline (always)] fn from (variant : Vos) -> Self { variant as u8 != 0 } } # [doc = "Field `VOS` reader - Regulator voltage scaling output selection"] pub type VosR = crate :: BitReader < Vos > ; impl VosR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Vos { match self . bits { false => Vos :: Scale2 , true => Vos :: Scale1 , } } # [doc = "Scale 2 mode"] # [inline (always)] pub fn is_scale2 (& self) -> bool { * self == Vos :: Scale2 } # [doc = "Scale 1 mode (default value at reset)"] # [inline (always)] pub fn is_scale1 (& self) -> bool { * self == Vos :: Scale1 } } # [doc = "Field `VOS` writer - Regulator voltage scaling output selection"] pub type VosW < 'a , REG > = crate :: BitWriter < 'a , REG , Vos > ; impl < 'a , REG > VosW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Scale 2 mode"] # [inline (always)] pub fn scale2 (self) -> & 'a mut crate :: W < REG > { self . variant (Vos :: Scale2) } # [doc = "Scale 1 mode (default value at reset)"] # [inline (always)] pub fn scale1 (self) -> & 'a mut crate :: W < REG > { self . variant (Vos :: Scale1) } } impl R { # [doc = "Bit 0 - Low-power deep sleep"] # [inline (always)] pub fn lpds (& self) -> LpdsR { LpdsR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Power down deepsleep"] # [inline (always)] pub fn pdds (& self) -> PddsR { PddsR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Clear wakeup flag"] # [inline (always)] pub fn cwuf (& self) -> CwufR { CwufR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clear standby flag"] # [inline (always)] pub fn csbf (& self) -> CsbfR { CsbfR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Power voltage detector enable"] # [inline (always)] pub fn pvde (& self) -> PvdeR { PvdeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - PVD level selection"] # [inline (always)] pub fn pls (& self) -> PlsR { PlsR :: new (((self . bits >> 5) & 7) as u8) } # [doc = "Bit 8 - Disable backup domain write protection"] # [inline (always)] pub fn dbp (& self) -> DbpR { DbpR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Flash power down in Stop mode"] # [inline (always)] pub fn fpds (& self) -> FpdsR { FpdsR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 14 - Regulator voltage scaling output selection"] # [inline (always)] pub fn vos (& self) -> VosR { VosR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low-power deep sleep"] # [inline (always)] pub fn lpds (& mut self) -> LpdsW < CrSpec > { LpdsW :: new (self , 0) } # [doc = "Bit 1 - Power down deepsleep"] # [inline (always)] pub fn pdds (& mut self) -> PddsW < CrSpec > { PddsW :: new (self , 1) } # [doc = "Bit 2 - Clear wakeup flag"] # [inline (always)] pub fn cwuf (& mut self) -> CwufW < CrSpec > { CwufW :: new (self , 2) } # [doc = "Bit 3 - Clear standby flag"] # [inline (always)] pub fn csbf (& mut self) -> CsbfW < CrSpec > { CsbfW :: new (self , 3) } # [doc = "Bit 4 - Power voltage detector enable"] # [inline (always)] pub fn pvde (& mut self) -> PvdeW < CrSpec > { PvdeW :: new (self , 4) } # [doc = "Bits 5:7 - PVD level selection"] # [inline (always)] pub fn pls (& mut self) -> PlsW < CrSpec > { PlsW :: new (self , 5) } # [doc = "Bit 8 - Disable backup domain write protection"] # [inline (always)] pub fn dbp (& mut self) -> DbpW < CrSpec > { DbpW :: new (self , 8) } # [doc = "Bit 9 - Flash power down in Stop mode"] # [inline (always)] pub fn fpds (& mut self) -> FpdsW < CrSpec > { FpdsW :: new (self , 9) } # [doc = "Bit 14 - Regulator voltage scaling output selection"] # [inline (always)] pub fn vos (& mut self) -> VosW < CrSpec > { VosW :: new (self , 14) } } # [doc = "power control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { }
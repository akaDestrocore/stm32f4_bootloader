# [doc = "Register `CCR` reader"] pub type R = crate :: R < CcrSpec > ; # [doc = "Register `CCR` writer"] pub type W = crate :: W < CcrSpec > ; # [doc = "Multi ADC mode selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Multi { # [doc = "0: All the ADCs independent: independent mode"] Independent = 0 , # [doc = "1: Dual ADC1 and ADC2, combined regular and injected simultaneous mode"] DualRj = 1 , # [doc = "2: Dual ADC1 and ADC2, combined regular and alternate trigger mode"] DualRa = 2 , # [doc = "5: Dual ADC1 and ADC2, injected simultaneous mode only"] DualJ = 5 , # [doc = "6: Dual ADC1 and ADC2, regular simultaneous mode only"] DualR = 6 , # [doc = "7: Dual ADC1 and ADC2, interleaved mode only"] DualI = 7 , # [doc = "9: Dual ADC1 and ADC2, alternate trigger mode only"] DualA = 9 , # [doc = "17: Triple ADC, regular and injected simultaneous mode"] TripleRj = 17 , # [doc = "18: Triple ADC, regular and alternate trigger mode"] TripleRa = 18 , # [doc = "21: Triple ADC, injected simultaneous mode only"] TripleJ = 21 , # [doc = "22: Triple ADC, regular simultaneous mode only"] TripleR = 22 , # [doc = "23: Triple ADC, interleaved mode only"] TripleI = 23 , # [doc = "24: Triple ADC, alternate trigger mode only"] TripleA = 24 , } impl From < Multi > for u8 { # [inline (always)] fn from (variant : Multi) -> Self { variant as _ } } impl crate :: FieldSpec for Multi { type Ux = u8 ; } impl crate :: IsEnum for Multi { } # [doc = "Field `MULTI` reader - Multi ADC mode selection"] pub type MultiR = crate :: FieldReader < Multi > ; impl MultiR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Multi > { match self . bits { 0 => Some (Multi :: Independent) , 1 => Some (Multi :: DualRj) , 2 => Some (Multi :: DualRa) , 5 => Some (Multi :: DualJ) , 6 => Some (Multi :: DualR) , 7 => Some (Multi :: DualI) , 9 => Some (Multi :: DualA) , 17 => Some (Multi :: TripleRj) , 18 => Some (Multi :: TripleRa) , 21 => Some (Multi :: TripleJ) , 22 => Some (Multi :: TripleR) , 23 => Some (Multi :: TripleI) , 24 => Some (Multi :: TripleA) , _ => None , } } # [doc = "All the ADCs independent: independent mode"] # [inline (always)] pub fn is_independent (& self) -> bool { * self == Multi :: Independent } # [doc = "Dual ADC1 and ADC2, combined regular and injected simultaneous mode"] # [inline (always)] pub fn is_dual_rj (& self) -> bool { * self == Multi :: DualRj } # [doc = "Dual ADC1 and ADC2, combined regular and alternate trigger mode"] # [inline (always)] pub fn is_dual_ra (& self) -> bool { * self == Multi :: DualRa } # [doc = "Dual ADC1 and ADC2, injected simultaneous mode only"] # [inline (always)] pub fn is_dual_j (& self) -> bool { * self == Multi :: DualJ } # [doc = "Dual ADC1 and ADC2, regular simultaneous mode only"] # [inline (always)] pub fn is_dual_r (& self) -> bool { * self == Multi :: DualR } # [doc = "Dual ADC1 and ADC2, interleaved mode only"] # [inline (always)] pub fn is_dual_i (& self) -> bool { * self == Multi :: DualI } # [doc = "Dual ADC1 and ADC2, alternate trigger mode only"] # [inline (always)] pub fn is_dual_a (& self) -> bool { * self == Multi :: DualA } # [doc = "Triple ADC, regular and injected simultaneous mode"] # [inline (always)] pub fn is_triple_rj (& self) -> bool { * self == Multi :: TripleRj } # [doc = "Triple ADC, regular and alternate trigger mode"] # [inline (always)] pub fn is_triple_ra (& self) -> bool { * self == Multi :: TripleRa } # [doc = "Triple ADC, injected simultaneous mode only"] # [inline (always)] pub fn is_triple_j (& self) -> bool { * self == Multi :: TripleJ } # [doc = "Triple ADC, regular simultaneous mode only"] # [inline (always)] pub fn is_triple_r (& self) -> bool { * self == Multi :: TripleR } # [doc = "Triple ADC, interleaved mode only"] # [inline (always)] pub fn is_triple_i (& self) -> bool { * self == Multi :: TripleI } # [doc = "Triple ADC, alternate trigger mode only"] # [inline (always)] pub fn is_triple_a (& self) -> bool { * self == Multi :: TripleA } } # [doc = "Field `MULTI` writer - Multi ADC mode selection"] pub type MultiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 , Multi > ; impl < 'a , REG > MultiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "All the ADCs independent: independent mode"] # [inline (always)] pub fn independent (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: Independent) } # [doc = "Dual ADC1 and ADC2, combined regular and injected simultaneous mode"] # [inline (always)] pub fn dual_rj (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualRj) } # [doc = "Dual ADC1 and ADC2, combined regular and alternate trigger mode"] # [inline (always)] pub fn dual_ra (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualRa) } # [doc = "Dual ADC1 and ADC2, injected simultaneous mode only"] # [inline (always)] pub fn dual_j (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualJ) } # [doc = "Dual ADC1 and ADC2, regular simultaneous mode only"] # [inline (always)] pub fn dual_r (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualR) } # [doc = "Dual ADC1 and ADC2, interleaved mode only"] # [inline (always)] pub fn dual_i (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualI) } # [doc = "Dual ADC1 and ADC2, alternate trigger mode only"] # [inline (always)] pub fn dual_a (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: DualA) } # [doc = "Triple ADC, regular and injected simultaneous mode"] # [inline (always)] pub fn triple_rj (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleRj) } # [doc = "Triple ADC, regular and alternate trigger mode"] # [inline (always)] pub fn triple_ra (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleRa) } # [doc = "Triple ADC, injected simultaneous mode only"] # [inline (always)] pub fn triple_j (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleJ) } # [doc = "Triple ADC, regular simultaneous mode only"] # [inline (always)] pub fn triple_r (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleR) } # [doc = "Triple ADC, interleaved mode only"] # [inline (always)] pub fn triple_i (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleI) } # [doc = "Triple ADC, alternate trigger mode only"] # [inline (always)] pub fn triple_a (self) -> & 'a mut crate :: W < REG > { self . variant (Multi :: TripleA) } } # [doc = "Field `DELAY` reader - Delay between 2 sampling phases"] pub type DelayR = crate :: FieldReader ; # [doc = "Field `DELAY` writer - Delay between 2 sampling phases"] pub type DelayW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "DMA disable selection for multi-ADC mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dds { # [doc = "0: No new DMA request is issued after the last transfer"] Single = 0 , # [doc = "1: DMA requests are issued as long as data are converted and DMA=01, 10 or 11"] Continuous = 1 , } impl From < Dds > for bool { # [inline (always)] fn from (variant : Dds) -> Self { variant as u8 != 0 } } # [doc = "Field `DDS` reader - DMA disable selection for multi-ADC mode"] pub type DdsR = crate :: BitReader < Dds > ; impl DdsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dds { match self . bits { false => Dds :: Single , true => Dds :: Continuous , } } # [doc = "No new DMA request is issued after the last transfer"] # [inline (always)] pub fn is_single (& self) -> bool { * self == Dds :: Single } # [doc = "DMA requests are issued as long as data are converted and DMA=01, 10 or 11"] # [inline (always)] pub fn is_continuous (& self) -> bool { * self == Dds :: Continuous } } # [doc = "Field `DDS` writer - DMA disable selection for multi-ADC mode"] pub type DdsW < 'a , REG > = crate :: BitWriter < 'a , REG , Dds > ; impl < 'a , REG > DdsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No new DMA request is issued after the last transfer"] # [inline (always)] pub fn single (self) -> & 'a mut crate :: W < REG > { self . variant (Dds :: Single) } # [doc = "DMA requests are issued as long as data are converted and DMA=01, 10 or 11"] # [inline (always)] pub fn continuous (self) -> & 'a mut crate :: W < REG > { self . variant (Dds :: Continuous) } } # [doc = "Direct memory access mode for multi ADC mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Dma { # [doc = "0: DMA mode disabled"] Disabled = 0 , # [doc = "1: DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)"] Mode1 = 1 , # [doc = "2: DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] Mode2 = 2 , # [doc = "3: DMA mode 3 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] Mode3 = 3 , } impl From < Dma > for u8 { # [inline (always)] fn from (variant : Dma) -> Self { variant as _ } } impl crate :: FieldSpec for Dma { type Ux = u8 ; } impl crate :: IsEnum for Dma { } # [doc = "Field `DMA` reader - Direct memory access mode for multi ADC mode"] pub type DmaR = crate :: FieldReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dma { match self . bits { 0 => Dma :: Disabled , 1 => Dma :: Mode1 , 2 => Dma :: Mode2 , 3 => Dma :: Mode3 , _ => unreachable ! () , } } # [doc = "DMA mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dma :: Disabled } # [doc = "DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)"] # [inline (always)] pub fn is_mode1 (& self) -> bool { * self == Dma :: Mode1 } # [doc = "DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] # [inline (always)] pub fn is_mode2 (& self) -> bool { * self == Dma :: Mode2 } # [doc = "DMA mode 3 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] # [inline (always)] pub fn is_mode3 (& self) -> bool { * self == Dma :: Mode3 } } # [doc = "Field `DMA` writer - Direct memory access mode for multi ADC mode"] pub type DmaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Dma , crate :: Safe > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "DMA mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Disabled) } # [doc = "DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)"] # [inline (always)] pub fn mode1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Mode1) } # [doc = "DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] # [inline (always)] pub fn mode2 (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Mode2) } # [doc = "DMA mode 3 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)"] # [inline (always)] pub fn mode3 (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Mode3) } } # [doc = "ADC prescaler\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Adcpre { # [doc = "0: PCLK2 divided by 2"] Div2 = 0 , # [doc = "1: PCLK2 divided by 4"] Div4 = 1 , # [doc = "2: PCLK2 divided by 6"] Div6 = 2 , # [doc = "3: PCLK2 divided by 8"] Div8 = 3 , } impl From < Adcpre > for u8 { # [inline (always)] fn from (variant : Adcpre) -> Self { variant as _ } } impl crate :: FieldSpec for Adcpre { type Ux = u8 ; } impl crate :: IsEnum for Adcpre { } # [doc = "Field `ADCPRE` reader - ADC prescaler"] pub type AdcpreR = crate :: FieldReader < Adcpre > ; impl AdcpreR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Adcpre { match self . bits { 0 => Adcpre :: Div2 , 1 => Adcpre :: Div4 , 2 => Adcpre :: Div6 , 3 => Adcpre :: Div8 , _ => unreachable ! () , } } # [doc = "PCLK2 divided by 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Adcpre :: Div2 } # [doc = "PCLK2 divided by 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Adcpre :: Div4 } # [doc = "PCLK2 divided by 6"] # [inline (always)] pub fn is_div6 (& self) -> bool { * self == Adcpre :: Div6 } # [doc = "PCLK2 divided by 8"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Adcpre :: Div8 } } # [doc = "Field `ADCPRE` writer - ADC prescaler"] pub type AdcpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Adcpre , crate :: Safe > ; impl < 'a , REG > AdcpreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "PCLK2 divided by 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Adcpre :: Div2) } # [doc = "PCLK2 divided by 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Adcpre :: Div4) } # [doc = "PCLK2 divided by 6"] # [inline (always)] pub fn div6 (self) -> & 'a mut crate :: W < REG > { self . variant (Adcpre :: Div6) } # [doc = "PCLK2 divided by 8"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Adcpre :: Div8) } } # [doc = "VBAT enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Vbate { # [doc = "0: V_BAT channel disabled"] Disabled = 0 , # [doc = "1: V_BAT channel enabled"] Enabled = 1 , } impl From < Vbate > for bool { # [inline (always)] fn from (variant : Vbate) -> Self { variant as u8 != 0 } } # [doc = "Field `VBATE` reader - VBAT enable"] pub type VbateR = crate :: BitReader < Vbate > ; impl VbateR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Vbate { match self . bits { false => Vbate :: Disabled , true => Vbate :: Enabled , } } # [doc = "V_BAT channel disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Vbate :: Disabled } # [doc = "V_BAT channel enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Vbate :: Enabled } } # [doc = "Field `VBATE` writer - VBAT enable"] pub type VbateW < 'a , REG > = crate :: BitWriter < 'a , REG , Vbate > ; impl < 'a , REG > VbateW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "V_BAT channel disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Vbate :: Disabled) } # [doc = "V_BAT channel enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Vbate :: Enabled) } } # [doc = "Temperature sensor and VREFINT enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tsvrefe { # [doc = "0: Temperature sensor and V_REFINT channel disabled"] Disabled = 0 , # [doc = "1: Temperature sensor and V_REFINT channel enabled"] Enabled = 1 , } impl From < Tsvrefe > for bool { # [inline (always)] fn from (variant : Tsvrefe) -> Self { variant as u8 != 0 } } # [doc = "Field `TSVREFE` reader - Temperature sensor and VREFINT enable"] pub type TsvrefeR = crate :: BitReader < Tsvrefe > ; impl TsvrefeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsvrefe { match self . bits { false => Tsvrefe :: Disabled , true => Tsvrefe :: Enabled , } } # [doc = "Temperature sensor and V_REFINT channel disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Tsvrefe :: Disabled } # [doc = "Temperature sensor and V_REFINT channel enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Tsvrefe :: Enabled } } # [doc = "Field `TSVREFE` writer - Temperature sensor and VREFINT enable"] pub type TsvrefeW < 'a , REG > = crate :: BitWriter < 'a , REG , Tsvrefe > ; impl < 'a , REG > TsvrefeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Temperature sensor and V_REFINT channel disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tsvrefe :: Disabled) } # [doc = "Temperature sensor and V_REFINT channel enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tsvrefe :: Enabled) } } impl R { # [doc = "Bits 0:4 - Multi ADC mode selection"] # [inline (always)] pub fn multi (& self) -> MultiR { MultiR :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 8:11 - Delay between 2 sampling phases"] # [inline (always)] pub fn delay (& self) -> DelayR { DelayR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 13 - DMA disable selection for multi-ADC mode"] # [inline (always)] pub fn dds (& self) -> DdsR { DdsR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bits 14:15 - Direct memory access mode for multi ADC mode"] # [inline (always)] pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - ADC prescaler"] # [inline (always)] pub fn adcpre (& self) -> AdcpreR { AdcpreR :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bit 22 - VBAT enable"] # [inline (always)] pub fn vbate (& self) -> VbateR { VbateR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Temperature sensor and VREFINT enable"] # [inline (always)] pub fn tsvrefe (& self) -> TsvrefeR { TsvrefeR :: new (((self . bits >> 23) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Multi ADC mode selection"] # [inline (always)] pub fn multi (& mut self) -> MultiW < CcrSpec > { MultiW :: new (self , 0) } # [doc = "Bits 8:11 - Delay between 2 sampling phases"] # [inline (always)] pub fn delay (& mut self) -> DelayW < CcrSpec > { DelayW :: new (self , 8) } # [doc = "Bit 13 - DMA disable selection for multi-ADC mode"] # [inline (always)] pub fn dds (& mut self) -> DdsW < CcrSpec > { DdsW :: new (self , 13) } # [doc = "Bits 14:15 - Direct memory access mode for multi ADC mode"] # [inline (always)] pub fn dma (& mut self) -> DmaW < CcrSpec > { DmaW :: new (self , 14) } # [doc = "Bits 16:17 - ADC prescaler"] # [inline (always)] pub fn adcpre (& mut self) -> AdcpreW < CcrSpec > { AdcpreW :: new (self , 16) } # [doc = "Bit 22 - VBAT enable"] # [inline (always)] pub fn vbate (& mut self) -> VbateW < CcrSpec > { VbateW :: new (self , 22) } # [doc = "Bit 23 - Temperature sensor and VREFINT enable"] # [inline (always)] pub fn tsvrefe (& mut self) -> TsvrefeW < CcrSpec > { TsvrefeW :: new (self , 23) } } # [doc = "ADC common control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcrSpec ; impl crate :: RegisterSpec for CcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ccr::R`](R) reader structure"] impl crate :: Readable for CcrSpec { } # [doc = "`write(|w| ..)` method takes [`ccr::W`](W) writer structure"] impl crate :: Writable for CcrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CCR to value 0"] impl crate :: Resettable for CcrSpec { }
# [doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ; # [doc = "Analog watchdog flag of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Awd1 { # [doc = "0: No analog watchdog event occurred"] NoEvent = 0 , # [doc = "1: Analog watchdog event occurred"] Event = 1 , } impl From < Awd1 > for bool { # [inline (always)] fn from (variant : Awd1) -> Self { variant as u8 != 0 } } # [doc = "Field `AWD1` reader - Analog watchdog flag of ADC 1"] pub type Awd1R = crate :: BitReader < Awd1 > ; impl Awd1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Awd1 { match self . bits { false => Awd1 :: NoEvent , true => Awd1 :: Event , } } # [doc = "No analog watchdog event occurred"] # [inline (always)] pub fn is_no_event (& self) -> bool { * self == Awd1 :: NoEvent } # [doc = "Analog watchdog event occurred"] # [inline (always)] pub fn is_event (& self) -> bool { * self == Awd1 :: Event } } # [doc = "End of conversion of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eoc1 { # [doc = "0: Conversion is not complete"] NotComplete = 0 , # [doc = "1: Conversion complete"] Complete = 1 , } impl From < Eoc1 > for bool { # [inline (always)] fn from (variant : Eoc1) -> Self { variant as u8 != 0 } } # [doc = "Field `EOC1` reader - End of conversion of ADC 1"] pub type Eoc1R = crate :: BitReader < Eoc1 > ; impl Eoc1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eoc1 { match self . bits { false => Eoc1 :: NotComplete , true => Eoc1 :: Complete , } } # [doc = "Conversion is not complete"] # [inline (always)] pub fn is_not_complete (& self) -> bool { * self == Eoc1 :: NotComplete } # [doc = "Conversion complete"] # [inline (always)] pub fn is_complete (& self) -> bool { * self == Eoc1 :: Complete } } # [doc = "Injected channel end of conversion of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jeoc1 { # [doc = "0: Conversion is not complete"] NotComplete = 0 , # [doc = "1: Conversion complete"] Complete = 1 , } impl From < Jeoc1 > for bool { # [inline (always)] fn from (variant : Jeoc1) -> Self { variant as u8 != 0 } } # [doc = "Field `JEOC1` reader - Injected channel end of conversion of ADC 1"] pub type Jeoc1R = crate :: BitReader < Jeoc1 > ; impl Jeoc1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jeoc1 { match self . bits { false => Jeoc1 :: NotComplete , true => Jeoc1 :: Complete , } } # [doc = "Conversion is not complete"] # [inline (always)] pub fn is_not_complete (& self) -> bool { * self == Jeoc1 :: NotComplete } # [doc = "Conversion complete"] # [inline (always)] pub fn is_complete (& self) -> bool { * self == Jeoc1 :: Complete } } # [doc = "Injected channel Start flag of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jstrt1 { # [doc = "0: No injected channel conversion started"] NotStarted = 0 , # [doc = "1: Injected channel conversion has started"] Started = 1 , } impl From < Jstrt1 > for bool { # [inline (always)] fn from (variant : Jstrt1) -> Self { variant as u8 != 0 } } # [doc = "Field `JSTRT1` reader - Injected channel Start flag of ADC 1"] pub type Jstrt1R = crate :: BitReader < Jstrt1 > ; impl Jstrt1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jstrt1 { match self . bits { false => Jstrt1 :: NotStarted , true => Jstrt1 :: Started , } } # [doc = "No injected channel conversion started"] # [inline (always)] pub fn is_not_started (& self) -> bool { * self == Jstrt1 :: NotStarted } # [doc = "Injected channel conversion has started"] # [inline (always)] pub fn is_started (& self) -> bool { * self == Jstrt1 :: Started } } # [doc = "Regular channel Start flag of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Strt1 { # [doc = "0: No regular channel conversion started"] NotStarted = 0 , # [doc = "1: Regular channel conversion has started"] Started = 1 , } impl From < Strt1 > for bool { # [inline (always)] fn from (variant : Strt1) -> Self { variant as u8 != 0 } } # [doc = "Field `STRT1` reader - Regular channel Start flag of ADC 1"] pub type Strt1R = crate :: BitReader < Strt1 > ; impl Strt1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Strt1 { match self . bits { false => Strt1 :: NotStarted , true => Strt1 :: Started , } } # [doc = "No regular channel conversion started"] # [inline (always)] pub fn is_not_started (& self) -> bool { * self == Strt1 :: NotStarted } # [doc = "Regular channel conversion has started"] # [inline (always)] pub fn is_started (& self) -> bool { * self == Strt1 :: Started } } # [doc = "Overrun flag of ADC 1\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ovr1 { # [doc = "0: No overrun occurred"] NoOverrun = 0 , # [doc = "1: Overrun occurred"] Overrun = 1 , } impl From < Ovr1 > for bool { # [inline (always)] fn from (variant : Ovr1) -> Self { variant as u8 != 0 } } # [doc = "Field `OVR1` reader - Overrun flag of ADC 1"] pub type Ovr1R = crate :: BitReader < Ovr1 > ; impl Ovr1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ovr1 { match self . bits { false => Ovr1 :: NoOverrun , true => Ovr1 :: Overrun , } } # [doc = "No overrun occurred"] # [inline (always)] pub fn is_no_overrun (& self) -> bool { * self == Ovr1 :: NoOverrun } # [doc = "Overrun occurred"] # [inline (always)] pub fn is_overrun (& self) -> bool { * self == Ovr1 :: Overrun } } # [doc = "Field `AWD2` reader - Analog watchdog flag of ADC 2"] pub use Awd1R as Awd2R ; # [doc = "Field `EOC2` reader - End of conversion of ADC 2"] pub use Eoc1R as Eoc2R ; # [doc = "Field `JEOC2` reader - Injected channel end of conversion of ADC 2"] pub use Jeoc1R as Jeoc2R ; # [doc = "Field `JSTRT2` reader - Injected channel Start flag of ADC 2"] pub use Jstrt1R as Jstrt2R ; # [doc = "Field `STRT2` reader - Regular channel Start flag of ADC 2"] pub use Strt1R as Strt2R ; # [doc = "Field `OVR2` reader - Overrun flag of ADC 2"] pub use Ovr1R as Ovr2R ; # [doc = "Field `AWD3` reader - Analog watchdog flag of ADC 3"] pub use Awd1R as Awd3R ; # [doc = "Field `EOC3` reader - End of conversion of ADC 3"] pub use Eoc1R as Eoc3R ; # [doc = "Field `JEOC3` reader - Injected channel end of conversion of ADC 3"] pub use Jeoc1R as Jeoc3R ; # [doc = "Field `JSTRT3` reader - Injected channel Start flag of ADC 3"] pub use Jstrt1R as Jstrt3R ; # [doc = "Field `STRT3` reader - Regular channel Start flag of ADC 3"] pub use Strt1R as Strt3R ; # [doc = "Field `OVR3` reader - Overrun flag of ADC3"] pub use Ovr1R as Ovr3R ; impl R { # [doc = "Bit 0 - Analog watchdog flag of ADC 1"] # [inline (always)] pub fn awd1 (& self) -> Awd1R { Awd1R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - End of conversion of ADC 1"] # [inline (always)] pub fn eoc1 (& self) -> Eoc1R { Eoc1R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Injected channel end of conversion of ADC 1"] # [inline (always)] pub fn jeoc1 (& self) -> Jeoc1R { Jeoc1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Injected channel Start flag of ADC 1"] # [inline (always)] pub fn jstrt1 (& self) -> Jstrt1R { Jstrt1R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Regular channel Start flag of ADC 1"] # [inline (always)] pub fn strt1 (& self) -> Strt1R { Strt1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Overrun flag of ADC 1"] # [inline (always)] pub fn ovr1 (& self) -> Ovr1R { Ovr1R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Analog watchdog flag of ADC 2"] # [inline (always)] pub fn awd2 (& self) -> Awd2R { Awd2R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - End of conversion of ADC 2"] # [inline (always)] pub fn eoc2 (& self) -> Eoc2R { Eoc2R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Injected channel end of conversion of ADC 2"] # [inline (always)] pub fn jeoc2 (& self) -> Jeoc2R { Jeoc2R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Injected channel Start flag of ADC 2"] # [inline (always)] pub fn jstrt2 (& self) -> Jstrt2R { Jstrt2R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Regular channel Start flag of ADC 2"] # [inline (always)] pub fn strt2 (& self) -> Strt2R { Strt2R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Overrun flag of ADC 2"] # [inline (always)] pub fn ovr2 (& self) -> Ovr2R { Ovr2R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 16 - Analog watchdog flag of ADC 3"] # [inline (always)] pub fn awd3 (& self) -> Awd3R { Awd3R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - End of conversion of ADC 3"] # [inline (always)] pub fn eoc3 (& self) -> Eoc3R { Eoc3R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Injected channel end of conversion of ADC 3"] # [inline (always)] pub fn jeoc3 (& self) -> Jeoc3R { Jeoc3R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Injected channel Start flag of ADC 3"] # [inline (always)] pub fn jstrt3 (& self) -> Jstrt3R { Jstrt3R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Regular channel Start flag of ADC 3"] # [inline (always)] pub fn strt3 (& self) -> Strt3R { Strt3R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Overrun flag of ADC3"] # [inline (always)] pub fn ovr3 (& self) -> Ovr3R { Ovr3R :: new (((self . bits >> 21) & 1) != 0) } } # [doc = "ADC Common status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { } # [doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { }
# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Counter enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cen { # [doc = "0: Counter disabled"] Disabled = 0 , # [doc = "1: Counter enabled"] Enabled = 1 , } impl From < Cen > for bool { # [inline (always)] fn from (variant : Cen) -> Self { variant as u8 != 0 } } # [doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader < Cen > ; impl CenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cen { match self . bits { false => Cen :: Disabled , true => Cen :: Enabled , } } # [doc = "Counter disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Cen :: Disabled } # [doc = "Counter enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Cen :: Enabled } } # [doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG , Cen > ; impl < 'a , REG > CenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counter disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cen :: Disabled) } # [doc = "Counter enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cen :: Enabled) } } # [doc = "Update disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Udis { # [doc = "0: Update event enabled"] Enabled = 0 , # [doc = "1: Update event disabled"] Disabled = 1 , } impl From < Udis > for bool { # [inline (always)] fn from (variant : Udis) -> Self { variant as u8 != 0 } } # [doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader < Udis > ; impl UdisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Udis { match self . bits { false => Udis :: Enabled , true => Udis :: Disabled , } } # [doc = "Update event enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Udis :: Enabled } # [doc = "Update event disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Udis :: Disabled } } # [doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Udis > ; impl < 'a , REG > UdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Update event enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Udis :: Enabled) } # [doc = "Update event disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Udis :: Disabled) } } # [doc = "Update request source\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Urs { # [doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] AnyEvent = 0 , # [doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"] CounterOnly = 1 , } impl From < Urs > for bool { # [inline (always)] fn from (variant : Urs) -> Self { variant as u8 != 0 } } # [doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader < Urs > ; impl UrsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Urs { match self . bits { false => Urs :: AnyEvent , true => Urs :: CounterOnly , } } # [doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] # [inline (always)] pub fn is_any_event (& self) -> bool { * self == Urs :: AnyEvent } # [doc = "Only counter overflow/underflow generates an update interrupt or DMA request"] # [inline (always)] pub fn is_counter_only (& self) -> bool { * self == Urs :: CounterOnly } } # [doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG , Urs > ; impl < 'a , REG > UrsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] # [inline (always)] pub fn any_event (self) -> & 'a mut crate :: W < REG > { self . variant (Urs :: AnyEvent) } # [doc = "Only counter overflow/underflow generates an update interrupt or DMA request"] # [inline (always)] pub fn counter_only (self) -> & 'a mut crate :: W < REG > { self . variant (Urs :: CounterOnly) } } # [doc = "One-pulse mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Opm { # [doc = "0: Counter is not stopped at update event"] Disabled = 0 , # [doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"] Enabled = 1 , } impl From < Opm > for bool { # [inline (always)] fn from (variant : Opm) -> Self { variant as u8 != 0 } } # [doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader < Opm > ; impl OpmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Opm { match self . bits { false => Opm :: Disabled , true => Opm :: Enabled , } } # [doc = "Counter is not stopped at update event"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Opm :: Disabled } # [doc = "Counter stops counting at the next update event (clearing the CEN bit)"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Opm :: Enabled } } # [doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG , Opm > ; impl < 'a , REG > OpmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counter is not stopped at update event"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Opm :: Disabled) } # [doc = "Counter stops counting at the next update event (clearing the CEN bit)"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Opm :: Enabled) } } # [doc = "Auto-reload preload enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Arpe { # [doc = "0: TIMx_APRR register is not buffered"] Disabled = 0 , # [doc = "1: TIMx_APRR register is buffered"] Enabled = 1 , } impl From < Arpe > for bool { # [inline (always)] fn from (variant : Arpe) -> Self { variant as u8 != 0 } } # [doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader < Arpe > ; impl ArpeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Arpe { match self . bits { false => Arpe :: Disabled , true => Arpe :: Enabled , } } # [doc = "TIMx_APRR register is not buffered"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Arpe :: Disabled } # [doc = "TIMx_APRR register is buffered"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Arpe :: Enabled } } # [doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG , Arpe > ; impl < 'a , REG > ArpeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TIMx_APRR register is not buffered"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Arpe :: Disabled) } # [doc = "TIMx_APRR register is buffered"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Arpe :: Enabled) } } impl R { # [doc = "Bit 0 - Counter enable"] # [inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Update disable"] # [inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Update request source"] # [inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - One-pulse mode"] # [inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Auto-reload preload enable"] # [inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Counter enable"] # [inline (always)] pub fn cen (& mut self) -> CenW < Cr1Spec > { CenW :: new (self , 0) } # [doc = "Bit 1 - Update disable"] # [inline (always)] pub fn udis (& mut self) -> UdisW < Cr1Spec > { UdisW :: new (self , 1) } # [doc = "Bit 2 - Update request source"] # [inline (always)] pub fn urs (& mut self) -> UrsW < Cr1Spec > { UrsW :: new (self , 2) } # [doc = "Bit 3 - One-pulse mode"] # [inline (always)] pub fn opm (& mut self) -> OpmW < Cr1Spec > { OpmW :: new (self , 3) } # [doc = "Bit 7 - Auto-reload preload enable"] # [inline (always)] pub fn arpe (& mut self) -> ArpeW < Cr1Spec > { ArpeW :: new (self , 7) } } # [doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
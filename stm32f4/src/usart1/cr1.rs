# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Send break\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sbk { # [doc = "0: No break character is transmitted"] NoBreak = 0 , # [doc = "1: Break character transmitted"] Break = 1 , } impl From < Sbk > for bool { # [inline (always)] fn from (variant : Sbk) -> Self { variant as u8 != 0 } } # [doc = "Field `SBK` reader - Send break"] pub type SbkR = crate :: BitReader < Sbk > ; impl SbkR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sbk { match self . bits { false => Sbk :: NoBreak , true => Sbk :: Break , } } # [doc = "No break character is transmitted"] # [inline (always)] pub fn is_no_break (& self) -> bool { * self == Sbk :: NoBreak } # [doc = "Break character transmitted"] # [inline (always)] pub fn is_break (& self) -> bool { * self == Sbk :: Break } } # [doc = "Field `SBK` writer - Send break"] pub type SbkW < 'a , REG > = crate :: BitWriter < 'a , REG , Sbk > ; impl < 'a , REG > SbkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No break character is transmitted"] # [inline (always)] pub fn no_break (self) -> & 'a mut crate :: W < REG > { self . variant (Sbk :: NoBreak) } # [doc = "Break character transmitted"] # [inline (always)] pub fn break_ (self) -> & 'a mut crate :: W < REG > { self . variant (Sbk :: Break) } } # [doc = "Receiver wakeup\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rwu { # [doc = "0: Receiver in active mode"] Active = 0 , # [doc = "1: Receiver in mute mode"] Mute = 1 , } impl From < Rwu > for bool { # [inline (always)] fn from (variant : Rwu) -> Self { variant as u8 != 0 } } # [doc = "Field `RWU` reader - Receiver wakeup"] pub type RwuR = crate :: BitReader < Rwu > ; impl RwuR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rwu { match self . bits { false => Rwu :: Active , true => Rwu :: Mute , } } # [doc = "Receiver in active mode"] # [inline (always)] pub fn is_active (& self) -> bool { * self == Rwu :: Active } # [doc = "Receiver in mute mode"] # [inline (always)] pub fn is_mute (& self) -> bool { * self == Rwu :: Mute } } # [doc = "Field `RWU` writer - Receiver wakeup"] pub type RwuW < 'a , REG > = crate :: BitWriter < 'a , REG , Rwu > ; impl < 'a , REG > RwuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Receiver in active mode"] # [inline (always)] pub fn active (self) -> & 'a mut crate :: W < REG > { self . variant (Rwu :: Active) } # [doc = "Receiver in mute mode"] # [inline (always)] pub fn mute (self) -> & 'a mut crate :: W < REG > { self . variant (Rwu :: Mute) } } # [doc = "Receiver enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Re { # [doc = "0: Receiver disabled"] Disabled = 0 , # [doc = "1: Receiver enabled"] Enabled = 1 , } impl From < Re > for bool { # [inline (always)] fn from (variant : Re) -> Self { variant as u8 != 0 } } # [doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader < Re > ; impl ReR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Re { match self . bits { false => Re :: Disabled , true => Re :: Enabled , } } # [doc = "Receiver disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Re :: Disabled } # [doc = "Receiver enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Re :: Enabled } } # [doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG , Re > ; impl < 'a , REG > ReW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Receiver disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Disabled) } # [doc = "Receiver enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Enabled) } } # [doc = "Transmitter enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Te { # [doc = "0: Transmitter disabled"] Disabled = 0 , # [doc = "1: Transmitter enabled"] Enabled = 1 , } impl From < Te > for bool { # [inline (always)] fn from (variant : Te) -> Self { variant as u8 != 0 } } # [doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader < Te > ; impl TeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Te { match self . bits { false => Te :: Disabled , true => Te :: Enabled , } } # [doc = "Transmitter disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Te :: Disabled } # [doc = "Transmitter enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Te :: Enabled } } # [doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG , Te > ; impl < 'a , REG > TeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Transmitter disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Disabled) } # [doc = "Transmitter enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Enabled) } } # [doc = "IDLE interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Idleie { # [doc = "0: IDLE interrupt disabled"] Disabled = 0 , # [doc = "1: IDLE interrupt enabled"] Enabled = 1 , } impl From < Idleie > for bool { # [inline (always)] fn from (variant : Idleie) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLEIE` reader - IDLE interrupt enable"] pub type IdleieR = crate :: BitReader < Idleie > ; impl IdleieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Idleie { match self . bits { false => Idleie :: Disabled , true => Idleie :: Enabled , } } # [doc = "IDLE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Idleie :: Disabled } # [doc = "IDLE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Idleie :: Enabled } } # [doc = "Field `IDLEIE` writer - IDLE interrupt enable"] pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG , Idleie > ; impl < 'a , REG > IdleieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "IDLE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Disabled) } # [doc = "IDLE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Enabled) } } # [doc = "RXNE interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxneie { # [doc = "0: RXNE interrupt disabled"] Disabled = 0 , # [doc = "1: RXNE interrupt enabled"] Enabled = 1 , } impl From < Rxneie > for bool { # [inline (always)] fn from (variant : Rxneie) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNEIE` reader - RXNE interrupt enable"] pub type RxneieR = crate :: BitReader < Rxneie > ; impl RxneieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxneie { match self . bits { false => Rxneie :: Disabled , true => Rxneie :: Enabled , } } # [doc = "RXNE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rxneie :: Disabled } # [doc = "RXNE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rxneie :: Enabled } } # [doc = "Field `RXNEIE` writer - RXNE interrupt enable"] pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxneie > ; impl < 'a , REG > RxneieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RXNE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Disabled) } # [doc = "RXNE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Enabled) } } # [doc = "Transmission complete interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcie { # [doc = "0: TC interrupt disabled"] Disabled = 0 , # [doc = "1: TC interrupt enabled"] Enabled = 1 , } impl From < Tcie > for bool { # [inline (always)] fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Transmission complete interrupt enable"] pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disabled , true => Tcie :: Enabled , } } # [doc = "TC interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Tcie :: Disabled } # [doc = "TC interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Tcie :: Enabled } } # [doc = "Field `TCIE` writer - Transmission complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TC interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disabled) } # [doc = "TC interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enabled) } } # [doc = "TXE interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txeie { # [doc = "0: TXE interrupt disabled"] Disabled = 0 , # [doc = "1: TXE interrupt enabled"] Enabled = 1 , } impl From < Txeie > for bool { # [inline (always)] fn from (variant : Txeie) -> Self { variant as u8 != 0 } } # [doc = "Field `TXEIE` reader - TXE interrupt enable"] pub type TxeieR = crate :: BitReader < Txeie > ; impl TxeieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txeie { match self . bits { false => Txeie :: Disabled , true => Txeie :: Enabled , } } # [doc = "TXE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Txeie :: Disabled } # [doc = "TXE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Txeie :: Enabled } } # [doc = "Field `TXEIE` writer - TXE interrupt enable"] pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Txeie > ; impl < 'a , REG > TxeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TXE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Disabled) } # [doc = "TXE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Enabled) } } # [doc = "PE interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Peie { # [doc = "0: PE interrupt disabled"] Disabled = 0 , # [doc = "1: PE interrupt enabled"] Enabled = 1 , } impl From < Peie > for bool { # [inline (always)] fn from (variant : Peie) -> Self { variant as u8 != 0 } } # [doc = "Field `PEIE` reader - PE interrupt enable"] pub type PeieR = crate :: BitReader < Peie > ; impl PeieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Peie { match self . bits { false => Peie :: Disabled , true => Peie :: Enabled , } } # [doc = "PE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Peie :: Disabled } # [doc = "PE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Peie :: Enabled } } # [doc = "Field `PEIE` writer - PE interrupt enable"] pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Peie > ; impl < 'a , REG > PeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "PE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Disabled) } # [doc = "PE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Enabled) } } # [doc = "Parity selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ps { # [doc = "0: Even parity"] Even = 0 , # [doc = "1: Odd parity"] Odd = 1 , } impl From < Ps > for bool { # [inline (always)] fn from (variant : Ps) -> Self { variant as u8 != 0 } } # [doc = "Field `PS` reader - Parity selection"] pub type PsR = crate :: BitReader < Ps > ; impl PsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ps { match self . bits { false => Ps :: Even , true => Ps :: Odd , } } # [doc = "Even parity"] # [inline (always)] pub fn is_even (& self) -> bool { * self == Ps :: Even } # [doc = "Odd parity"] # [inline (always)] pub fn is_odd (& self) -> bool { * self == Ps :: Odd } } # [doc = "Field `PS` writer - Parity selection"] pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG , Ps > ; impl < 'a , REG > PsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Even parity"] # [inline (always)] pub fn even (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Even) } # [doc = "Odd parity"] # [inline (always)] pub fn odd (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Odd) } } # [doc = "Parity control enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pce { # [doc = "0: Parity control disabled"] Disabled = 0 , # [doc = "1: Parity control enabled"] Enabled = 1 , } impl From < Pce > for bool { # [inline (always)] fn from (variant : Pce) -> Self { variant as u8 != 0 } } # [doc = "Field `PCE` reader - Parity control enable"] pub type PceR = crate :: BitReader < Pce > ; impl PceR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pce { match self . bits { false => Pce :: Disabled , true => Pce :: Enabled , } } # [doc = "Parity control disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pce :: Disabled } # [doc = "Parity control enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pce :: Enabled } } # [doc = "Field `PCE` writer - Parity control enable"] pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG , Pce > ; impl < 'a , REG > PceW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Parity control disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Disabled) } # [doc = "Parity control enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Enabled) } } # [doc = "Wakeup method\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wake { # [doc = "0: USART wakeup on idle line"] IdleLine = 0 , # [doc = "1: USART wakeup on address mark"] AddressMark = 1 , } impl From < Wake > for bool { # [inline (always)] fn from (variant : Wake) -> Self { variant as u8 != 0 } } # [doc = "Field `WAKE` reader - Wakeup method"] pub type WakeR = crate :: BitReader < Wake > ; impl WakeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wake { match self . bits { false => Wake :: IdleLine , true => Wake :: AddressMark , } } # [doc = "USART wakeup on idle line"] # [inline (always)] pub fn is_idle_line (& self) -> bool { * self == Wake :: IdleLine } # [doc = "USART wakeup on address mark"] # [inline (always)] pub fn is_address_mark (& self) -> bool { * self == Wake :: AddressMark } } # [doc = "Field `WAKE` writer - Wakeup method"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG , Wake > ; impl < 'a , REG > WakeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "USART wakeup on idle line"] # [inline (always)] pub fn idle_line (self) -> & 'a mut crate :: W < REG > { self . variant (Wake :: IdleLine) } # [doc = "USART wakeup on address mark"] # [inline (always)] pub fn address_mark (self) -> & 'a mut crate :: W < REG > { self . variant (Wake :: AddressMark) } } # [doc = "Word length\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum M { # [doc = "0: 8 data bits"] M8 = 0 , # [doc = "1: 9 data bits"] M9 = 1 , } impl From < M > for bool { # [inline (always)] fn from (variant : M) -> Self { variant as u8 != 0 } } # [doc = "Field `M` reader - Word length"] pub type MR = crate :: BitReader < M > ; impl MR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> M { match self . bits { false => M :: M8 , true => M :: M9 , } } # [doc = "8 data bits"] # [inline (always)] pub fn is_m8 (& self) -> bool { * self == M :: M8 } # [doc = "9 data bits"] # [inline (always)] pub fn is_m9 (& self) -> bool { * self == M :: M9 } } # [doc = "Field `M` writer - Word length"] pub type MW < 'a , REG > = crate :: BitWriter < 'a , REG , M > ; impl < 'a , REG > MW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "8 data bits"] # [inline (always)] pub fn m8 (self) -> & 'a mut crate :: W < REG > { self . variant (M :: M8) } # [doc = "9 data bits"] # [inline (always)] pub fn m9 (self) -> & 'a mut crate :: W < REG > { self . variant (M :: M9) } } # [doc = "USART enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ue { # [doc = "0: USART prescaler and outputs disabled"] Disabled = 0 , # [doc = "1: USART enabled"] Enabled = 1 , } impl From < Ue > for bool { # [inline (always)] fn from (variant : Ue) -> Self { variant as u8 != 0 } } # [doc = "Field `UE` reader - USART enable"] pub type UeR = crate :: BitReader < Ue > ; impl UeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ue { match self . bits { false => Ue :: Disabled , true => Ue :: Enabled , } } # [doc = "USART prescaler and outputs disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ue :: Disabled } # [doc = "USART enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ue :: Enabled } } # [doc = "Field `UE` writer - USART enable"] pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG , Ue > ; impl < 'a , REG > UeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "USART prescaler and outputs disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Disabled) } # [doc = "USART enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Enabled) } } # [doc = "Oversampling mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Over8 { # [doc = "0: Oversampling by 16"] Oversample16 = 0 , # [doc = "1: Oversampling by 8"] Oversample8 = 1 , } impl From < Over8 > for bool { # [inline (always)] fn from (variant : Over8) -> Self { variant as u8 != 0 } } # [doc = "Field `OVER8` reader - Oversampling mode"] pub type Over8R = crate :: BitReader < Over8 > ; impl Over8R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Over8 { match self . bits { false => Over8 :: Oversample16 , true => Over8 :: Oversample8 , } } # [doc = "Oversampling by 16"] # [inline (always)] pub fn is_oversample16 (& self) -> bool { * self == Over8 :: Oversample16 } # [doc = "Oversampling by 8"] # [inline (always)] pub fn is_oversample8 (& self) -> bool { * self == Over8 :: Oversample8 } } # [doc = "Field `OVER8` writer - Oversampling mode"] pub type Over8W < 'a , REG > = crate :: BitWriter < 'a , REG , Over8 > ; impl < 'a , REG > Over8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Oversampling by 16"] # [inline (always)] pub fn oversample16 (self) -> & 'a mut crate :: W < REG > { self . variant (Over8 :: Oversample16) } # [doc = "Oversampling by 8"] # [inline (always)] pub fn oversample8 (self) -> & 'a mut crate :: W < REG > { self . variant (Over8 :: Oversample8) } } impl R { # [doc = "Bit 0 - Send break"] # [inline (always)] pub fn sbk (& self) -> SbkR { SbkR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receiver wakeup"] # [inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receiver enable"] # [inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter enable"] # [inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - IDLE interrupt enable"] # [inline (always)] pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - RXNE interrupt enable"] # [inline (always)] pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmission complete interrupt enable"] # [inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - TXE interrupt enable"] # [inline (always)] pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - PE interrupt enable"] # [inline (always)] pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Parity selection"] # [inline (always)] pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Parity control enable"] # [inline (always)] pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Wakeup method"] # [inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Word length"] # [inline (always)] pub fn m (& self) -> MR { MR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - USART enable"] # [inline (always)] pub fn ue (& self) -> UeR { UeR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 15 - Oversampling mode"] # [inline (always)] pub fn over8 (& self) -> Over8R { Over8R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Send break"] # [inline (always)] pub fn sbk (& mut self) -> SbkW < Cr1Spec > { SbkW :: new (self , 0) } # [doc = "Bit 1 - Receiver wakeup"] # [inline (always)] pub fn rwu (& mut self) -> RwuW < Cr1Spec > { RwuW :: new (self , 1) } # [doc = "Bit 2 - Receiver enable"] # [inline (always)] pub fn re (& mut self) -> ReW < Cr1Spec > { ReW :: new (self , 2) } # [doc = "Bit 3 - Transmitter enable"] # [inline (always)] pub fn te (& mut self) -> TeW < Cr1Spec > { TeW :: new (self , 3) } # [doc = "Bit 4 - IDLE interrupt enable"] # [inline (always)] pub fn idleie (& mut self) -> IdleieW < Cr1Spec > { IdleieW :: new (self , 4) } # [doc = "Bit 5 - RXNE interrupt enable"] # [inline (always)] pub fn rxneie (& mut self) -> RxneieW < Cr1Spec > { RxneieW :: new (self , 5) } # [doc = "Bit 6 - Transmission complete interrupt enable"] # [inline (always)] pub fn tcie (& mut self) -> TcieW < Cr1Spec > { TcieW :: new (self , 6) } # [doc = "Bit 7 - TXE interrupt enable"] # [inline (always)] pub fn txeie (& mut self) -> TxeieW < Cr1Spec > { TxeieW :: new (self , 7) } # [doc = "Bit 8 - PE interrupt enable"] # [inline (always)] pub fn peie (& mut self) -> PeieW < Cr1Spec > { PeieW :: new (self , 8) } # [doc = "Bit 9 - Parity selection"] # [inline (always)] pub fn ps (& mut self) -> PsW < Cr1Spec > { PsW :: new (self , 9) } # [doc = "Bit 10 - Parity control enable"] # [inline (always)] pub fn pce (& mut self) -> PceW < Cr1Spec > { PceW :: new (self , 10) } # [doc = "Bit 11 - Wakeup method"] # [inline (always)] pub fn wake (& mut self) -> WakeW < Cr1Spec > { WakeW :: new (self , 11) } # [doc = "Bit 12 - Word length"] # [inline (always)] pub fn m (& mut self) -> MW < Cr1Spec > { MW :: new (self , 12) } # [doc = "Bit 13 - USART enable"] # [inline (always)] pub fn ue (& mut self) -> UeW < Cr1Spec > { UeW :: new (self , 13) } # [doc = "Bit 15 - Oversampling mode"] # [inline (always)] pub fn over8 (& mut self) -> Over8W < Cr1Spec > { Over8W :: new (self , 15) } } # [doc = "Control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
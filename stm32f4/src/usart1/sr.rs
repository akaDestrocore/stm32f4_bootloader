# [doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "Parity error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pe { # [doc = "0: No parity error"] NoError = 0 , # [doc = "1: Parity error"] Error = 1 , } impl From < Pe > for bool { # [inline (always)] fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Parity error"] pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: NoError , true => Pe :: Error , } } # [doc = "No parity error"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Pe :: NoError } # [doc = "Parity error"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Pe :: Error } } # [doc = "Framing error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fe { # [doc = "0: No Framing error is detected"] NoError = 0 , # [doc = "1: Framing error or break character is detected"] Error = 1 , } impl From < Fe > for bool { # [inline (always)] fn from (variant : Fe) -> Self { variant as u8 != 0 } } # [doc = "Field `FE` reader - Framing error"] pub type FeR = crate :: BitReader < Fe > ; impl FeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fe { match self . bits { false => Fe :: NoError , true => Fe :: Error , } } # [doc = "No Framing error is detected"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Fe :: NoError } # [doc = "Framing error or break character is detected"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Fe :: Error } } # [doc = "Noise detected flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Nf { # [doc = "0: No noise is detected"] NoNoise = 0 , # [doc = "1: Noise is detected"] Noise = 1 , } impl From < Nf > for bool { # [inline (always)] fn from (variant : Nf) -> Self { variant as u8 != 0 } } # [doc = "Field `NF` reader - Noise detected flag"] pub type NfR = crate :: BitReader < Nf > ; impl NfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Nf { match self . bits { false => Nf :: NoNoise , true => Nf :: Noise , } } # [doc = "No noise is detected"] # [inline (always)] pub fn is_no_noise (& self) -> bool { * self == Nf :: NoNoise } # [doc = "Noise is detected"] # [inline (always)] pub fn is_noise (& self) -> bool { * self == Nf :: Noise } } # [doc = "Overrun error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ore { # [doc = "0: No Overrun error"] NoOverrun = 0 , # [doc = "1: Overrun error is detected"] Overrun = 1 , } impl From < Ore > for bool { # [inline (always)] fn from (variant : Ore) -> Self { variant as u8 != 0 } } # [doc = "Field `ORE` reader - Overrun error"] pub type OreR = crate :: BitReader < Ore > ; impl OreR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ore { match self . bits { false => Ore :: NoOverrun , true => Ore :: Overrun , } } # [doc = "No Overrun error"] # [inline (always)] pub fn is_no_overrun (& self) -> bool { * self == Ore :: NoOverrun } # [doc = "Overrun error is detected"] # [inline (always)] pub fn is_overrun (& self) -> bool { * self == Ore :: Overrun } } # [doc = "IDLE line detected\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Idle { # [doc = "0: No Idle Line is detected"] NoIdle = 0 , # [doc = "1: Idle Line is detected"] Idle = 1 , } impl From < Idle > for bool { # [inline (always)] fn from (variant : Idle) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLE` reader - IDLE line detected"] pub type IdleR = crate :: BitReader < Idle > ; impl IdleR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Idle { match self . bits { false => Idle :: NoIdle , true => Idle :: Idle , } } # [doc = "No Idle Line is detected"] # [inline (always)] pub fn is_no_idle (& self) -> bool { * self == Idle :: NoIdle } # [doc = "Idle Line is detected"] # [inline (always)] pub fn is_idle (& self) -> bool { * self == Idle :: Idle } } # [doc = "Read data register not empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxner { # [doc = "0: Data is not received"] NoData = 0 , # [doc = "1: Received data is ready to be read"] DataReady = 1 , } impl From < Rxner > for bool { # [inline (always)] fn from (variant : Rxner) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNE` reader - Read data register not empty"] pub type RxneR = crate :: BitReader < Rxner > ; impl RxneR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxner { match self . bits { false => Rxner :: NoData , true => Rxner :: DataReady , } } # [doc = "Data is not received"] # [inline (always)] pub fn is_no_data (& self) -> bool { * self == Rxner :: NoData } # [doc = "Received data is ready to be read"] # [inline (always)] pub fn is_data_ready (& self) -> bool { * self == Rxner :: DataReady } } # [doc = "Read data register not empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum RxnewWO { # [doc = "0: Clear received data ready flag"] Clear = 0 , } impl From < RxnewWO > for bool { # [inline (always)] fn from (variant : RxnewWO) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNE` writer - Read data register not empty"] pub type RxneW < 'a , REG > = crate :: BitWriter0C < 'a , REG , RxnewWO > ; impl < 'a , REG > RxneW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear received data ready flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (RxnewWO :: Clear) } } # [doc = "Transmission complete\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcr { # [doc = "0: Transmission is not complete"] TxNotComplete = 0 , # [doc = "1: Transmission is complete"] TxComplete = 1 , } impl From < Tcr > for bool { # [inline (always)] fn from (variant : Tcr) -> Self { variant as u8 != 0 } } # [doc = "Field `TC` reader - Transmission complete"] pub type TcR = crate :: BitReader < Tcr > ; impl TcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcr { match self . bits { false => Tcr :: TxNotComplete , true => Tcr :: TxComplete , } } # [doc = "Transmission is not complete"] # [inline (always)] pub fn is_tx_not_complete (& self) -> bool { * self == Tcr :: TxNotComplete } # [doc = "Transmission is complete"] # [inline (always)] pub fn is_tx_complete (& self) -> bool { * self == Tcr :: TxComplete } } # [doc = "Transmission complete\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum TcwWO { # [doc = "0: Clear transmission complete flag"] Clear = 0 , } impl From < TcwWO > for bool { # [inline (always)] fn from (variant : TcwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `TC` writer - Transmission complete"] pub type TcW < 'a , REG > = crate :: BitWriter0C < 'a , REG , TcwWO > ; impl < 'a , REG > TcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear transmission complete flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (TcwWO :: Clear) } } # [doc = "Transmit data register empty\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txe { # [doc = "0: Data is not transferred to the shift register"] TxNotEmpty = 0 , # [doc = "1: Data is transferred to the shift register"] TxEmpty = 1 , } impl From < Txe > for bool { # [inline (always)] fn from (variant : Txe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXE` reader - Transmit data register empty"] pub type TxeR = crate :: BitReader < Txe > ; impl TxeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txe { match self . bits { false => Txe :: TxNotEmpty , true => Txe :: TxEmpty , } } # [doc = "Data is not transferred to the shift register"] # [inline (always)] pub fn is_tx_not_empty (& self) -> bool { * self == Txe :: TxNotEmpty } # [doc = "Data is transferred to the shift register"] # [inline (always)] pub fn is_tx_empty (& self) -> bool { * self == Txe :: TxEmpty } } # [doc = "LIN break detection flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lbdr { # [doc = "0: LIN break not detected"] NotDetected = 0 , # [doc = "1: LIN break detected"] Detected = 1 , } impl From < Lbdr > for bool { # [inline (always)] fn from (variant : Lbdr) -> Self { variant as u8 != 0 } } # [doc = "Field `LBD` reader - LIN break detection flag"] pub type LbdR = crate :: BitReader < Lbdr > ; impl LbdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lbdr { match self . bits { false => Lbdr :: NotDetected , true => Lbdr :: Detected , } } # [doc = "LIN break not detected"] # [inline (always)] pub fn is_not_detected (& self) -> bool { * self == Lbdr :: NotDetected } # [doc = "LIN break detected"] # [inline (always)] pub fn is_detected (& self) -> bool { * self == Lbdr :: Detected } } # [doc = "LIN break detection flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum LbdwWO { # [doc = "0: Clear LIN break detection flag"] Clear = 0 , } impl From < LbdwWO > for bool { # [inline (always)] fn from (variant : LbdwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `LBD` writer - LIN break detection flag"] pub type LbdW < 'a , REG > = crate :: BitWriter0C < 'a , REG , LbdwWO > ; impl < 'a , REG > LbdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear LIN break detection flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (LbdwWO :: Clear) } } # [doc = "CTS flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ctsr { # [doc = "0: No change occurred on the CTS status line"] NotChanged = 0 , # [doc = "1: A change occurred on the CTS status line"] Changed = 1 , } impl From < Ctsr > for bool { # [inline (always)] fn from (variant : Ctsr) -> Self { variant as u8 != 0 } } # [doc = "Field `CTS` reader - CTS flag"] pub type CtsR = crate :: BitReader < Ctsr > ; impl CtsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ctsr { match self . bits { false => Ctsr :: NotChanged , true => Ctsr :: Changed , } } # [doc = "No change occurred on the CTS status line"] # [inline (always)] pub fn is_not_changed (& self) -> bool { * self == Ctsr :: NotChanged } # [doc = "A change occurred on the CTS status line"] # [inline (always)] pub fn is_changed (& self) -> bool { * self == Ctsr :: Changed } } # [doc = "CTS flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CtswWO { # [doc = "0: Clear CTS toggle detection flag"] Clear = 0 , } impl From < CtswWO > for bool { # [inline (always)] fn from (variant : CtswWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CTS` writer - CTS flag"] pub type CtsW < 'a , REG > = crate :: BitWriter0C < 'a , REG , CtswWO > ; impl < 'a , REG > CtsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear CTS toggle detection flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (CtswWO :: Clear) } } impl R { # [doc = "Bit 0 - Parity error"] # [inline (always)] pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Framing error"] # [inline (always)] pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Noise detected flag"] # [inline (always)] pub fn nf (& self) -> NfR { NfR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Overrun error"] # [inline (always)] pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - IDLE line detected"] # [inline (always)] pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Read data register not empty"] # [inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmission complete"] # [inline (always)] pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Transmit data register empty"] # [inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - LIN break detection flag"] # [inline (always)] pub fn lbd (& self) -> LbdR { LbdR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - CTS flag"] # [inline (always)] pub fn cts (& self) -> CtsR { CtsR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 5 - Read data register not empty"] # [inline (always)] pub fn rxne (& mut self) -> RxneW < SrSpec > { RxneW :: new (self , 5) } # [doc = "Bit 6 - Transmission complete"] # [inline (always)] pub fn tc (& mut self) -> TcW < SrSpec > { TcW :: new (self , 6) } # [doc = "Bit 8 - LIN break detection flag"] # [inline (always)] pub fn lbd (& mut self) -> LbdW < SrSpec > { LbdW :: new (self , 8) } # [doc = "Bit 9 - CTS flag"] # [inline (always)] pub fn cts (& mut self) -> CtsW < SrSpec > { CtsW :: new (self , 9) } } # [doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u16 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0x0360 ; } # [doc = "`reset()` method sets SR to value 0xc0"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u16 = 0xc0 ; }
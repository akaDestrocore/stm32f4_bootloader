# [doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ; # [doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ; # [doc = "Error interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eie { # [doc = "0: Error interrupt disabled"] Disabled = 0 , # [doc = "1: Error interrupt enabled"] Enabled = 1 , } impl From < Eie > for bool { # [inline (always)] fn from (variant : Eie) -> Self { variant as u8 != 0 } } # [doc = "Field `EIE` reader - Error interrupt enable"] pub type EieR = crate :: BitReader < Eie > ; impl EieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eie { match self . bits { false => Eie :: Disabled , true => Eie :: Enabled , } } # [doc = "Error interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Eie :: Disabled } # [doc = "Error interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Eie :: Enabled } } # [doc = "Field `EIE` writer - Error interrupt enable"] pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG , Eie > ; impl < 'a , REG > EieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Error interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Disabled) } # [doc = "Error interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Enabled) } } # [doc = "IrDA mode enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iren { # [doc = "0: IrDA disabled"] Disabled = 0 , # [doc = "1: IrDA enabled"] Enabled = 1 , } impl From < Iren > for bool { # [inline (always)] fn from (variant : Iren) -> Self { variant as u8 != 0 } } # [doc = "Field `IREN` reader - IrDA mode enable"] pub type IrenR = crate :: BitReader < Iren > ; impl IrenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iren { match self . bits { false => Iren :: Disabled , true => Iren :: Enabled , } } # [doc = "IrDA disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Iren :: Disabled } # [doc = "IrDA enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Iren :: Enabled } } # [doc = "Field `IREN` writer - IrDA mode enable"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG , Iren > ; impl < 'a , REG > IrenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "IrDA disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iren :: Disabled) } # [doc = "IrDA enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iren :: Enabled) } } # [doc = "IrDA low-power\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Irlp { # [doc = "0: Normal mode"] Normal = 0 , # [doc = "1: Low-power mode"] LowPower = 1 , } impl From < Irlp > for bool { # [inline (always)] fn from (variant : Irlp) -> Self { variant as u8 != 0 } } # [doc = "Field `IRLP` reader - IrDA low-power"] pub type IrlpR = crate :: BitReader < Irlp > ; impl IrlpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Irlp { match self . bits { false => Irlp :: Normal , true => Irlp :: LowPower , } } # [doc = "Normal mode"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Irlp :: Normal } # [doc = "Low-power mode"] # [inline (always)] pub fn is_low_power (& self) -> bool { * self == Irlp :: LowPower } } # [doc = "Field `IRLP` writer - IrDA low-power"] pub type IrlpW < 'a , REG > = crate :: BitWriter < 'a , REG , Irlp > ; impl < 'a , REG > IrlpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal mode"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Irlp :: Normal) } # [doc = "Low-power mode"] # [inline (always)] pub fn low_power (self) -> & 'a mut crate :: W < REG > { self . variant (Irlp :: LowPower) } } # [doc = "Half-duplex selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hdsel { # [doc = "0: Half duplex mode is not selected"] FullDuplex = 0 , # [doc = "1: Half duplex mode is selected"] HalfDuplex = 1 , } impl From < Hdsel > for bool { # [inline (always)] fn from (variant : Hdsel) -> Self { variant as u8 != 0 } } # [doc = "Field `HDSEL` reader - Half-duplex selection"] pub type HdselR = crate :: BitReader < Hdsel > ; impl HdselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hdsel { match self . bits { false => Hdsel :: FullDuplex , true => Hdsel :: HalfDuplex , } } # [doc = "Half duplex mode is not selected"] # [inline (always)] pub fn is_full_duplex (& self) -> bool { * self == Hdsel :: FullDuplex } # [doc = "Half duplex mode is selected"] # [inline (always)] pub fn is_half_duplex (& self) -> bool { * self == Hdsel :: HalfDuplex } } # [doc = "Field `HDSEL` writer - Half-duplex selection"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG , Hdsel > ; impl < 'a , REG > HdselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Half duplex mode is not selected"] # [inline (always)] pub fn full_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: FullDuplex) } # [doc = "Half duplex mode is selected"] # [inline (always)] pub fn half_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: HalfDuplex) } } # [doc = "Smartcard NACK enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Nack { # [doc = "0: NACK transmission in case of parity error is disabled"] Disabled = 0 , # [doc = "1: NACK transmission during parity error is enabled"] Enabled = 1 , } impl From < Nack > for bool { # [inline (always)] fn from (variant : Nack) -> Self { variant as u8 != 0 } } # [doc = "Field `NACK` reader - Smartcard NACK enable"] pub type NackR = crate :: BitReader < Nack > ; impl NackR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Nack { match self . bits { false => Nack :: Disabled , true => Nack :: Enabled , } } # [doc = "NACK transmission in case of parity error is disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Nack :: Disabled } # [doc = "NACK transmission during parity error is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Nack :: Enabled } } # [doc = "Field `NACK` writer - Smartcard NACK enable"] pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG , Nack > ; impl < 'a , REG > NackW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NACK transmission in case of parity error is disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Disabled) } # [doc = "NACK transmission during parity error is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Enabled) } } # [doc = "Smartcard mode enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Scen { # [doc = "0: Smartcard mode disabled"] Disabled = 0 , # [doc = "1: Smartcard mode enabled"] Enabled = 1 , } impl From < Scen > for bool { # [inline (always)] fn from (variant : Scen) -> Self { variant as u8 != 0 } } # [doc = "Field `SCEN` reader - Smartcard mode enable"] pub type ScenR = crate :: BitReader < Scen > ; impl ScenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Scen { match self . bits { false => Scen :: Disabled , true => Scen :: Enabled , } } # [doc = "Smartcard mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Scen :: Disabled } # [doc = "Smartcard mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Scen :: Enabled } } # [doc = "Field `SCEN` writer - Smartcard mode enable"] pub type ScenW < 'a , REG > = crate :: BitWriter < 'a , REG , Scen > ; impl < 'a , REG > ScenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Smartcard mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Scen :: Disabled) } # [doc = "Smartcard mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Scen :: Enabled) } } # [doc = "DMA enable receiver\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmar { # [doc = "0: DMA mode is disabled for reception"] Disabled = 0 , # [doc = "1: DMA mode is enabled for reception"] Enabled = 1 , } impl From < Dmar > for bool { # [inline (always)] fn from (variant : Dmar) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAR` reader - DMA enable receiver"] pub type DmarR = crate :: BitReader < Dmar > ; impl DmarR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmar { match self . bits { false => Dmar :: Disabled , true => Dmar :: Enabled , } } # [doc = "DMA mode is disabled for reception"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmar :: Disabled } # [doc = "DMA mode is enabled for reception"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmar :: Enabled } } # [doc = "Field `DMAR` writer - DMA enable receiver"] pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmar > ; impl < 'a , REG > DmarW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DMA mode is disabled for reception"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Disabled) } # [doc = "DMA mode is enabled for reception"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Enabled) } } # [doc = "DMA enable transmitter\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmat { # [doc = "0: DMA mode is disabled for transmission"] Disabled = 0 , # [doc = "1: DMA mode is enabled for transmission"] Enabled = 1 , } impl From < Dmat > for bool { # [inline (always)] fn from (variant : Dmat) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAT` reader - DMA enable transmitter"] pub type DmatR = crate :: BitReader < Dmat > ; impl DmatR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmat { match self . bits { false => Dmat :: Disabled , true => Dmat :: Enabled , } } # [doc = "DMA mode is disabled for transmission"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmat :: Disabled } # [doc = "DMA mode is enabled for transmission"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmat :: Enabled } } # [doc = "Field `DMAT` writer - DMA enable transmitter"] pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmat > ; impl < 'a , REG > DmatW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DMA mode is disabled for transmission"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Disabled) } # [doc = "DMA mode is enabled for transmission"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Enabled) } } # [doc = "RTS enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rtse { # [doc = "0: RTS hardware flow control disabled"] Disabled = 0 , # [doc = "1: RTS hardware flow control enabled"] Enabled = 1 , } impl From < Rtse > for bool { # [inline (always)] fn from (variant : Rtse) -> Self { variant as u8 != 0 } } # [doc = "Field `RTSE` reader - RTS enable"] pub type RtseR = crate :: BitReader < Rtse > ; impl RtseR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rtse { match self . bits { false => Rtse :: Disabled , true => Rtse :: Enabled , } } # [doc = "RTS hardware flow control disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rtse :: Disabled } # [doc = "RTS hardware flow control enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rtse :: Enabled } } # [doc = "Field `RTSE` writer - RTS enable"] pub type RtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Rtse > ; impl < 'a , REG > RtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RTS hardware flow control disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: Disabled) } # [doc = "RTS hardware flow control enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: Enabled) } } # [doc = "CTS enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ctse { # [doc = "0: CTS hardware flow control disabled"] Disabled = 0 , # [doc = "1: CTS hardware flow control enabled"] Enabled = 1 , } impl From < Ctse > for bool { # [inline (always)] fn from (variant : Ctse) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSE` reader - CTS enable"] pub type CtseR = crate :: BitReader < Ctse > ; impl CtseR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ctse { match self . bits { false => Ctse :: Disabled , true => Ctse :: Enabled , } } # [doc = "CTS hardware flow control disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ctse :: Disabled } # [doc = "CTS hardware flow control enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ctse :: Enabled } } # [doc = "Field `CTSE` writer - CTS enable"] pub type CtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctse > ; impl < 'a , REG > CtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CTS hardware flow control disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Disabled) } # [doc = "CTS hardware flow control enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Enabled) } } # [doc = "CTS interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ctsie { # [doc = "0: CTS interrupt disabled"] Disabled = 0 , # [doc = "1: CTS interrupt enabled"] Enabled = 1 , } impl From < Ctsie > for bool { # [inline (always)] fn from (variant : Ctsie) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSIE` reader - CTS interrupt enable"] pub type CtsieR = crate :: BitReader < Ctsie > ; impl CtsieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ctsie { match self . bits { false => Ctsie :: Disabled , true => Ctsie :: Enabled , } } # [doc = "CTS interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ctsie :: Disabled } # [doc = "CTS interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ctsie :: Enabled } } # [doc = "Field `CTSIE` writer - CTS interrupt enable"] pub type CtsieW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctsie > ; impl < 'a , REG > CtsieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CTS interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Disabled) } # [doc = "CTS interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Enabled) } } # [doc = "One sample bit method enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Onebit { # [doc = "0: Three sample bit method"] Sample3 = 0 , # [doc = "1: One sample bit method"] Sample1 = 1 , } impl From < Onebit > for bool { # [inline (always)] fn from (variant : Onebit) -> Self { variant as u8 != 0 } } # [doc = "Field `ONEBIT` reader - One sample bit method enable"] pub type OnebitR = crate :: BitReader < Onebit > ; impl OnebitR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Onebit { match self . bits { false => Onebit :: Sample3 , true => Onebit :: Sample1 , } } # [doc = "Three sample bit method"] # [inline (always)] pub fn is_sample3 (& self) -> bool { * self == Onebit :: Sample3 } # [doc = "One sample bit method"] # [inline (always)] pub fn is_sample1 (& self) -> bool { * self == Onebit :: Sample1 } } # [doc = "Field `ONEBIT` writer - One sample bit method enable"] pub type OnebitW < 'a , REG > = crate :: BitWriter < 'a , REG , Onebit > ; impl < 'a , REG > OnebitW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Three sample bit method"] # [inline (always)] pub fn sample3 (self) -> & 'a mut crate :: W < REG > { self . variant (Onebit :: Sample3) } # [doc = "One sample bit method"] # [inline (always)] pub fn sample1 (self) -> & 'a mut crate :: W < REG > { self . variant (Onebit :: Sample1) } } impl R { # [doc = "Bit 0 - Error interrupt enable"] # [inline (always)] pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - IrDA mode enable"] # [inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - IrDA low-power"] # [inline (always)] pub fn irlp (& self) -> IrlpR { IrlpR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Half-duplex selection"] # [inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Smartcard NACK enable"] # [inline (always)] pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Smartcard mode enable"] # [inline (always)] pub fn scen (& self) -> ScenR { ScenR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DMA enable receiver"] # [inline (always)] pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DMA enable transmitter"] # [inline (always)] pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - RTS enable"] # [inline (always)] pub fn rtse (& self) -> RtseR { RtseR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - CTS enable"] # [inline (always)] pub fn ctse (& self) -> CtseR { CtseR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - CTS interrupt enable"] # [inline (always)] pub fn ctsie (& self) -> CtsieR { CtsieR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - One sample bit method enable"] # [inline (always)] pub fn onebit (& self) -> OnebitR { OnebitR :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - Error interrupt enable"] # [inline (always)] pub fn eie (& mut self) -> EieW < Cr3Spec > { EieW :: new (self , 0) } # [doc = "Bit 1 - IrDA mode enable"] # [inline (always)] pub fn iren (& mut self) -> IrenW < Cr3Spec > { IrenW :: new (self , 1) } # [doc = "Bit 2 - IrDA low-power"] # [inline (always)] pub fn irlp (& mut self) -> IrlpW < Cr3Spec > { IrlpW :: new (self , 2) } # [doc = "Bit 3 - Half-duplex selection"] # [inline (always)] pub fn hdsel (& mut self) -> HdselW < Cr3Spec > { HdselW :: new (self , 3) } # [doc = "Bit 4 - Smartcard NACK enable"] # [inline (always)] pub fn nack (& mut self) -> NackW < Cr3Spec > { NackW :: new (self , 4) } # [doc = "Bit 5 - Smartcard mode enable"] # [inline (always)] pub fn scen (& mut self) -> ScenW < Cr3Spec > { ScenW :: new (self , 5) } # [doc = "Bit 6 - DMA enable receiver"] # [inline (always)] pub fn dmar (& mut self) -> DmarW < Cr3Spec > { DmarW :: new (self , 6) } # [doc = "Bit 7 - DMA enable transmitter"] # [inline (always)] pub fn dmat (& mut self) -> DmatW < Cr3Spec > { DmatW :: new (self , 7) } # [doc = "Bit 8 - RTS enable"] # [inline (always)] pub fn rtse (& mut self) -> RtseW < Cr3Spec > { RtseW :: new (self , 8) } # [doc = "Bit 9 - CTS enable"] # [inline (always)] pub fn ctse (& mut self) -> CtseW < Cr3Spec > { CtseW :: new (self , 9) } # [doc = "Bit 10 - CTS interrupt enable"] # [inline (always)] pub fn ctsie (& mut self) -> CtsieW < Cr3Spec > { CtsieW :: new (self , 10) } # [doc = "Bit 11 - One sample bit method enable"] # [inline (always)] pub fn onebit (& mut self) -> OnebitW < Cr3Spec > { OnebitW :: new (self , 11) } } # [doc = "Control register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { } # [doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { }
# [doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ; # [doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ; # [doc = "A/D Converter ON / OFF\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Adon { # [doc = "0: Disable ADC conversion and go to power down mode"] Disabled = 0 , # [doc = "1: Enable ADC"] Enabled = 1 , } impl From < Adon > for bool { # [inline (always)] fn from (variant : Adon) -> Self { variant as u8 != 0 } } # [doc = "Field `ADON` reader - A/D Converter ON / OFF"] pub type AdonR = crate :: BitReader < Adon > ; impl AdonR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Adon { match self . bits { false => Adon :: Disabled , true => Adon :: Enabled , } } # [doc = "Disable ADC conversion and go to power down mode"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Adon :: Disabled } # [doc = "Enable ADC"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Adon :: Enabled } } # [doc = "Field `ADON` writer - A/D Converter ON / OFF"] pub type AdonW < 'a , REG > = crate :: BitWriter < 'a , REG , Adon > ; impl < 'a , REG > AdonW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disable ADC conversion and go to power down mode"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Adon :: Disabled) } # [doc = "Enable ADC"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Adon :: Enabled) } } # [doc = "Continuous conversion\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cont { # [doc = "0: Single conversion mode"] Single = 0 , # [doc = "1: Continuous conversion mode"] Continuous = 1 , } impl From < Cont > for bool { # [inline (always)] fn from (variant : Cont) -> Self { variant as u8 != 0 } } # [doc = "Field `CONT` reader - Continuous conversion"] pub type ContR = crate :: BitReader < Cont > ; impl ContR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cont { match self . bits { false => Cont :: Single , true => Cont :: Continuous , } } # [doc = "Single conversion mode"] # [inline (always)] pub fn is_single (& self) -> bool { * self == Cont :: Single } # [doc = "Continuous conversion mode"] # [inline (always)] pub fn is_continuous (& self) -> bool { * self == Cont :: Continuous } } # [doc = "Field `CONT` writer - Continuous conversion"] pub type ContW < 'a , REG > = crate :: BitWriter < 'a , REG , Cont > ; impl < 'a , REG > ContW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Single conversion mode"] # [inline (always)] pub fn single (self) -> & 'a mut crate :: W < REG > { self . variant (Cont :: Single) } # [doc = "Continuous conversion mode"] # [inline (always)] pub fn continuous (self) -> & 'a mut crate :: W < REG > { self . variant (Cont :: Continuous) } } # [doc = "Direct memory access mode (for single ADC mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dma { # [doc = "0: DMA mode disabled"] Disabled = 0 , # [doc = "1: DMA mode enabled"] Enabled = 1 , } impl From < Dma > for bool { # [inline (always)] fn from (variant : Dma) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - Direct memory access mode (for single ADC mode)"] pub type DmaR = crate :: BitReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dma { match self . bits { false => Dma :: Disabled , true => Dma :: Enabled , } } # [doc = "DMA mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dma :: Disabled } # [doc = "DMA mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dma :: Enabled } } # [doc = "Field `DMA` writer - Direct memory access mode (for single ADC mode)"] pub type DmaW < 'a , REG > = crate :: BitWriter < 'a , REG , Dma > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DMA mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Disabled) } # [doc = "DMA mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Enabled) } } # [doc = "DMA disable selection (for single ADC mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dds { # [doc = "0: No new DMA request is issued after the last transfer"] Single = 0 , # [doc = "1: DMA requests are issued as long as data are converted and DMA=1"] Continuous = 1 , } impl From < Dds > for bool { # [inline (always)] fn from (variant : Dds) -> Self { variant as u8 != 0 } } # [doc = "Field `DDS` reader - DMA disable selection (for single ADC mode)"] pub type DdsR = crate :: BitReader < Dds > ; impl DdsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dds { match self . bits { false => Dds :: Single , true => Dds :: Continuous , } } # [doc = "No new DMA request is issued after the last transfer"] # [inline (always)] pub fn is_single (& self) -> bool { * self == Dds :: Single } # [doc = "DMA requests are issued as long as data are converted and DMA=1"] # [inline (always)] pub fn is_continuous (& self) -> bool { * self == Dds :: Continuous } } # [doc = "Field `DDS` writer - DMA disable selection (for single ADC mode)"] pub type DdsW < 'a , REG > = crate :: BitWriter < 'a , REG , Dds > ; impl < 'a , REG > DdsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No new DMA request is issued after the last transfer"] # [inline (always)] pub fn single (self) -> & 'a mut crate :: W < REG > { self . variant (Dds :: Single) } # [doc = "DMA requests are issued as long as data are converted and DMA=1"] # [inline (always)] pub fn continuous (self) -> & 'a mut crate :: W < REG > { self . variant (Dds :: Continuous) } } # [doc = "End of conversion selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eocs { # [doc = "0: The EOC bit is set at the end of each sequence of regular conversions"] EachSequence = 0 , # [doc = "1: The EOC bit is set at the end of each regular conversion"] EachConversion = 1 , } impl From < Eocs > for bool { # [inline (always)] fn from (variant : Eocs) -> Self { variant as u8 != 0 } } # [doc = "Field `EOCS` reader - End of conversion selection"] pub type EocsR = crate :: BitReader < Eocs > ; impl EocsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eocs { match self . bits { false => Eocs :: EachSequence , true => Eocs :: EachConversion , } } # [doc = "The EOC bit is set at the end of each sequence of regular conversions"] # [inline (always)] pub fn is_each_sequence (& self) -> bool { * self == Eocs :: EachSequence } # [doc = "The EOC bit is set at the end of each regular conversion"] # [inline (always)] pub fn is_each_conversion (& self) -> bool { * self == Eocs :: EachConversion } } # [doc = "Field `EOCS` writer - End of conversion selection"] pub type EocsW < 'a , REG > = crate :: BitWriter < 'a , REG , Eocs > ; impl < 'a , REG > EocsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The EOC bit is set at the end of each sequence of regular conversions"] # [inline (always)] pub fn each_sequence (self) -> & 'a mut crate :: W < REG > { self . variant (Eocs :: EachSequence) } # [doc = "The EOC bit is set at the end of each regular conversion"] # [inline (always)] pub fn each_conversion (self) -> & 'a mut crate :: W < REG > { self . variant (Eocs :: EachConversion) } } # [doc = "Data alignment\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Align { # [doc = "0: Right alignment"] Right = 0 , # [doc = "1: Left alignment"] Left = 1 , } impl From < Align > for bool { # [inline (always)] fn from (variant : Align) -> Self { variant as u8 != 0 } } # [doc = "Field `ALIGN` reader - Data alignment"] pub type AlignR = crate :: BitReader < Align > ; impl AlignR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Align { match self . bits { false => Align :: Right , true => Align :: Left , } } # [doc = "Right alignment"] # [inline (always)] pub fn is_right (& self) -> bool { * self == Align :: Right } # [doc = "Left alignment"] # [inline (always)] pub fn is_left (& self) -> bool { * self == Align :: Left } } # [doc = "Field `ALIGN` writer - Data alignment"] pub type AlignW < 'a , REG > = crate :: BitWriter < 'a , REG , Align > ; impl < 'a , REG > AlignW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Right alignment"] # [inline (always)] pub fn right (self) -> & 'a mut crate :: W < REG > { self . variant (Align :: Right) } # [doc = "Left alignment"] # [inline (always)] pub fn left (self) -> & 'a mut crate :: W < REG > { self . variant (Align :: Left) } } # [doc = "External event select for injected group\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Jextsel { # [doc = "0: Timer 1 CC4 event"] Tim1cc4 = 0 , # [doc = "1: Timer 1 TRGO event"] Tim1trgo = 1 , # [doc = "2: Timer 2 CC1 event"] Tim2cc1 = 2 , # [doc = "3: Timer 2 TRGO event"] Tim2trgo = 3 , # [doc = "4: Timer 3 CC2 event"] Tim3cc2 = 4 , # [doc = "5: Timer 3 CC4 event"] Tim3cc4 = 5 , # [doc = "6: Timer 4 CC1 event"] Tim4cc1 = 6 , # [doc = "7: Timer 4 CC2 event"] Tim4cc2 = 7 , # [doc = "8: Timer 4 CC3 event"] Tim4cc3 = 8 , # [doc = "9: Timer 4 TRGO event"] Tim4trgo = 9 , # [doc = "10: Timer 5 CC4 event"] Tim5cc4 = 10 , # [doc = "11: Timer 5 TRGO event"] Tim5trgo = 11 , # [doc = "12: Timer 8 CC2 event"] Tim8cc2 = 12 , # [doc = "13: Timer 8 CC3 event"] Tim8cc3 = 13 , # [doc = "14: Timer 8 CC4 event"] Tim8cc4 = 14 , # [doc = "15: EXTI line 15"] Exti15 = 15 , } impl From < Jextsel > for u8 { # [inline (always)] fn from (variant : Jextsel) -> Self { variant as _ } } impl crate :: FieldSpec for Jextsel { type Ux = u8 ; } impl crate :: IsEnum for Jextsel { } # [doc = "Field `JEXTSEL` reader - External event select for injected group"] pub type JextselR = crate :: FieldReader < Jextsel > ; impl JextselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jextsel { match self . bits { 0 => Jextsel :: Tim1cc4 , 1 => Jextsel :: Tim1trgo , 2 => Jextsel :: Tim2cc1 , 3 => Jextsel :: Tim2trgo , 4 => Jextsel :: Tim3cc2 , 5 => Jextsel :: Tim3cc4 , 6 => Jextsel :: Tim4cc1 , 7 => Jextsel :: Tim4cc2 , 8 => Jextsel :: Tim4cc3 , 9 => Jextsel :: Tim4trgo , 10 => Jextsel :: Tim5cc4 , 11 => Jextsel :: Tim5trgo , 12 => Jextsel :: Tim8cc2 , 13 => Jextsel :: Tim8cc3 , 14 => Jextsel :: Tim8cc4 , 15 => Jextsel :: Exti15 , _ => unreachable ! () , } } # [doc = "Timer 1 CC4 event"] # [inline (always)] pub fn is_tim1cc4 (& self) -> bool { * self == Jextsel :: Tim1cc4 } # [doc = "Timer 1 TRGO event"] # [inline (always)] pub fn is_tim1trgo (& self) -> bool { * self == Jextsel :: Tim1trgo } # [doc = "Timer 2 CC1 event"] # [inline (always)] pub fn is_tim2cc1 (& self) -> bool { * self == Jextsel :: Tim2cc1 } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn is_tim2trgo (& self) -> bool { * self == Jextsel :: Tim2trgo } # [doc = "Timer 3 CC2 event"] # [inline (always)] pub fn is_tim3cc2 (& self) -> bool { * self == Jextsel :: Tim3cc2 } # [doc = "Timer 3 CC4 event"] # [inline (always)] pub fn is_tim3cc4 (& self) -> bool { * self == Jextsel :: Tim3cc4 } # [doc = "Timer 4 CC1 event"] # [inline (always)] pub fn is_tim4cc1 (& self) -> bool { * self == Jextsel :: Tim4cc1 } # [doc = "Timer 4 CC2 event"] # [inline (always)] pub fn is_tim4cc2 (& self) -> bool { * self == Jextsel :: Tim4cc2 } # [doc = "Timer 4 CC3 event"] # [inline (always)] pub fn is_tim4cc3 (& self) -> bool { * self == Jextsel :: Tim4cc3 } # [doc = "Timer 4 TRGO event"] # [inline (always)] pub fn is_tim4trgo (& self) -> bool { * self == Jextsel :: Tim4trgo } # [doc = "Timer 5 CC4 event"] # [inline (always)] pub fn is_tim5cc4 (& self) -> bool { * self == Jextsel :: Tim5cc4 } # [doc = "Timer 5 TRGO event"] # [inline (always)] pub fn is_tim5trgo (& self) -> bool { * self == Jextsel :: Tim5trgo } # [doc = "Timer 8 CC2 event"] # [inline (always)] pub fn is_tim8cc2 (& self) -> bool { * self == Jextsel :: Tim8cc2 } # [doc = "Timer 8 CC3 event"] # [inline (always)] pub fn is_tim8cc3 (& self) -> bool { * self == Jextsel :: Tim8cc3 } # [doc = "Timer 8 CC4 event"] # [inline (always)] pub fn is_tim8cc4 (& self) -> bool { * self == Jextsel :: Tim8cc4 } # [doc = "EXTI line 15"] # [inline (always)] pub fn is_exti15 (& self) -> bool { * self == Jextsel :: Exti15 } } # [doc = "Field `JEXTSEL` writer - External event select for injected group"] pub type JextselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Jextsel , crate :: Safe > ; impl < 'a , REG > JextselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Timer 1 CC4 event"] # [inline (always)] pub fn tim1cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim1cc4) } # [doc = "Timer 1 TRGO event"] # [inline (always)] pub fn tim1trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim1trgo) } # [doc = "Timer 2 CC1 event"] # [inline (always)] pub fn tim2cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim2cc1) } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn tim2trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim2trgo) } # [doc = "Timer 3 CC2 event"] # [inline (always)] pub fn tim3cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim3cc2) } # [doc = "Timer 3 CC4 event"] # [inline (always)] pub fn tim3cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim3cc4) } # [doc = "Timer 4 CC1 event"] # [inline (always)] pub fn tim4cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim4cc1) } # [doc = "Timer 4 CC2 event"] # [inline (always)] pub fn tim4cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim4cc2) } # [doc = "Timer 4 CC3 event"] # [inline (always)] pub fn tim4cc3 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim4cc3) } # [doc = "Timer 4 TRGO event"] # [inline (always)] pub fn tim4trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim4trgo) } # [doc = "Timer 5 CC4 event"] # [inline (always)] pub fn tim5cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim5cc4) } # [doc = "Timer 5 TRGO event"] # [inline (always)] pub fn tim5trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim5trgo) } # [doc = "Timer 8 CC2 event"] # [inline (always)] pub fn tim8cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim8cc2) } # [doc = "Timer 8 CC3 event"] # [inline (always)] pub fn tim8cc3 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim8cc3) } # [doc = "Timer 8 CC4 event"] # [inline (always)] pub fn tim8cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Tim8cc4) } # [doc = "EXTI line 15"] # [inline (always)] pub fn exti15 (self) -> & 'a mut crate :: W < REG > { self . variant (Jextsel :: Exti15) } } # [doc = "External trigger enable for injected channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Jexten { # [doc = "0: Trigger detection disabled"] Disabled = 0 , # [doc = "1: Trigger detection on the rising edge"] RisingEdge = 1 , # [doc = "2: Trigger detection on the falling edge"] FallingEdge = 2 , # [doc = "3: Trigger detection on both the rising and falling edges"] BothEdges = 3 , } impl From < Jexten > for u8 { # [inline (always)] fn from (variant : Jexten) -> Self { variant as _ } } impl crate :: FieldSpec for Jexten { type Ux = u8 ; } impl crate :: IsEnum for Jexten { } # [doc = "Field `JEXTEN` reader - External trigger enable for injected channels"] pub type JextenR = crate :: FieldReader < Jexten > ; impl JextenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jexten { match self . bits { 0 => Jexten :: Disabled , 1 => Jexten :: RisingEdge , 2 => Jexten :: FallingEdge , 3 => Jexten :: BothEdges , _ => unreachable ! () , } } # [doc = "Trigger detection disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jexten :: Disabled } # [doc = "Trigger detection on the rising edge"] # [inline (always)] pub fn is_rising_edge (& self) -> bool { * self == Jexten :: RisingEdge } # [doc = "Trigger detection on the falling edge"] # [inline (always)] pub fn is_falling_edge (& self) -> bool { * self == Jexten :: FallingEdge } # [doc = "Trigger detection on both the rising and falling edges"] # [inline (always)] pub fn is_both_edges (& self) -> bool { * self == Jexten :: BothEdges } } # [doc = "Field `JEXTEN` writer - External trigger enable for injected channels"] pub type JextenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Jexten , crate :: Safe > ; impl < 'a , REG > JextenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Trigger detection disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jexten :: Disabled) } # [doc = "Trigger detection on the rising edge"] # [inline (always)] pub fn rising_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Jexten :: RisingEdge) } # [doc = "Trigger detection on the falling edge"] # [inline (always)] pub fn falling_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Jexten :: FallingEdge) } # [doc = "Trigger detection on both the rising and falling edges"] # [inline (always)] pub fn both_edges (self) -> & 'a mut crate :: W < REG > { self . variant (Jexten :: BothEdges) } } # [doc = "Start conversion of injected channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jswstartw { # [doc = "1: Starts conversion of injected channels"] Start = 1 , } impl From < Jswstartw > for bool { # [inline (always)] fn from (variant : Jswstartw) -> Self { variant as u8 != 0 } } # [doc = "Field `JSWSTART` reader - Start conversion of injected channels"] pub type JswstartR = crate :: BitReader < Jswstartw > ; impl JswstartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Jswstartw > { match self . bits { true => Some (Jswstartw :: Start) , _ => None , } } # [doc = "Starts conversion of injected channels"] # [inline (always)] pub fn is_start (& self) -> bool { * self == Jswstartw :: Start } } # [doc = "Field `JSWSTART` writer - Start conversion of injected channels"] pub type JswstartW < 'a , REG > = crate :: BitWriter < 'a , REG , Jswstartw > ; impl < 'a , REG > JswstartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Starts conversion of injected channels"] # [inline (always)] pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Jswstartw :: Start) } } # [doc = "External event select for regular group\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Extsel { # [doc = "0: Timer 1 CC1 event"] Tim1cc1 = 0 , # [doc = "1: Timer 1 CC2 event"] Tim1cc2 = 1 , # [doc = "2: Timer 1 CC3 event"] Tim1cc3 = 2 , # [doc = "3: Timer 2 CC2 event"] Tim2cc2 = 3 , # [doc = "4: Timer 2 CC3 event"] Tim2cc3 = 4 , # [doc = "5: Timer 2 CC4 event"] Tim2cc4 = 5 , # [doc = "6: Timer 2 TRGO event"] Tim2trgo = 6 , # [doc = "7: Timer 3 CC1 event"] Tim3cc1 = 7 , # [doc = "8: Timer 3 TRGO event"] Tim3trgo = 8 , # [doc = "9: Timer 4 CC4 event"] Tim4cc4 = 9 , # [doc = "10: Timer 5 CC1 event"] Tim5cc1 = 10 , # [doc = "11: Timer 5 CC2 event"] Tim5cc2 = 11 , # [doc = "12: Timer 5 CC3 event"] Tim5cc3 = 12 , # [doc = "13: Timer 8 CC1 event"] Tim8cc1 = 13 , # [doc = "14: Timer 8 TRGO event"] Tim8trgo = 14 , # [doc = "15: EXTI line 11"] Exti11 = 15 , } impl From < Extsel > for u8 { # [inline (always)] fn from (variant : Extsel) -> Self { variant as _ } } impl crate :: FieldSpec for Extsel { type Ux = u8 ; } impl crate :: IsEnum for Extsel { } # [doc = "Field `EXTSEL` reader - External event select for regular group"] pub type ExtselR = crate :: FieldReader < Extsel > ; impl ExtselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Extsel { match self . bits { 0 => Extsel :: Tim1cc1 , 1 => Extsel :: Tim1cc2 , 2 => Extsel :: Tim1cc3 , 3 => Extsel :: Tim2cc2 , 4 => Extsel :: Tim2cc3 , 5 => Extsel :: Tim2cc4 , 6 => Extsel :: Tim2trgo , 7 => Extsel :: Tim3cc1 , 8 => Extsel :: Tim3trgo , 9 => Extsel :: Tim4cc4 , 10 => Extsel :: Tim5cc1 , 11 => Extsel :: Tim5cc2 , 12 => Extsel :: Tim5cc3 , 13 => Extsel :: Tim8cc1 , 14 => Extsel :: Tim8trgo , 15 => Extsel :: Exti11 , _ => unreachable ! () , } } # [doc = "Timer 1 CC1 event"] # [inline (always)] pub fn is_tim1cc1 (& self) -> bool { * self == Extsel :: Tim1cc1 } # [doc = "Timer 1 CC2 event"] # [inline (always)] pub fn is_tim1cc2 (& self) -> bool { * self == Extsel :: Tim1cc2 } # [doc = "Timer 1 CC3 event"] # [inline (always)] pub fn is_tim1cc3 (& self) -> bool { * self == Extsel :: Tim1cc3 } # [doc = "Timer 2 CC2 event"] # [inline (always)] pub fn is_tim2cc2 (& self) -> bool { * self == Extsel :: Tim2cc2 } # [doc = "Timer 2 CC3 event"] # [inline (always)] pub fn is_tim2cc3 (& self) -> bool { * self == Extsel :: Tim2cc3 } # [doc = "Timer 2 CC4 event"] # [inline (always)] pub fn is_tim2cc4 (& self) -> bool { * self == Extsel :: Tim2cc4 } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn is_tim2trgo (& self) -> bool { * self == Extsel :: Tim2trgo } # [doc = "Timer 3 CC1 event"] # [inline (always)] pub fn is_tim3cc1 (& self) -> bool { * self == Extsel :: Tim3cc1 } # [doc = "Timer 3 TRGO event"] # [inline (always)] pub fn is_tim3trgo (& self) -> bool { * self == Extsel :: Tim3trgo } # [doc = "Timer 4 CC4 event"] # [inline (always)] pub fn is_tim4cc4 (& self) -> bool { * self == Extsel :: Tim4cc4 } # [doc = "Timer 5 CC1 event"] # [inline (always)] pub fn is_tim5cc1 (& self) -> bool { * self == Extsel :: Tim5cc1 } # [doc = "Timer 5 CC2 event"] # [inline (always)] pub fn is_tim5cc2 (& self) -> bool { * self == Extsel :: Tim5cc2 } # [doc = "Timer 5 CC3 event"] # [inline (always)] pub fn is_tim5cc3 (& self) -> bool { * self == Extsel :: Tim5cc3 } # [doc = "Timer 8 CC1 event"] # [inline (always)] pub fn is_tim8cc1 (& self) -> bool { * self == Extsel :: Tim8cc1 } # [doc = "Timer 8 TRGO event"] # [inline (always)] pub fn is_tim8trgo (& self) -> bool { * self == Extsel :: Tim8trgo } # [doc = "EXTI line 11"] # [inline (always)] pub fn is_exti11 (& self) -> bool { * self == Extsel :: Exti11 } } # [doc = "Field `EXTSEL` writer - External event select for regular group"] pub type ExtselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Extsel , crate :: Safe > ; impl < 'a , REG > ExtselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Timer 1 CC1 event"] # [inline (always)] pub fn tim1cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim1cc1) } # [doc = "Timer 1 CC2 event"] # [inline (always)] pub fn tim1cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim1cc2) } # [doc = "Timer 1 CC3 event"] # [inline (always)] pub fn tim1cc3 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim1cc3) } # [doc = "Timer 2 CC2 event"] # [inline (always)] pub fn tim2cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim2cc2) } # [doc = "Timer 2 CC3 event"] # [inline (always)] pub fn tim2cc3 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim2cc3) } # [doc = "Timer 2 CC4 event"] # [inline (always)] pub fn tim2cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim2cc4) } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn tim2trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim2trgo) } # [doc = "Timer 3 CC1 event"] # [inline (always)] pub fn tim3cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim3cc1) } # [doc = "Timer 3 TRGO event"] # [inline (always)] pub fn tim3trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim3trgo) } # [doc = "Timer 4 CC4 event"] # [inline (always)] pub fn tim4cc4 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim4cc4) } # [doc = "Timer 5 CC1 event"] # [inline (always)] pub fn tim5cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim5cc1) } # [doc = "Timer 5 CC2 event"] # [inline (always)] pub fn tim5cc2 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim5cc2) } # [doc = "Timer 5 CC3 event"] # [inline (always)] pub fn tim5cc3 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim5cc3) } # [doc = "Timer 8 CC1 event"] # [inline (always)] pub fn tim8cc1 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim8cc1) } # [doc = "Timer 8 TRGO event"] # [inline (always)] pub fn tim8trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Tim8trgo) } # [doc = "EXTI line 11"] # [inline (always)] pub fn exti11 (self) -> & 'a mut crate :: W < REG > { self . variant (Extsel :: Exti11) } } # [doc = "External trigger enable for regular channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Exten { # [doc = "0: Trigger detection disabled"] Disabled = 0 , # [doc = "1: Trigger detection on the rising edge"] RisingEdge = 1 , # [doc = "2: Trigger detection on the falling edge"] FallingEdge = 2 , # [doc = "3: Trigger detection on both the rising and falling edges"] BothEdges = 3 , } impl From < Exten > for u8 { # [inline (always)] fn from (variant : Exten) -> Self { variant as _ } } impl crate :: FieldSpec for Exten { type Ux = u8 ; } impl crate :: IsEnum for Exten { } # [doc = "Field `EXTEN` reader - External trigger enable for regular channels"] pub type ExtenR = crate :: FieldReader < Exten > ; impl ExtenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Exten { match self . bits { 0 => Exten :: Disabled , 1 => Exten :: RisingEdge , 2 => Exten :: FallingEdge , 3 => Exten :: BothEdges , _ => unreachable ! () , } } # [doc = "Trigger detection disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Exten :: Disabled } # [doc = "Trigger detection on the rising edge"] # [inline (always)] pub fn is_rising_edge (& self) -> bool { * self == Exten :: RisingEdge } # [doc = "Trigger detection on the falling edge"] # [inline (always)] pub fn is_falling_edge (& self) -> bool { * self == Exten :: FallingEdge } # [doc = "Trigger detection on both the rising and falling edges"] # [inline (always)] pub fn is_both_edges (& self) -> bool { * self == Exten :: BothEdges } } # [doc = "Field `EXTEN` writer - External trigger enable for regular channels"] pub type ExtenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Exten , crate :: Safe > ; impl < 'a , REG > ExtenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Trigger detection disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: Disabled) } # [doc = "Trigger detection on the rising edge"] # [inline (always)] pub fn rising_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: RisingEdge) } # [doc = "Trigger detection on the falling edge"] # [inline (always)] pub fn falling_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: FallingEdge) } # [doc = "Trigger detection on both the rising and falling edges"] # [inline (always)] pub fn both_edges (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: BothEdges) } } # [doc = "Start conversion of regular channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Swstartw { # [doc = "1: Starts conversion of regular channels"] Start = 1 , } impl From < Swstartw > for bool { # [inline (always)] fn from (variant : Swstartw) -> Self { variant as u8 != 0 } } # [doc = "Field `SWSTART` reader - Start conversion of regular channels"] pub type SwstartR = crate :: BitReader < Swstartw > ; impl SwstartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Swstartw > { match self . bits { true => Some (Swstartw :: Start) , _ => None , } } # [doc = "Starts conversion of regular channels"] # [inline (always)] pub fn is_start (& self) -> bool { * self == Swstartw :: Start } } # [doc = "Field `SWSTART` writer - Start conversion of regular channels"] pub type SwstartW < 'a , REG > = crate :: BitWriter < 'a , REG , Swstartw > ; impl < 'a , REG > SwstartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Starts conversion of regular channels"] # [inline (always)] pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Swstartw :: Start) } } impl R { # [doc = "Bit 0 - A/D Converter ON / OFF"] # [inline (always)] pub fn adon (& self) -> AdonR { AdonR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Continuous conversion"] # [inline (always)] pub fn cont (& self) -> ContR { ContR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 8 - Direct memory access mode (for single ADC mode)"] # [inline (always)] pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - DMA disable selection (for single ADC mode)"] # [inline (always)] pub fn dds (& self) -> DdsR { DdsR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - End of conversion selection"] # [inline (always)] pub fn eocs (& self) -> EocsR { EocsR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Data alignment"] # [inline (always)] pub fn align (& self) -> AlignR { AlignR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 16:19 - External event select for injected group"] # [inline (always)] pub fn jextsel (& self) -> JextselR { JextselR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:21 - External trigger enable for injected channels"] # [inline (always)] pub fn jexten (& self) -> JextenR { JextenR :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bit 22 - Start conversion of injected channels"] # [inline (always)] pub fn jswstart (& self) -> JswstartR { JswstartR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bits 24:27 - External event select for regular group"] # [inline (always)] pub fn extsel (& self) -> ExtselR { ExtselR :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:29 - External trigger enable for regular channels"] # [inline (always)] pub fn exten (& self) -> ExtenR { ExtenR :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bit 30 - Start conversion of regular channels"] # [inline (always)] pub fn swstart (& self) -> SwstartR { SwstartR :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 0 - A/D Converter ON / OFF"] # [inline (always)] pub fn adon (& mut self) -> AdonW < Cr2Spec > { AdonW :: new (self , 0) } # [doc = "Bit 1 - Continuous conversion"] # [inline (always)] pub fn cont (& mut self) -> ContW < Cr2Spec > { ContW :: new (self , 1) } # [doc = "Bit 8 - Direct memory access mode (for single ADC mode)"] # [inline (always)] pub fn dma (& mut self) -> DmaW < Cr2Spec > { DmaW :: new (self , 8) } # [doc = "Bit 9 - DMA disable selection (for single ADC mode)"] # [inline (always)] pub fn dds (& mut self) -> DdsW < Cr2Spec > { DdsW :: new (self , 9) } # [doc = "Bit 10 - End of conversion selection"] # [inline (always)] pub fn eocs (& mut self) -> EocsW < Cr2Spec > { EocsW :: new (self , 10) } # [doc = "Bit 11 - Data alignment"] # [inline (always)] pub fn align (& mut self) -> AlignW < Cr2Spec > { AlignW :: new (self , 11) } # [doc = "Bits 16:19 - External event select for injected group"] # [inline (always)] pub fn jextsel (& mut self) -> JextselW < Cr2Spec > { JextselW :: new (self , 16) } # [doc = "Bits 20:21 - External trigger enable for injected channels"] # [inline (always)] pub fn jexten (& mut self) -> JextenW < Cr2Spec > { JextenW :: new (self , 20) } # [doc = "Bit 22 - Start conversion of injected channels"] # [inline (always)] pub fn jswstart (& mut self) -> JswstartW < Cr2Spec > { JswstartW :: new (self , 22) } # [doc = "Bits 24:27 - External event select for regular group"] # [inline (always)] pub fn extsel (& mut self) -> ExtselW < Cr2Spec > { ExtselW :: new (self , 24) } # [doc = "Bits 28:29 - External trigger enable for regular channels"] # [inline (always)] pub fn exten (& mut self) -> ExtenW < Cr2Spec > { ExtenW :: new (self , 28) } # [doc = "Bit 30 - Start conversion of regular channels"] # [inline (always)] pub fn swstart (& mut self) -> SwstartW < Cr2Spec > { SwstartW :: new (self , 30) } } # [doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { } # [doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { }
# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Field `AWDCH` reader - Analog watchdog channel select bits"] pub type AwdchR = crate :: FieldReader ; # [doc = "Field `AWDCH` writer - Analog watchdog channel select bits"] pub type AwdchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; # [doc = "Interrupt enable for EOC\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Eocie { # [doc = "0: EOC interrupt disabled"] Disabled = 0 , # [doc = "1: EOC interrupt enabled"] Enabled = 1 , } impl From < Eocie > for bool { # [inline (always)] fn from (variant : Eocie) -> Self { variant as u8 != 0 } } # [doc = "Field `EOCIE` reader - Interrupt enable for EOC"] pub type EocieR = crate :: BitReader < Eocie > ; impl EocieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Eocie { match self . bits { false => Eocie :: Disabled , true => Eocie :: Enabled , } } # [doc = "EOC interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Eocie :: Disabled } # [doc = "EOC interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Eocie :: Enabled } } # [doc = "Field `EOCIE` writer - Interrupt enable for EOC"] pub type EocieW < 'a , REG > = crate :: BitWriter < 'a , REG , Eocie > ; impl < 'a , REG > EocieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "EOC interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Eocie :: Disabled) } # [doc = "EOC interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Eocie :: Enabled) } } # [doc = "Analog watchdog interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Awdie { # [doc = "0: Analogue watchdog interrupt disabled"] Disabled = 0 , # [doc = "1: Analogue watchdog interrupt enabled"] Enabled = 1 , } impl From < Awdie > for bool { # [inline (always)] fn from (variant : Awdie) -> Self { variant as u8 != 0 } } # [doc = "Field `AWDIE` reader - Analog watchdog interrupt enable"] pub type AwdieR = crate :: BitReader < Awdie > ; impl AwdieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Awdie { match self . bits { false => Awdie :: Disabled , true => Awdie :: Enabled , } } # [doc = "Analogue watchdog interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Awdie :: Disabled } # [doc = "Analogue watchdog interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Awdie :: Enabled } } # [doc = "Field `AWDIE` writer - Analog watchdog interrupt enable"] pub type AwdieW < 'a , REG > = crate :: BitWriter < 'a , REG , Awdie > ; impl < 'a , REG > AwdieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Analogue watchdog interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Awdie :: Disabled) } # [doc = "Analogue watchdog interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Awdie :: Enabled) } } # [doc = "Interrupt enable for injected channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jeocie { # [doc = "0: JEOC interrupt disabled"] Disabled = 0 , # [doc = "1: JEOC interrupt enabled"] Enabled = 1 , } impl From < Jeocie > for bool { # [inline (always)] fn from (variant : Jeocie) -> Self { variant as u8 != 0 } } # [doc = "Field `JEOCIE` reader - Interrupt enable for injected channels"] pub type JeocieR = crate :: BitReader < Jeocie > ; impl JeocieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jeocie { match self . bits { false => Jeocie :: Disabled , true => Jeocie :: Enabled , } } # [doc = "JEOC interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jeocie :: Disabled } # [doc = "JEOC interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Jeocie :: Enabled } } # [doc = "Field `JEOCIE` writer - Interrupt enable for injected channels"] pub type JeocieW < 'a , REG > = crate :: BitWriter < 'a , REG , Jeocie > ; impl < 'a , REG > JeocieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "JEOC interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jeocie :: Disabled) } # [doc = "JEOC interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jeocie :: Enabled) } } # [doc = "Scan mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Scan { # [doc = "0: Scan mode disabled"] Disabled = 0 , # [doc = "1: Scan mode enabled"] Enabled = 1 , } impl From < Scan > for bool { # [inline (always)] fn from (variant : Scan) -> Self { variant as u8 != 0 } } # [doc = "Field `SCAN` reader - Scan mode"] pub type ScanR = crate :: BitReader < Scan > ; impl ScanR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Scan { match self . bits { false => Scan :: Disabled , true => Scan :: Enabled , } } # [doc = "Scan mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Scan :: Disabled } # [doc = "Scan mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Scan :: Enabled } } # [doc = "Field `SCAN` writer - Scan mode"] pub type ScanW < 'a , REG > = crate :: BitWriter < 'a , REG , Scan > ; impl < 'a , REG > ScanW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Scan mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Scan :: Disabled) } # [doc = "Scan mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Scan :: Enabled) } } # [doc = "Enable the watchdog on a single channel in scan mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Awdsgl { # [doc = "0: Analog watchdog enabled on all channels"] AllChannels = 0 , # [doc = "1: Analog watchdog enabled on a single channel"] SingleChannel = 1 , } impl From < Awdsgl > for bool { # [inline (always)] fn from (variant : Awdsgl) -> Self { variant as u8 != 0 } } # [doc = "Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode"] pub type AwdsglR = crate :: BitReader < Awdsgl > ; impl AwdsglR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Awdsgl { match self . bits { false => Awdsgl :: AllChannels , true => Awdsgl :: SingleChannel , } } # [doc = "Analog watchdog enabled on all channels"] # [inline (always)] pub fn is_all_channels (& self) -> bool { * self == Awdsgl :: AllChannels } # [doc = "Analog watchdog enabled on a single channel"] # [inline (always)] pub fn is_single_channel (& self) -> bool { * self == Awdsgl :: SingleChannel } } # [doc = "Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode"] pub type AwdsglW < 'a , REG > = crate :: BitWriter < 'a , REG , Awdsgl > ; impl < 'a , REG > AwdsglW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Analog watchdog enabled on all channels"] # [inline (always)] pub fn all_channels (self) -> & 'a mut crate :: W < REG > { self . variant (Awdsgl :: AllChannels) } # [doc = "Analog watchdog enabled on a single channel"] # [inline (always)] pub fn single_channel (self) -> & 'a mut crate :: W < REG > { self . variant (Awdsgl :: SingleChannel) } } # [doc = "Automatic injected group conversion\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jauto { # [doc = "0: Automatic injected group conversion disabled"] Disabled = 0 , # [doc = "1: Automatic injected group conversion enabled"] Enabled = 1 , } impl From < Jauto > for bool { # [inline (always)] fn from (variant : Jauto) -> Self { variant as u8 != 0 } } # [doc = "Field `JAUTO` reader - Automatic injected group conversion"] pub type JautoR = crate :: BitReader < Jauto > ; impl JautoR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jauto { match self . bits { false => Jauto :: Disabled , true => Jauto :: Enabled , } } # [doc = "Automatic injected group conversion disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jauto :: Disabled } # [doc = "Automatic injected group conversion enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Jauto :: Enabled } } # [doc = "Field `JAUTO` writer - Automatic injected group conversion"] pub type JautoW < 'a , REG > = crate :: BitWriter < 'a , REG , Jauto > ; impl < 'a , REG > JautoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Automatic injected group conversion disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jauto :: Disabled) } # [doc = "Automatic injected group conversion enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jauto :: Enabled) } } # [doc = "Discontinuous mode on regular channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Discen { # [doc = "0: Discontinuous mode on regular channels disabled"] Disabled = 0 , # [doc = "1: Discontinuous mode on regular channels enabled"] Enabled = 1 , } impl From < Discen > for bool { # [inline (always)] fn from (variant : Discen) -> Self { variant as u8 != 0 } } # [doc = "Field `DISCEN` reader - Discontinuous mode on regular channels"] pub type DiscenR = crate :: BitReader < Discen > ; impl DiscenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Discen { match self . bits { false => Discen :: Disabled , true => Discen :: Enabled , } } # [doc = "Discontinuous mode on regular channels disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Discen :: Disabled } # [doc = "Discontinuous mode on regular channels enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Discen :: Enabled } } # [doc = "Field `DISCEN` writer - Discontinuous mode on regular channels"] pub type DiscenW < 'a , REG > = crate :: BitWriter < 'a , REG , Discen > ; impl < 'a , REG > DiscenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Discontinuous mode on regular channels disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Discen :: Disabled) } # [doc = "Discontinuous mode on regular channels enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Discen :: Enabled) } } # [doc = "Discontinuous mode on injected channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jdiscen { # [doc = "0: Discontinuous mode on injected channels disabled"] Disabled = 0 , # [doc = "1: Discontinuous mode on injected channels enabled"] Enabled = 1 , } impl From < Jdiscen > for bool { # [inline (always)] fn from (variant : Jdiscen) -> Self { variant as u8 != 0 } } # [doc = "Field `JDISCEN` reader - Discontinuous mode on injected channels"] pub type JdiscenR = crate :: BitReader < Jdiscen > ; impl JdiscenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jdiscen { match self . bits { false => Jdiscen :: Disabled , true => Jdiscen :: Enabled , } } # [doc = "Discontinuous mode on injected channels disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jdiscen :: Disabled } # [doc = "Discontinuous mode on injected channels enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Jdiscen :: Enabled } } # [doc = "Field `JDISCEN` writer - Discontinuous mode on injected channels"] pub type JdiscenW < 'a , REG > = crate :: BitWriter < 'a , REG , Jdiscen > ; impl < 'a , REG > JdiscenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Discontinuous mode on injected channels disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jdiscen :: Disabled) } # [doc = "Discontinuous mode on injected channels enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jdiscen :: Enabled) } } # [doc = "Field `DISCNUM` reader - Discontinuous mode channel count"] pub type DiscnumR = crate :: FieldReader ; # [doc = "Field `DISCNUM` writer - Discontinuous mode channel count"] pub type DiscnumW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , u8 , crate :: Safe > ; # [doc = "Analog watchdog enable on injected channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jawden { # [doc = "0: Analog watchdog disabled on injected channels"] Disabled = 0 , # [doc = "1: Analog watchdog enabled on injected channels"] Enabled = 1 , } impl From < Jawden > for bool { # [inline (always)] fn from (variant : Jawden) -> Self { variant as u8 != 0 } } # [doc = "Field `JAWDEN` reader - Analog watchdog enable on injected channels"] pub type JawdenR = crate :: BitReader < Jawden > ; impl JawdenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jawden { match self . bits { false => Jawden :: Disabled , true => Jawden :: Enabled , } } # [doc = "Analog watchdog disabled on injected channels"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jawden :: Disabled } # [doc = "Analog watchdog enabled on injected channels"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Jawden :: Enabled } } # [doc = "Field `JAWDEN` writer - Analog watchdog enable on injected channels"] pub type JawdenW < 'a , REG > = crate :: BitWriter < 'a , REG , Jawden > ; impl < 'a , REG > JawdenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Analog watchdog disabled on injected channels"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jawden :: Disabled) } # [doc = "Analog watchdog enabled on injected channels"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jawden :: Enabled) } } # [doc = "Analog watchdog enable on regular channels\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Awden { # [doc = "0: Analog watchdog disabled on regular channels"] Disabled = 0 , # [doc = "1: Analog watchdog enabled on regular channels"] Enabled = 1 , } impl From < Awden > for bool { # [inline (always)] fn from (variant : Awden) -> Self { variant as u8 != 0 } } # [doc = "Field `AWDEN` reader - Analog watchdog enable on regular channels"] pub type AwdenR = crate :: BitReader < Awden > ; impl AwdenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Awden { match self . bits { false => Awden :: Disabled , true => Awden :: Enabled , } } # [doc = "Analog watchdog disabled on regular channels"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Awden :: Disabled } # [doc = "Analog watchdog enabled on regular channels"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Awden :: Enabled } } # [doc = "Field `AWDEN` writer - Analog watchdog enable on regular channels"] pub type AwdenW < 'a , REG > = crate :: BitWriter < 'a , REG , Awden > ; impl < 'a , REG > AwdenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Analog watchdog disabled on regular channels"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Awden :: Disabled) } # [doc = "Analog watchdog enabled on regular channels"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Awden :: Enabled) } } # [doc = "Resolution\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Res { # [doc = "0: 12-bit (15 ADCCLK cycles)"] TwelveBit = 0 , # [doc = "1: 10-bit (13 ADCCLK cycles)"] TenBit = 1 , # [doc = "2: 8-bit (11 ADCCLK cycles)"] EightBit = 2 , # [doc = "3: 6-bit (9 ADCCLK cycles)"] SixBit = 3 , } impl From < Res > for u8 { # [inline (always)] fn from (variant : Res) -> Self { variant as _ } } impl crate :: FieldSpec for Res { type Ux = u8 ; } impl crate :: IsEnum for Res { } # [doc = "Field `RES` reader - Resolution"] pub type ResR = crate :: FieldReader < Res > ; impl ResR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Res { match self . bits { 0 => Res :: TwelveBit , 1 => Res :: TenBit , 2 => Res :: EightBit , 3 => Res :: SixBit , _ => unreachable ! () , } } # [doc = "12-bit (15 ADCCLK cycles)"] # [inline (always)] pub fn is_twelve_bit (& self) -> bool { * self == Res :: TwelveBit } # [doc = "10-bit (13 ADCCLK cycles)"] # [inline (always)] pub fn is_ten_bit (& self) -> bool { * self == Res :: TenBit } # [doc = "8-bit (11 ADCCLK cycles)"] # [inline (always)] pub fn is_eight_bit (& self) -> bool { * self == Res :: EightBit } # [doc = "6-bit (9 ADCCLK cycles)"] # [inline (always)] pub fn is_six_bit (& self) -> bool { * self == Res :: SixBit } } # [doc = "Field `RES` writer - Resolution"] pub type ResW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Res , crate :: Safe > ; impl < 'a , REG > ResW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "12-bit (15 ADCCLK cycles)"] # [inline (always)] pub fn twelve_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Res :: TwelveBit) } # [doc = "10-bit (13 ADCCLK cycles)"] # [inline (always)] pub fn ten_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Res :: TenBit) } # [doc = "8-bit (11 ADCCLK cycles)"] # [inline (always)] pub fn eight_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Res :: EightBit) } # [doc = "6-bit (9 ADCCLK cycles)"] # [inline (always)] pub fn six_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Res :: SixBit) } } # [doc = "Overrun interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ovrie { # [doc = "0: Overrun interrupt disabled"] Disabled = 0 , # [doc = "1: Overrun interrupt enabled"] Enabled = 1 , } impl From < Ovrie > for bool { # [inline (always)] fn from (variant : Ovrie) -> Self { variant as u8 != 0 } } # [doc = "Field `OVRIE` reader - Overrun interrupt enable"] pub type OvrieR = crate :: BitReader < Ovrie > ; impl OvrieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ovrie { match self . bits { false => Ovrie :: Disabled , true => Ovrie :: Enabled , } } # [doc = "Overrun interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ovrie :: Disabled } # [doc = "Overrun interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ovrie :: Enabled } } # [doc = "Field `OVRIE` writer - Overrun interrupt enable"] pub type OvrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Ovrie > ; impl < 'a , REG > OvrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Overrun interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrie :: Disabled) } # [doc = "Overrun interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrie :: Enabled) } } impl R { # [doc = "Bits 0:4 - Analog watchdog channel select bits"] # [inline (always)] pub fn awdch (& self) -> AwdchR { AwdchR :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 5 - Interrupt enable for EOC"] # [inline (always)] pub fn eocie (& self) -> EocieR { EocieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Analog watchdog interrupt enable"] # [inline (always)] pub fn awdie (& self) -> AwdieR { AwdieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt enable for injected channels"] # [inline (always)] pub fn jeocie (& self) -> JeocieR { JeocieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Scan mode"] # [inline (always)] pub fn scan (& self) -> ScanR { ScanR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"] # [inline (always)] pub fn awdsgl (& self) -> AwdsglR { AwdsglR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Automatic injected group conversion"] # [inline (always)] pub fn jauto (& self) -> JautoR { JautoR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Discontinuous mode on regular channels"] # [inline (always)] pub fn discen (& self) -> DiscenR { DiscenR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Discontinuous mode on injected channels"] # [inline (always)] pub fn jdiscen (& self) -> JdiscenR { JdiscenR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bits 13:15 - Discontinuous mode channel count"] # [inline (always)] pub fn discnum (& self) -> DiscnumR { DiscnumR :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bit 22 - Analog watchdog enable on injected channels"] # [inline (always)] pub fn jawden (& self) -> JawdenR { JawdenR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Analog watchdog enable on regular channels"] # [inline (always)] pub fn awden (& self) -> AwdenR { AwdenR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:25 - Resolution"] # [inline (always)] pub fn res (& self) -> ResR { ResR :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bit 26 - Overrun interrupt enable"] # [inline (always)] pub fn ovrie (& self) -> OvrieR { OvrieR :: new (((self . bits >> 26) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Analog watchdog channel select bits"] # [inline (always)] pub fn awdch (& mut self) -> AwdchW < Cr1Spec > { AwdchW :: new (self , 0) } # [doc = "Bit 5 - Interrupt enable for EOC"] # [inline (always)] pub fn eocie (& mut self) -> EocieW < Cr1Spec > { EocieW :: new (self , 5) } # [doc = "Bit 6 - Analog watchdog interrupt enable"] # [inline (always)] pub fn awdie (& mut self) -> AwdieW < Cr1Spec > { AwdieW :: new (self , 6) } # [doc = "Bit 7 - Interrupt enable for injected channels"] # [inline (always)] pub fn jeocie (& mut self) -> JeocieW < Cr1Spec > { JeocieW :: new (self , 7) } # [doc = "Bit 8 - Scan mode"] # [inline (always)] pub fn scan (& mut self) -> ScanW < Cr1Spec > { ScanW :: new (self , 8) } # [doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"] # [inline (always)] pub fn awdsgl (& mut self) -> AwdsglW < Cr1Spec > { AwdsglW :: new (self , 9) } # [doc = "Bit 10 - Automatic injected group conversion"] # [inline (always)] pub fn jauto (& mut self) -> JautoW < Cr1Spec > { JautoW :: new (self , 10) } # [doc = "Bit 11 - Discontinuous mode on regular channels"] # [inline (always)] pub fn discen (& mut self) -> DiscenW < Cr1Spec > { DiscenW :: new (self , 11) } # [doc = "Bit 12 - Discontinuous mode on injected channels"] # [inline (always)] pub fn jdiscen (& mut self) -> JdiscenW < Cr1Spec > { JdiscenW :: new (self , 12) } # [doc = "Bits 13:15 - Discontinuous mode channel count"] # [inline (always)] pub fn discnum (& mut self) -> DiscnumW < Cr1Spec > { DiscnumW :: new (self , 13) } # [doc = "Bit 22 - Analog watchdog enable on injected channels"] # [inline (always)] pub fn jawden (& mut self) -> JawdenW < Cr1Spec > { JawdenW :: new (self , 22) } # [doc = "Bit 23 - Analog watchdog enable on regular channels"] # [inline (always)] pub fn awden (& mut self) -> AwdenW < Cr1Spec > { AwdenW :: new (self , 23) } # [doc = "Bits 24:25 - Resolution"] # [inline (always)] pub fn res (& mut self) -> ResW < Cr1Spec > { ResW :: new (self , 24) } # [doc = "Bit 26 - Overrun interrupt enable"] # [inline (always)] pub fn ovrie (& mut self) -> OvrieW < Cr1Spec > { OvrieW :: new (self , 26) } } # [doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
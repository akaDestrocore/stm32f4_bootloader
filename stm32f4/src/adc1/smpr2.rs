# [doc = "Register `SMPR2` reader"] pub type R = crate :: R < Smpr2Spec > ; # [doc = "Register `SMPR2` writer"] pub type W = crate :: W < Smpr2Spec > ; # [doc = "Channel %s sample time selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Smp0 { # [doc = "0: 3 cycles"] Cycles3 = 0 , # [doc = "1: 15 cycles"] Cycles15 = 1 , # [doc = "2: 28 cycles"] Cycles28 = 2 , # [doc = "3: 56 cycles"] Cycles56 = 3 , # [doc = "4: 84 cycles"] Cycles84 = 4 , # [doc = "5: 112 cycles"] Cycles112 = 5 , # [doc = "6: 144 cycles"] Cycles144 = 6 , # [doc = "7: 480 cycles"] Cycles480 = 7 , } impl From < Smp0 > for u8 { # [inline (always)] fn from (variant : Smp0) -> Self { variant as _ } } impl crate :: FieldSpec for Smp0 { type Ux = u8 ; } impl crate :: IsEnum for Smp0 { } # [doc = "Field `SMP(0-9)` reader - Channel %s sample time selection"] pub type SmpR = crate :: FieldReader < Smp0 > ; impl SmpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Smp0 { match self . bits { 0 => Smp0 :: Cycles3 , 1 => Smp0 :: Cycles15 , 2 => Smp0 :: Cycles28 , 3 => Smp0 :: Cycles56 , 4 => Smp0 :: Cycles84 , 5 => Smp0 :: Cycles112 , 6 => Smp0 :: Cycles144 , 7 => Smp0 :: Cycles480 , _ => unreachable ! () , } } # [doc = "3 cycles"] # [inline (always)] pub fn is_cycles3 (& self) -> bool { * self == Smp0 :: Cycles3 } # [doc = "15 cycles"] # [inline (always)] pub fn is_cycles15 (& self) -> bool { * self == Smp0 :: Cycles15 } # [doc = "28 cycles"] # [inline (always)] pub fn is_cycles28 (& self) -> bool { * self == Smp0 :: Cycles28 } # [doc = "56 cycles"] # [inline (always)] pub fn is_cycles56 (& self) -> bool { * self == Smp0 :: Cycles56 } # [doc = "84 cycles"] # [inline (always)] pub fn is_cycles84 (& self) -> bool { * self == Smp0 :: Cycles84 } # [doc = "112 cycles"] # [inline (always)] pub fn is_cycles112 (& self) -> bool { * self == Smp0 :: Cycles112 } # [doc = "144 cycles"] # [inline (always)] pub fn is_cycles144 (& self) -> bool { * self == Smp0 :: Cycles144 } # [doc = "480 cycles"] # [inline (always)] pub fn is_cycles480 (& self) -> bool { * self == Smp0 :: Cycles480 } } # [doc = "Field `SMP(0-9)` writer - Channel %s sample time selection"] pub type SmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Smp0 , crate :: Safe > ; impl < 'a , REG > SmpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "3 cycles"] # [inline (always)] pub fn cycles3 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles3) } # [doc = "15 cycles"] # [inline (always)] pub fn cycles15 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles15) } # [doc = "28 cycles"] # [inline (always)] pub fn cycles28 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles28) } # [doc = "56 cycles"] # [inline (always)] pub fn cycles56 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles56) } # [doc = "84 cycles"] # [inline (always)] pub fn cycles84 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles84) } # [doc = "112 cycles"] # [inline (always)] pub fn cycles112 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles112) } # [doc = "144 cycles"] # [inline (always)] pub fn cycles144 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles144) } # [doc = "480 cycles"] # [inline (always)] pub fn cycles480 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp0 :: Cycles480) } } impl R { # [doc = "Channel (0-9) sample time selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `SMP0` field.</div>"] # [inline (always)] pub fn smp (& self , n : u8) -> SmpR { # [allow (clippy :: no_effect)] [() ; 10] [n as usize] ; SmpR :: new (((self . bits >> (n * 3)) & 7) as u8) } # [doc = "Iterator for array of:"] # [doc = "Channel (0-9) sample time selection"] # [inline (always)] pub fn smp_iter (& self) -> impl Iterator < Item = SmpR > + '_ { (0 .. 10) . map (move | n | SmpR :: new (((self . bits >> (n * 3)) & 7) as u8)) } # [doc = "Bits 0:2 - Channel 0 sample time selection"] # [inline (always)] pub fn smp0 (& self) -> SmpR { SmpR :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:5 - Channel 1 sample time selection"] # [inline (always)] pub fn smp1 (& self) -> SmpR { SmpR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bits 6:8 - Channel 2 sample time selection"] # [inline (always)] pub fn smp2 (& self) -> SmpR { SmpR :: new (((self . bits >> 6) & 7) as u8) } # [doc = "Bits 9:11 - Channel 3 sample time selection"] # [inline (always)] pub fn smp3 (& self) -> SmpR { SmpR :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 12:14 - Channel 4 sample time selection"] # [inline (always)] pub fn smp4 (& self) -> SmpR { SmpR :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bits 15:17 - Channel 5 sample time selection"] # [inline (always)] pub fn smp5 (& self) -> SmpR { SmpR :: new (((self . bits >> 15) & 7) as u8) } # [doc = "Bits 18:20 - Channel 6 sample time selection"] # [inline (always)] pub fn smp6 (& self) -> SmpR { SmpR :: new (((self . bits >> 18) & 7) as u8) } # [doc = "Bits 21:23 - Channel 7 sample time selection"] # [inline (always)] pub fn smp7 (& self) -> SmpR { SmpR :: new (((self . bits >> 21) & 7) as u8) } # [doc = "Bits 24:26 - Channel 8 sample time selection"] # [inline (always)] pub fn smp8 (& self) -> SmpR { SmpR :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bits 27:29 - Channel 9 sample time selection"] # [inline (always)] pub fn smp9 (& self) -> SmpR { SmpR :: new (((self . bits >> 27) & 7) as u8) } } impl W { # [doc = "Channel (0-9) sample time selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `SMP0` field.</div>"] # [inline (always)] pub fn smp (& mut self , n : u8) -> SmpW < Smpr2Spec > { # [allow (clippy :: no_effect)] [() ; 10] [n as usize] ; SmpW :: new (self , n * 3) } # [doc = "Bits 0:2 - Channel 0 sample time selection"] # [inline (always)] pub fn smp0 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 0) } # [doc = "Bits 3:5 - Channel 1 sample time selection"] # [inline (always)] pub fn smp1 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 3) } # [doc = "Bits 6:8 - Channel 2 sample time selection"] # [inline (always)] pub fn smp2 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 6) } # [doc = "Bits 9:11 - Channel 3 sample time selection"] # [inline (always)] pub fn smp3 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 9) } # [doc = "Bits 12:14 - Channel 4 sample time selection"] # [inline (always)] pub fn smp4 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 12) } # [doc = "Bits 15:17 - Channel 5 sample time selection"] # [inline (always)] pub fn smp5 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 15) } # [doc = "Bits 18:20 - Channel 6 sample time selection"] # [inline (always)] pub fn smp6 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 18) } # [doc = "Bits 21:23 - Channel 7 sample time selection"] # [inline (always)] pub fn smp7 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 21) } # [doc = "Bits 24:26 - Channel 8 sample time selection"] # [inline (always)] pub fn smp8 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 24) } # [doc = "Bits 27:29 - Channel 9 sample time selection"] # [inline (always)] pub fn smp9 (& mut self) -> SmpW < Smpr2Spec > { SmpW :: new (self , 27) } } # [doc = "sample time register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr2Spec ; impl crate :: RegisterSpec for Smpr2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`smpr2::R`](R) reader structure"] impl crate :: Readable for Smpr2Spec { } # [doc = "`write(|w| ..)` method takes [`smpr2::W`](W) writer structure"] impl crate :: Writable for Smpr2Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets SMPR2 to value 0"] impl crate :: Resettable for Smpr2Spec { }
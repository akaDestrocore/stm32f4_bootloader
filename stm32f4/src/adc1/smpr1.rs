# [doc = "Register `SMPR1` reader"] pub type R = crate :: R < Smpr1Spec > ; # [doc = "Register `SMPR1` writer"] pub type W = crate :: W < Smpr1Spec > ; # [doc = "Channel %s sample time selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Smp10 { # [doc = "0: 3 cycles"] Cycles3 = 0 , # [doc = "1: 15 cycles"] Cycles15 = 1 , # [doc = "2: 28 cycles"] Cycles28 = 2 , # [doc = "3: 56 cycles"] Cycles56 = 3 , # [doc = "4: 84 cycles"] Cycles84 = 4 , # [doc = "5: 112 cycles"] Cycles112 = 5 , # [doc = "6: 144 cycles"] Cycles144 = 6 , # [doc = "7: 480 cycles"] Cycles480 = 7 , } impl From < Smp10 > for u8 { # [inline (always)] fn from (variant : Smp10) -> Self { variant as _ } } impl crate :: FieldSpec for Smp10 { type Ux = u8 ; } impl crate :: IsEnum for Smp10 { } # [doc = "Field `SMP(10-18)` reader - Channel %s sample time selection"] pub type SmpR = crate :: FieldReader < Smp10 > ; impl SmpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Smp10 { match self . bits { 0 => Smp10 :: Cycles3 , 1 => Smp10 :: Cycles15 , 2 => Smp10 :: Cycles28 , 3 => Smp10 :: Cycles56 , 4 => Smp10 :: Cycles84 , 5 => Smp10 :: Cycles112 , 6 => Smp10 :: Cycles144 , 7 => Smp10 :: Cycles480 , _ => unreachable ! () , } } # [doc = "3 cycles"] # [inline (always)] pub fn is_cycles3 (& self) -> bool { * self == Smp10 :: Cycles3 } # [doc = "15 cycles"] # [inline (always)] pub fn is_cycles15 (& self) -> bool { * self == Smp10 :: Cycles15 } # [doc = "28 cycles"] # [inline (always)] pub fn is_cycles28 (& self) -> bool { * self == Smp10 :: Cycles28 } # [doc = "56 cycles"] # [inline (always)] pub fn is_cycles56 (& self) -> bool { * self == Smp10 :: Cycles56 } # [doc = "84 cycles"] # [inline (always)] pub fn is_cycles84 (& self) -> bool { * self == Smp10 :: Cycles84 } # [doc = "112 cycles"] # [inline (always)] pub fn is_cycles112 (& self) -> bool { * self == Smp10 :: Cycles112 } # [doc = "144 cycles"] # [inline (always)] pub fn is_cycles144 (& self) -> bool { * self == Smp10 :: Cycles144 } # [doc = "480 cycles"] # [inline (always)] pub fn is_cycles480 (& self) -> bool { * self == Smp10 :: Cycles480 } } # [doc = "Field `SMP(10-18)` writer - Channel %s sample time selection"] pub type SmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Smp10 , crate :: Safe > ; impl < 'a , REG > SmpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "3 cycles"] # [inline (always)] pub fn cycles3 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles3) } # [doc = "15 cycles"] # [inline (always)] pub fn cycles15 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles15) } # [doc = "28 cycles"] # [inline (always)] pub fn cycles28 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles28) } # [doc = "56 cycles"] # [inline (always)] pub fn cycles56 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles56) } # [doc = "84 cycles"] # [inline (always)] pub fn cycles84 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles84) } # [doc = "112 cycles"] # [inline (always)] pub fn cycles112 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles112) } # [doc = "144 cycles"] # [inline (always)] pub fn cycles144 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles144) } # [doc = "480 cycles"] # [inline (always)] pub fn cycles480 (self) -> & 'a mut crate :: W < REG > { self . variant (Smp10 :: Cycles480) } } impl R { # [doc = "Channel (10-18) sample time selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `SMP10` field.</div>"] # [inline (always)] pub fn smp (& self , n : u8) -> SmpR { # [allow (clippy :: no_effect)] [() ; 9] [n as usize] ; SmpR :: new (((self . bits >> (n * 3)) & 7) as u8) } # [doc = "Iterator for array of:"] # [doc = "Channel (10-18) sample time selection"] # [inline (always)] pub fn smp_iter (& self) -> impl Iterator < Item = SmpR > + '_ { (0 .. 9) . map (move | n | SmpR :: new (((self . bits >> (n * 3)) & 7) as u8)) } # [doc = "Bits 0:2 - Channel 10 sample time selection"] # [inline (always)] pub fn smp10 (& self) -> SmpR { SmpR :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:5 - Channel 11 sample time selection"] # [inline (always)] pub fn smp11 (& self) -> SmpR { SmpR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bits 6:8 - Channel 12 sample time selection"] # [inline (always)] pub fn smp12 (& self) -> SmpR { SmpR :: new (((self . bits >> 6) & 7) as u8) } # [doc = "Bits 9:11 - Channel 13 sample time selection"] # [inline (always)] pub fn smp13 (& self) -> SmpR { SmpR :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 12:14 - Channel 14 sample time selection"] # [inline (always)] pub fn smp14 (& self) -> SmpR { SmpR :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bits 15:17 - Channel 15 sample time selection"] # [inline (always)] pub fn smp15 (& self) -> SmpR { SmpR :: new (((self . bits >> 15) & 7) as u8) } # [doc = "Bits 18:20 - Channel 16 sample time selection"] # [inline (always)] pub fn smp16 (& self) -> SmpR { SmpR :: new (((self . bits >> 18) & 7) as u8) } # [doc = "Bits 21:23 - Channel 17 sample time selection"] # [inline (always)] pub fn smp17 (& self) -> SmpR { SmpR :: new (((self . bits >> 21) & 7) as u8) } # [doc = "Bits 24:26 - Channel 18 sample time selection"] # [inline (always)] pub fn smp18 (& self) -> SmpR { SmpR :: new (((self . bits >> 24) & 7) as u8) } } impl W { # [doc = "Channel (10-18) sample time selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `SMP10` field.</div>"] # [inline (always)] pub fn smp (& mut self , n : u8) -> SmpW < Smpr1Spec > { # [allow (clippy :: no_effect)] [() ; 9] [n as usize] ; SmpW :: new (self , n * 3) } # [doc = "Bits 0:2 - Channel 10 sample time selection"] # [inline (always)] pub fn smp10 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 0) } # [doc = "Bits 3:5 - Channel 11 sample time selection"] # [inline (always)] pub fn smp11 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 3) } # [doc = "Bits 6:8 - Channel 12 sample time selection"] # [inline (always)] pub fn smp12 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 6) } # [doc = "Bits 9:11 - Channel 13 sample time selection"] # [inline (always)] pub fn smp13 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 9) } # [doc = "Bits 12:14 - Channel 14 sample time selection"] # [inline (always)] pub fn smp14 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 12) } # [doc = "Bits 15:17 - Channel 15 sample time selection"] # [inline (always)] pub fn smp15 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 15) } # [doc = "Bits 18:20 - Channel 16 sample time selection"] # [inline (always)] pub fn smp16 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 18) } # [doc = "Bits 21:23 - Channel 17 sample time selection"] # [inline (always)] pub fn smp17 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 21) } # [doc = "Bits 24:26 - Channel 18 sample time selection"] # [inline (always)] pub fn smp18 (& mut self) -> SmpW < Smpr1Spec > { SmpW :: new (self , 24) } } # [doc = "sample time register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smpr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smpr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Smpr1Spec ; impl crate :: RegisterSpec for Smpr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`smpr1::R`](R) reader structure"] impl crate :: Readable for Smpr1Spec { } # [doc = "`write(|w| ..)` method takes [`smpr1::W`](W) writer structure"] impl crate :: Writable for Smpr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets SMPR1 to value 0"] impl crate :: Resettable for Smpr1Spec { }
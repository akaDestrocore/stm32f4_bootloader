# [doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ; # [doc = "Stream enable / flag stream ready when read low\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum En { # [doc = "0: Stream disabled"] Disabled = 0 , # [doc = "1: Stream enabled"] Enabled = 1 , } impl From < En > for bool { # [inline (always)] fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Stream enable / flag stream ready when read low"] pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> En { match self . bits { false => En :: Disabled , true => En :: Enabled , } } # [doc = "Stream disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == En :: Disabled } # [doc = "Stream enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == En :: Enabled } } # [doc = "Field `EN` writer - Stream enable / flag stream ready when read low"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Stream disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Disabled) } # [doc = "Stream enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Enabled) } } # [doc = "Direct mode error interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmeie { # [doc = "0: DME interrupt disabled"] Disabled = 0 , # [doc = "1: DME interrupt enabled"] Enabled = 1 , } impl From < Dmeie > for bool { # [inline (always)] fn from (variant : Dmeie) -> Self { variant as u8 != 0 } } # [doc = "Field `DMEIE` reader - Direct mode error interrupt enable"] pub type DmeieR = crate :: BitReader < Dmeie > ; impl DmeieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmeie { match self . bits { false => Dmeie :: Disabled , true => Dmeie :: Enabled , } } # [doc = "DME interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmeie :: Disabled } # [doc = "DME interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmeie :: Enabled } } # [doc = "Field `DMEIE` writer - Direct mode error interrupt enable"] pub type DmeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmeie > ; impl < 'a , REG > DmeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DME interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmeie :: Disabled) } # [doc = "DME interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmeie :: Enabled) } } # [doc = "Transfer error interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Teie { # [doc = "0: TE interrupt disabled"] Disabled = 0 , # [doc = "1: TE interrupt enabled"] Enabled = 1 , } impl From < Teie > for bool { # [inline (always)] fn from (variant : Teie) -> Self { variant as u8 != 0 } } # [doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader < Teie > ; impl TeieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Teie { match self . bits { false => Teie :: Disabled , true => Teie :: Enabled , } } # [doc = "TE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Teie :: Disabled } # [doc = "TE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Teie :: Enabled } } # [doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Teie > ; impl < 'a , REG > TeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Teie :: Disabled) } # [doc = "TE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Teie :: Enabled) } } # [doc = "Half transfer interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Htie { # [doc = "0: HT interrupt disabled"] Disabled = 0 , # [doc = "1: HT interrupt enabled"] Enabled = 1 , } impl From < Htie > for bool { # [inline (always)] fn from (variant : Htie) -> Self { variant as u8 != 0 } } # [doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader < Htie > ; impl HtieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Htie { match self . bits { false => Htie :: Disabled , true => Htie :: Enabled , } } # [doc = "HT interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Htie :: Disabled } # [doc = "HT interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Htie :: Enabled } } # [doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG , Htie > ; impl < 'a , REG > HtieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "HT interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Htie :: Disabled) } # [doc = "HT interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Htie :: Enabled) } } # [doc = "Transfer complete interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcie { # [doc = "0: TC interrupt disabled"] Disabled = 0 , # [doc = "1: TC interrupt enabled"] Enabled = 1 , } impl From < Tcie > for bool { # [inline (always)] fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disabled , true => Tcie :: Enabled , } } # [doc = "TC interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Tcie :: Disabled } # [doc = "TC interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Tcie :: Enabled } } # [doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TC interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disabled) } # [doc = "TC interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enabled) } } # [doc = "Peripheral flow controller\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pfctrl { # [doc = "0: The DMA is the flow controller"] Dma = 0 , # [doc = "1: The peripheral is the flow controller"] Peripheral = 1 , } impl From < Pfctrl > for bool { # [inline (always)] fn from (variant : Pfctrl) -> Self { variant as u8 != 0 } } # [doc = "Field `PFCTRL` reader - Peripheral flow controller"] pub type PfctrlR = crate :: BitReader < Pfctrl > ; impl PfctrlR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pfctrl { match self . bits { false => Pfctrl :: Dma , true => Pfctrl :: Peripheral , } } # [doc = "The DMA is the flow controller"] # [inline (always)] pub fn is_dma (& self) -> bool { * self == Pfctrl :: Dma } # [doc = "The peripheral is the flow controller"] # [inline (always)] pub fn is_peripheral (& self) -> bool { * self == Pfctrl :: Peripheral } } # [doc = "Field `PFCTRL` writer - Peripheral flow controller"] pub type PfctrlW < 'a , REG > = crate :: BitWriter < 'a , REG , Pfctrl > ; impl < 'a , REG > PfctrlW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The DMA is the flow controller"] # [inline (always)] pub fn dma (self) -> & 'a mut crate :: W < REG > { self . variant (Pfctrl :: Dma) } # [doc = "The peripheral is the flow controller"] # [inline (always)] pub fn peripheral (self) -> & 'a mut crate :: W < REG > { self . variant (Pfctrl :: Peripheral) } } # [doc = "Data transfer direction\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Dir { # [doc = "0: Peripheral-to-memory"] PeripheralToMemory = 0 , # [doc = "1: Memory-to-peripheral"] MemoryToPeripheral = 1 , # [doc = "2: Memory-to-memory"] MemoryToMemory = 2 , } impl From < Dir > for u8 { # [inline (always)] fn from (variant : Dir) -> Self { variant as _ } } impl crate :: FieldSpec for Dir { type Ux = u8 ; } impl crate :: IsEnum for Dir { } # [doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: FieldReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Dir > { match self . bits { 0 => Some (Dir :: PeripheralToMemory) , 1 => Some (Dir :: MemoryToPeripheral) , 2 => Some (Dir :: MemoryToMemory) , _ => None , } } # [doc = "Peripheral-to-memory"] # [inline (always)] pub fn is_peripheral_to_memory (& self) -> bool { * self == Dir :: PeripheralToMemory } # [doc = "Memory-to-peripheral"] # [inline (always)] pub fn is_memory_to_peripheral (& self) -> bool { * self == Dir :: MemoryToPeripheral } # [doc = "Memory-to-memory"] # [inline (always)] pub fn is_memory_to_memory (& self) -> bool { * self == Dir :: MemoryToMemory } } # [doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Dir > ; impl < 'a , REG > DirW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Peripheral-to-memory"] # [inline (always)] pub fn peripheral_to_memory (self) -> & 'a mut crate :: W < REG > { self . variant (Dir :: PeripheralToMemory) } # [doc = "Memory-to-peripheral"] # [inline (always)] pub fn memory_to_peripheral (self) -> & 'a mut crate :: W < REG > { self . variant (Dir :: MemoryToPeripheral) } # [doc = "Memory-to-memory"] # [inline (always)] pub fn memory_to_memory (self) -> & 'a mut crate :: W < REG > { self . variant (Dir :: MemoryToMemory) } } # [doc = "Circular mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Circ { # [doc = "0: Circular mode disabled"] Disabled = 0 , # [doc = "1: Circular mode enabled"] Enabled = 1 , } impl From < Circ > for bool { # [inline (always)] fn from (variant : Circ) -> Self { variant as u8 != 0 } } # [doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader < Circ > ; impl CircR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Circ { match self . bits { false => Circ :: Disabled , true => Circ :: Enabled , } } # [doc = "Circular mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Circ :: Disabled } # [doc = "Circular mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Circ :: Enabled } } # [doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG , Circ > ; impl < 'a , REG > CircW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Circular mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Circ :: Disabled) } # [doc = "Circular mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Circ :: Enabled) } } # [doc = "Peripheral increment mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pinc { # [doc = "0: Address pointer is fixed"] Fixed = 0 , # [doc = "1: Address pointer is incremented after each data transfer"] Incremented = 1 , } impl From < Pinc > for bool { # [inline (always)] fn from (variant : Pinc) -> Self { variant as u8 != 0 } } # [doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader < Pinc > ; impl PincR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pinc { match self . bits { false => Pinc :: Fixed , true => Pinc :: Incremented , } } # [doc = "Address pointer is fixed"] # [inline (always)] pub fn is_fixed (& self) -> bool { * self == Pinc :: Fixed } # [doc = "Address pointer is incremented after each data transfer"] # [inline (always)] pub fn is_incremented (& self) -> bool { * self == Pinc :: Incremented } } # [doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG , Pinc > ; impl < 'a , REG > PincW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Address pointer is fixed"] # [inline (always)] pub fn fixed (self) -> & 'a mut crate :: W < REG > { self . variant (Pinc :: Fixed) } # [doc = "Address pointer is incremented after each data transfer"] # [inline (always)] pub fn incremented (self) -> & 'a mut crate :: W < REG > { self . variant (Pinc :: Incremented) } } # [doc = "Field `MINC` reader - Memory increment mode"] pub use PincR as MincR ; # [doc = "Field `MINC` writer - Memory increment mode"] pub use PincW as MincW ; # [doc = "Peripheral data size\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Psize { # [doc = "0: Byte (8-bit)"] Bits8 = 0 , # [doc = "1: Half-word (16-bit)"] Bits16 = 1 , # [doc = "2: Word (32-bit)"] Bits32 = 2 , } impl From < Psize > for u8 { # [inline (always)] fn from (variant : Psize) -> Self { variant as _ } } impl crate :: FieldSpec for Psize { type Ux = u8 ; } impl crate :: IsEnum for Psize { } # [doc = "Field `PSIZE` reader - Peripheral data size"] pub type PsizeR = crate :: FieldReader < Psize > ; impl PsizeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Psize > { match self . bits { 0 => Some (Psize :: Bits8) , 1 => Some (Psize :: Bits16) , 2 => Some (Psize :: Bits32) , _ => None , } } # [doc = "Byte (8-bit)"] # [inline (always)] pub fn is_bits8 (& self) -> bool { * self == Psize :: Bits8 } # [doc = "Half-word (16-bit)"] # [inline (always)] pub fn is_bits16 (& self) -> bool { * self == Psize :: Bits16 } # [doc = "Word (32-bit)"] # [inline (always)] pub fn is_bits32 (& self) -> bool { * self == Psize :: Bits32 } } # [doc = "Field `PSIZE` writer - Peripheral data size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Psize > ; impl < 'a , REG > PsizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Byte (8-bit)"] # [inline (always)] pub fn bits8 (self) -> & 'a mut crate :: W < REG > { self . variant (Psize :: Bits8) } # [doc = "Half-word (16-bit)"] # [inline (always)] pub fn bits16 (self) -> & 'a mut crate :: W < REG > { self . variant (Psize :: Bits16) } # [doc = "Word (32-bit)"] # [inline (always)] pub fn bits32 (self) -> & 'a mut crate :: W < REG > { self . variant (Psize :: Bits32) } } # [doc = "Field `MSIZE` reader - Memory data size"] pub use PsizeR as MsizeR ; # [doc = "Field `MSIZE` writer - Memory data size"] pub use PsizeW as MsizeW ; # [doc = "Peripheral increment offset size\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pincos { # [doc = "0: The offset size for the peripheral address calculation is linked to the PSIZE"] Psize = 0 , # [doc = "1: The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)"] Fixed4 = 1 , } impl From < Pincos > for bool { # [inline (always)] fn from (variant : Pincos) -> Self { variant as u8 != 0 } } # [doc = "Field `PINCOS` reader - Peripheral increment offset size"] pub type PincosR = crate :: BitReader < Pincos > ; impl PincosR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pincos { match self . bits { false => Pincos :: Psize , true => Pincos :: Fixed4 , } } # [doc = "The offset size for the peripheral address calculation is linked to the PSIZE"] # [inline (always)] pub fn is_psize (& self) -> bool { * self == Pincos :: Psize } # [doc = "The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)"] # [inline (always)] pub fn is_fixed4 (& self) -> bool { * self == Pincos :: Fixed4 } } # [doc = "Field `PINCOS` writer - Peripheral increment offset size"] pub type PincosW < 'a , REG > = crate :: BitWriter < 'a , REG , Pincos > ; impl < 'a , REG > PincosW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The offset size for the peripheral address calculation is linked to the PSIZE"] # [inline (always)] pub fn psize (self) -> & 'a mut crate :: W < REG > { self . variant (Pincos :: Psize) } # [doc = "The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)"] # [inline (always)] pub fn fixed4 (self) -> & 'a mut crate :: W < REG > { self . variant (Pincos :: Fixed4) } } # [doc = "Priority level\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pl { # [doc = "0: Low"] Low = 0 , # [doc = "1: Medium"] Medium = 1 , # [doc = "2: High"] High = 2 , # [doc = "3: Very high"] VeryHigh = 3 , } impl From < Pl > for u8 { # [inline (always)] fn from (variant : Pl) -> Self { variant as _ } } impl crate :: FieldSpec for Pl { type Ux = u8 ; } impl crate :: IsEnum for Pl { } # [doc = "Field `PL` reader - Priority level"] pub type PlR = crate :: FieldReader < Pl > ; impl PlR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pl { match self . bits { 0 => Pl :: Low , 1 => Pl :: Medium , 2 => Pl :: High , 3 => Pl :: VeryHigh , _ => unreachable ! () , } } # [doc = "Low"] # [inline (always)] pub fn is_low (& self) -> bool { * self == Pl :: Low } # [doc = "Medium"] # [inline (always)] pub fn is_medium (& self) -> bool { * self == Pl :: Medium } # [doc = "High"] # [inline (always)] pub fn is_high (& self) -> bool { * self == Pl :: High } # [doc = "Very high"] # [inline (always)] pub fn is_very_high (& self) -> bool { * self == Pl :: VeryHigh } } # [doc = "Field `PL` writer - Priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Pl , crate :: Safe > ; impl < 'a , REG > PlW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Low"] # [inline (always)] pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Pl :: Low) } # [doc = "Medium"] # [inline (always)] pub fn medium (self) -> & 'a mut crate :: W < REG > { self . variant (Pl :: Medium) } # [doc = "High"] # [inline (always)] pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Pl :: High) } # [doc = "Very high"] # [inline (always)] pub fn very_high (self) -> & 'a mut crate :: W < REG > { self . variant (Pl :: VeryHigh) } } # [doc = "Double buffer mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dbm { # [doc = "0: No buffer switching at the end of transfer"] Disabled = 0 , # [doc = "1: Memory target switched at the end of the DMA transfer"] Enabled = 1 , } impl From < Dbm > for bool { # [inline (always)] fn from (variant : Dbm) -> Self { variant as u8 != 0 } } # [doc = "Field `DBM` reader - Double buffer mode"] pub type DbmR = crate :: BitReader < Dbm > ; impl DbmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dbm { match self . bits { false => Dbm :: Disabled , true => Dbm :: Enabled , } } # [doc = "No buffer switching at the end of transfer"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dbm :: Disabled } # [doc = "Memory target switched at the end of the DMA transfer"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dbm :: Enabled } } # [doc = "Field `DBM` writer - Double buffer mode"] pub type DbmW < 'a , REG > = crate :: BitWriter < 'a , REG , Dbm > ; impl < 'a , REG > DbmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No buffer switching at the end of transfer"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dbm :: Disabled) } # [doc = "Memory target switched at the end of the DMA transfer"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dbm :: Enabled) } } # [doc = "Current target (only in double buffer mode)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ct { # [doc = "0: The current target memory is Memory 0"] Memory0 = 0 , # [doc = "1: The current target memory is Memory 1"] Memory1 = 1 , } impl From < Ct > for bool { # [inline (always)] fn from (variant : Ct) -> Self { variant as u8 != 0 } } # [doc = "Field `CT` reader - Current target (only in double buffer mode)"] pub type CtR = crate :: BitReader < Ct > ; impl CtR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ct { match self . bits { false => Ct :: Memory0 , true => Ct :: Memory1 , } } # [doc = "The current target memory is Memory 0"] # [inline (always)] pub fn is_memory0 (& self) -> bool { * self == Ct :: Memory0 } # [doc = "The current target memory is Memory 1"] # [inline (always)] pub fn is_memory1 (& self) -> bool { * self == Ct :: Memory1 } } # [doc = "Field `CT` writer - Current target (only in double buffer mode)"] pub type CtW < 'a , REG > = crate :: BitWriter < 'a , REG , Ct > ; impl < 'a , REG > CtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The current target memory is Memory 0"] # [inline (always)] pub fn memory0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ct :: Memory0) } # [doc = "The current target memory is Memory 1"] # [inline (always)] pub fn memory1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ct :: Memory1) } } # [doc = "Peripheral burst transfer configuration\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pburst { # [doc = "0: Single transfer"] Single = 0 , # [doc = "1: Incremental burst of 4 beats"] Incr4 = 1 , # [doc = "2: Incremental burst of 8 beats"] Incr8 = 2 , # [doc = "3: Incremental burst of 16 beats"] Incr16 = 3 , } impl From < Pburst > for u8 { # [inline (always)] fn from (variant : Pburst) -> Self { variant as _ } } impl crate :: FieldSpec for Pburst { type Ux = u8 ; } impl crate :: IsEnum for Pburst { } # [doc = "Field `PBURST` reader - Peripheral burst transfer configuration"] pub type PburstR = crate :: FieldReader < Pburst > ; impl PburstR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pburst { match self . bits { 0 => Pburst :: Single , 1 => Pburst :: Incr4 , 2 => Pburst :: Incr8 , 3 => Pburst :: Incr16 , _ => unreachable ! () , } } # [doc = "Single transfer"] # [inline (always)] pub fn is_single (& self) -> bool { * self == Pburst :: Single } # [doc = "Incremental burst of 4 beats"] # [inline (always)] pub fn is_incr4 (& self) -> bool { * self == Pburst :: Incr4 } # [doc = "Incremental burst of 8 beats"] # [inline (always)] pub fn is_incr8 (& self) -> bool { * self == Pburst :: Incr8 } # [doc = "Incremental burst of 16 beats"] # [inline (always)] pub fn is_incr16 (& self) -> bool { * self == Pburst :: Incr16 } } # [doc = "Field `PBURST` writer - Peripheral burst transfer configuration"] pub type PburstW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Pburst , crate :: Safe > ; impl < 'a , REG > PburstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Single transfer"] # [inline (always)] pub fn single (self) -> & 'a mut crate :: W < REG > { self . variant (Pburst :: Single) } # [doc = "Incremental burst of 4 beats"] # [inline (always)] pub fn incr4 (self) -> & 'a mut crate :: W < REG > { self . variant (Pburst :: Incr4) } # [doc = "Incremental burst of 8 beats"] # [inline (always)] pub fn incr8 (self) -> & 'a mut crate :: W < REG > { self . variant (Pburst :: Incr8) } # [doc = "Incremental burst of 16 beats"] # [inline (always)] pub fn incr16 (self) -> & 'a mut crate :: W < REG > { self . variant (Pburst :: Incr16) } } # [doc = "Field `MBURST` reader - Memory burst transfer configuration"] pub use PburstR as MburstR ; # [doc = "Field `MBURST` writer - Memory burst transfer configuration"] pub use PburstW as MburstW ; # [doc = "Field `CHSEL` reader - Channel selection"] pub type ChselR = crate :: FieldReader ; # [doc = "Field `CHSEL` writer - Channel selection"] pub type ChselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , u8 , crate :: Safe > ; impl R { # [doc = "Bit 0 - Stream enable / flag stream ready when read low"] # [inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Direct mode error interrupt enable"] # [inline (always)] pub fn dmeie (& self) -> DmeieR { DmeieR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Transfer error interrupt enable"] # [inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Half transfer interrupt enable"] # [inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transfer complete interrupt enable"] # [inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Peripheral flow controller"] # [inline (always)] pub fn pfctrl (& self) -> PfctrlR { PfctrlR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Data transfer direction"] # [inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 8 - Circular mode"] # [inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Peripheral increment mode"] # [inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Memory increment mode"] # [inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 11:12 - Peripheral data size"] # [inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 11) & 3) as u8) } # [doc = "Bits 13:14 - Memory data size"] # [inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 13) & 3) as u8) } # [doc = "Bit 15 - Peripheral increment offset size"] # [inline (always)] pub fn pincos (& self) -> PincosR { PincosR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:17 - Priority level"] # [inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bit 18 - Double buffer mode"] # [inline (always)] pub fn dbm (& self) -> DbmR { DbmR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Current target (only in double buffer mode)"] # [inline (always)] pub fn ct (& self) -> CtR { CtR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bits 21:22 - Peripheral burst transfer configuration"] # [inline (always)] pub fn pburst (& self) -> PburstR { PburstR :: new (((self . bits >> 21) & 3) as u8) } # [doc = "Bits 23:24 - Memory burst transfer configuration"] # [inline (always)] pub fn mburst (& self) -> MburstR { MburstR :: new (((self . bits >> 23) & 3) as u8) } # [doc = "Bits 25:27 - Channel selection"] # [inline (always)] pub fn chsel (& self) -> ChselR { ChselR :: new (((self . bits >> 25) & 7) as u8) } } impl W { # [doc = "Bit 0 - Stream enable / flag stream ready when read low"] # [inline (always)] pub fn en (& mut self) -> EnW < CrSpec > { EnW :: new (self , 0) } # [doc = "Bit 1 - Direct mode error interrupt enable"] # [inline (always)] pub fn dmeie (& mut self) -> DmeieW < CrSpec > { DmeieW :: new (self , 1) } # [doc = "Bit 2 - Transfer error interrupt enable"] # [inline (always)] pub fn teie (& mut self) -> TeieW < CrSpec > { TeieW :: new (self , 2) } # [doc = "Bit 3 - Half transfer interrupt enable"] # [inline (always)] pub fn htie (& mut self) -> HtieW < CrSpec > { HtieW :: new (self , 3) } # [doc = "Bit 4 - Transfer complete interrupt enable"] # [inline (always)] pub fn tcie (& mut self) -> TcieW < CrSpec > { TcieW :: new (self , 4) } # [doc = "Bit 5 - Peripheral flow controller"] # [inline (always)] pub fn pfctrl (& mut self) -> PfctrlW < CrSpec > { PfctrlW :: new (self , 5) } # [doc = "Bits 6:7 - Data transfer direction"] # [inline (always)] pub fn dir (& mut self) -> DirW < CrSpec > { DirW :: new (self , 6) } # [doc = "Bit 8 - Circular mode"] # [inline (always)] pub fn circ (& mut self) -> CircW < CrSpec > { CircW :: new (self , 8) } # [doc = "Bit 9 - Peripheral increment mode"] # [inline (always)] pub fn pinc (& mut self) -> PincW < CrSpec > { PincW :: new (self , 9) } # [doc = "Bit 10 - Memory increment mode"] # [inline (always)] pub fn minc (& mut self) -> MincW < CrSpec > { MincW :: new (self , 10) } # [doc = "Bits 11:12 - Peripheral data size"] # [inline (always)] pub fn psize (& mut self) -> PsizeW < CrSpec > { PsizeW :: new (self , 11) } # [doc = "Bits 13:14 - Memory data size"] # [inline (always)] pub fn msize (& mut self) -> MsizeW < CrSpec > { MsizeW :: new (self , 13) } # [doc = "Bit 15 - Peripheral increment offset size"] # [inline (always)] pub fn pincos (& mut self) -> PincosW < CrSpec > { PincosW :: new (self , 15) } # [doc = "Bits 16:17 - Priority level"] # [inline (always)] pub fn pl (& mut self) -> PlW < CrSpec > { PlW :: new (self , 16) } # [doc = "Bit 18 - Double buffer mode"] # [inline (always)] pub fn dbm (& mut self) -> DbmW < CrSpec > { DbmW :: new (self , 18) } # [doc = "Bit 19 - Current target (only in double buffer mode)"] # [inline (always)] pub fn ct (& mut self) -> CtW < CrSpec > { CtW :: new (self , 19) } # [doc = "Bits 21:22 - Peripheral burst transfer configuration"] # [inline (always)] pub fn pburst (& mut self) -> PburstW < CrSpec > { PburstW :: new (self , 21) } # [doc = "Bits 23:24 - Memory burst transfer configuration"] # [inline (always)] pub fn mburst (& mut self) -> MburstW < CrSpec > { MburstW :: new (self , 23) } # [doc = "Bits 25:27 - Channel selection"] # [inline (always)] pub fn chsel (& mut self) -> ChselW < CrSpec > { ChselW :: new (self , 25) } } # [doc = "stream x configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { }
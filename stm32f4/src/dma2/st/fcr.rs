# [doc = "Register `FCR` reader"] pub type R = crate :: R < FcrSpec > ; # [doc = "Register `FCR` writer"] pub type W = crate :: W < FcrSpec > ; # [doc = "FIFO threshold selection\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Fth { # [doc = "0: 1/4 full FIFO"] Quarter = 0 , # [doc = "1: 1/2 full FIFO"] Half = 1 , # [doc = "2: 3/4 full FIFO"] ThreeQuarters = 2 , # [doc = "3: Full FIFO"] Full = 3 , } impl From < Fth > for u8 { # [inline (always)] fn from (variant : Fth) -> Self { variant as _ } } impl crate :: FieldSpec for Fth { type Ux = u8 ; } impl crate :: IsEnum for Fth { } # [doc = "Field `FTH` reader - FIFO threshold selection"] pub type FthR = crate :: FieldReader < Fth > ; impl FthR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fth { match self . bits { 0 => Fth :: Quarter , 1 => Fth :: Half , 2 => Fth :: ThreeQuarters , 3 => Fth :: Full , _ => unreachable ! () , } } # [doc = "1/4 full FIFO"] # [inline (always)] pub fn is_quarter (& self) -> bool { * self == Fth :: Quarter } # [doc = "1/2 full FIFO"] # [inline (always)] pub fn is_half (& self) -> bool { * self == Fth :: Half } # [doc = "3/4 full FIFO"] # [inline (always)] pub fn is_three_quarters (& self) -> bool { * self == Fth :: ThreeQuarters } # [doc = "Full FIFO"] # [inline (always)] pub fn is_full (& self) -> bool { * self == Fth :: Full } } # [doc = "Field `FTH` writer - FIFO threshold selection"] pub type FthW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Fth , crate :: Safe > ; impl < 'a , REG > FthW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "1/4 full FIFO"] # [inline (always)] pub fn quarter (self) -> & 'a mut crate :: W < REG > { self . variant (Fth :: Quarter) } # [doc = "1/2 full FIFO"] # [inline (always)] pub fn half (self) -> & 'a mut crate :: W < REG > { self . variant (Fth :: Half) } # [doc = "3/4 full FIFO"] # [inline (always)] pub fn three_quarters (self) -> & 'a mut crate :: W < REG > { self . variant (Fth :: ThreeQuarters) } # [doc = "Full FIFO"] # [inline (always)] pub fn full (self) -> & 'a mut crate :: W < REG > { self . variant (Fth :: Full) } } # [doc = "Direct mode disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmdis { # [doc = "0: Direct mode is enabled"] Enabled = 0 , # [doc = "1: Direct mode is disabled"] Disabled = 1 , } impl From < Dmdis > for bool { # [inline (always)] fn from (variant : Dmdis) -> Self { variant as u8 != 0 } } # [doc = "Field `DMDIS` reader - Direct mode disable"] pub type DmdisR = crate :: BitReader < Dmdis > ; impl DmdisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmdis { match self . bits { false => Dmdis :: Enabled , true => Dmdis :: Disabled , } } # [doc = "Direct mode is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmdis :: Enabled } # [doc = "Direct mode is disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmdis :: Disabled } } # [doc = "Field `DMDIS` writer - Direct mode disable"] pub type DmdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmdis > ; impl < 'a , REG > DmdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Direct mode is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmdis :: Enabled) } # [doc = "Direct mode is disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmdis :: Disabled) } } # [doc = "FIFO status\n\nValue on reset: 4"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Fs { # [doc = "0: 0 < fifo_level < 1/4"] Quarter1 = 0 , # [doc = "1: 1/4 <= fifo_level < 1/2"] Quarter2 = 1 , # [doc = "2: 1/2 <= fifo_level < 3/4"] Quarter3 = 2 , # [doc = "3: 3/4 <= fifo_level < full"] Quarter4 = 3 , # [doc = "4: FIFO is empty"] Empty = 4 , # [doc = "5: FIFO is full"] Full = 5 , } impl From < Fs > for u8 { # [inline (always)] fn from (variant : Fs) -> Self { variant as _ } } impl crate :: FieldSpec for Fs { type Ux = u8 ; } impl crate :: IsEnum for Fs { } # [doc = "Field `FS` reader - FIFO status"] pub type FsR = crate :: FieldReader < Fs > ; impl FsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Fs > { match self . bits { 0 => Some (Fs :: Quarter1) , 1 => Some (Fs :: Quarter2) , 2 => Some (Fs :: Quarter3) , 3 => Some (Fs :: Quarter4) , 4 => Some (Fs :: Empty) , 5 => Some (Fs :: Full) , _ => None , } } # [doc = "0 < fifo_level < 1/4"] # [inline (always)] pub fn is_quarter1 (& self) -> bool { * self == Fs :: Quarter1 } # [doc = "1/4 <= fifo_level < 1/2"] # [inline (always)] pub fn is_quarter2 (& self) -> bool { * self == Fs :: Quarter2 } # [doc = "1/2 <= fifo_level < 3/4"] # [inline (always)] pub fn is_quarter3 (& self) -> bool { * self == Fs :: Quarter3 } # [doc = "3/4 <= fifo_level < full"] # [inline (always)] pub fn is_quarter4 (& self) -> bool { * self == Fs :: Quarter4 } # [doc = "FIFO is empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Fs :: Empty } # [doc = "FIFO is full"] # [inline (always)] pub fn is_full (& self) -> bool { * self == Fs :: Full } } # [doc = "FIFO error interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Feie { # [doc = "0: FE interrupt disabled"] Disabled = 0 , # [doc = "1: FE interrupt enabled"] Enabled = 1 , } impl From < Feie > for bool { # [inline (always)] fn from (variant : Feie) -> Self { variant as u8 != 0 } } # [doc = "Field `FEIE` reader - FIFO error interrupt enable"] pub type FeieR = crate :: BitReader < Feie > ; impl FeieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Feie { match self . bits { false => Feie :: Disabled , true => Feie :: Enabled , } } # [doc = "FE interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Feie :: Disabled } # [doc = "FE interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Feie :: Enabled } } # [doc = "Field `FEIE` writer - FIFO error interrupt enable"] pub type FeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Feie > ; impl < 'a , REG > FeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "FE interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Feie :: Disabled) } # [doc = "FE interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Feie :: Enabled) } } impl R { # [doc = "Bits 0:1 - FIFO threshold selection"] # [inline (always)] pub fn fth (& self) -> FthR { FthR :: new ((self . bits & 3) as u8) } # [doc = "Bit 2 - Direct mode disable"] # [inline (always)] pub fn dmdis (& self) -> DmdisR { DmdisR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - FIFO status"] # [inline (always)] pub fn fs (& self) -> FsR { FsR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bit 7 - FIFO error interrupt enable"] # [inline (always)] pub fn feie (& self) -> FeieR { FeieR :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - FIFO threshold selection"] # [inline (always)] pub fn fth (& mut self) -> FthW < FcrSpec > { FthW :: new (self , 0) } # [doc = "Bit 2 - Direct mode disable"] # [inline (always)] pub fn dmdis (& mut self) -> DmdisW < FcrSpec > { DmdisW :: new (self , 2) } # [doc = "Bit 7 - FIFO error interrupt enable"] # [inline (always)] pub fn feie (& mut self) -> FeieW < FcrSpec > { FeieW :: new (self , 7) } } # [doc = "stream x FIFO control register\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FcrSpec ; impl crate :: RegisterSpec for FcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FcrSpec { } # [doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FcrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets FCR to value 0x21"] impl crate :: Resettable for FcrSpec { const RESET_VALUE : u32 = 0x21 ; }
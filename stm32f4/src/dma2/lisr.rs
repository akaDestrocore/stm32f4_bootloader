# [doc = "Register `LISR` reader"] pub type R = crate :: R < LisrSpec > ; # [doc = "Stream x FIFO error interrupt flag (x=3..0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Feif0 { # [doc = "0: No FIFO error event on stream x"] NoError = 0 , # [doc = "1: A FIFO error event occurred on stream x"] Error = 1 , } impl From < Feif0 > for bool { # [inline (always)] fn from (variant : Feif0) -> Self { variant as u8 != 0 } } # [doc = "Field `FEIF0` reader - Stream x FIFO error interrupt flag (x=3..0)"] pub type Feif0R = crate :: BitReader < Feif0 > ; impl Feif0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Feif0 { match self . bits { false => Feif0 :: NoError , true => Feif0 :: Error , } } # [doc = "No FIFO error event on stream x"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Feif0 :: NoError } # [doc = "A FIFO error event occurred on stream x"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Feif0 :: Error } } # [doc = "Stream x direct mode error interrupt flag (x=3..0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmeif0 { # [doc = "0: No Direct Mode error on stream x"] NoError = 0 , # [doc = "1: A Direct Mode error occurred on stream x"] Error = 1 , } impl From < Dmeif0 > for bool { # [inline (always)] fn from (variant : Dmeif0) -> Self { variant as u8 != 0 } } # [doc = "Field `DMEIF0` reader - Stream x direct mode error interrupt flag (x=3..0)"] pub type Dmeif0R = crate :: BitReader < Dmeif0 > ; impl Dmeif0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmeif0 { match self . bits { false => Dmeif0 :: NoError , true => Dmeif0 :: Error , } } # [doc = "No Direct Mode error on stream x"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Dmeif0 :: NoError } # [doc = "A Direct Mode error occurred on stream x"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Dmeif0 :: Error } } # [doc = "Stream x transfer error interrupt flag (x=3..0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Teif0 { # [doc = "0: No transfer error on stream x"] NoError = 0 , # [doc = "1: A transfer error occurred on stream x"] Error = 1 , } impl From < Teif0 > for bool { # [inline (always)] fn from (variant : Teif0) -> Self { variant as u8 != 0 } } # [doc = "Field `TEIF0` reader - Stream x transfer error interrupt flag (x=3..0)"] pub type Teif0R = crate :: BitReader < Teif0 > ; impl Teif0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Teif0 { match self . bits { false => Teif0 :: NoError , true => Teif0 :: Error , } } # [doc = "No transfer error on stream x"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Teif0 :: NoError } # [doc = "A transfer error occurred on stream x"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Teif0 :: Error } } # [doc = "Stream x half transfer interrupt flag (x=3..0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Htif0 { # [doc = "0: No half transfer event on stream x"] NotHalf = 0 , # [doc = "1: A half transfer event occurred on stream x"] Half = 1 , } impl From < Htif0 > for bool { # [inline (always)] fn from (variant : Htif0) -> Self { variant as u8 != 0 } } # [doc = "Field `HTIF0` reader - Stream x half transfer interrupt flag (x=3..0)"] pub type Htif0R = crate :: BitReader < Htif0 > ; impl Htif0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Htif0 { match self . bits { false => Htif0 :: NotHalf , true => Htif0 :: Half , } } # [doc = "No half transfer event on stream x"] # [inline (always)] pub fn is_not_half (& self) -> bool { * self == Htif0 :: NotHalf } # [doc = "A half transfer event occurred on stream x"] # [inline (always)] pub fn is_half (& self) -> bool { * self == Htif0 :: Half } } # [doc = "Stream x transfer complete interrupt flag (x = 3..0)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tcif0 { # [doc = "0: No transfer complete event on stream x"] NotComplete = 0 , # [doc = "1: A transfer complete event occurred on stream x"] Complete = 1 , } impl From < Tcif0 > for bool { # [inline (always)] fn from (variant : Tcif0) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIF0` reader - Stream x transfer complete interrupt flag (x = 3..0)"] pub type Tcif0R = crate :: BitReader < Tcif0 > ; impl Tcif0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tcif0 { match self . bits { false => Tcif0 :: NotComplete , true => Tcif0 :: Complete , } } # [doc = "No transfer complete event on stream x"] # [inline (always)] pub fn is_not_complete (& self) -> bool { * self == Tcif0 :: NotComplete } # [doc = "A transfer complete event occurred on stream x"] # [inline (always)] pub fn is_complete (& self) -> bool { * self == Tcif0 :: Complete } } # [doc = "Field `FEIF1` reader - Stream x FIFO error interrupt flag (x=3..0)"] pub use Feif0R as Feif1R ; # [doc = "Field `DMEIF1` reader - Stream x direct mode error interrupt flag (x=3..0)"] pub use Dmeif0R as Dmeif1R ; # [doc = "Field `TEIF1` reader - Stream x transfer error interrupt flag (x=3..0)"] pub use Teif0R as Teif1R ; # [doc = "Field `HTIF1` reader - Stream x half transfer interrupt flag (x=3..0)"] pub use Htif0R as Htif1R ; # [doc = "Field `TCIF1` reader - Stream x transfer complete interrupt flag (x = 3..0)"] pub use Tcif0R as Tcif1R ; # [doc = "Field `FEIF2` reader - Stream x FIFO error interrupt flag (x=3..0)"] pub use Feif0R as Feif2R ; # [doc = "Field `DMEIF2` reader - Stream x direct mode error interrupt flag (x=3..0)"] pub use Dmeif0R as Dmeif2R ; # [doc = "Field `TEIF2` reader - Stream x transfer error interrupt flag (x=3..0)"] pub use Teif0R as Teif2R ; # [doc = "Field `HTIF2` reader - Stream x half transfer interrupt flag (x=3..0)"] pub use Htif0R as Htif2R ; # [doc = "Field `TCIF2` reader - Stream x transfer complete interrupt flag (x = 3..0)"] pub use Tcif0R as Tcif2R ; # [doc = "Field `FEIF3` reader - Stream x FIFO error interrupt flag (x=3..0)"] pub use Feif0R as Feif3R ; # [doc = "Field `DMEIF3` reader - Stream x direct mode error interrupt flag (x=3..0)"] pub use Dmeif0R as Dmeif3R ; # [doc = "Field `TEIF3` reader - Stream x transfer error interrupt flag (x=3..0)"] pub use Teif0R as Teif3R ; # [doc = "Field `HTIF3` reader - Stream x half transfer interrupt flag (x=3..0)"] pub use Htif0R as Htif3R ; # [doc = "Field `TCIF3` reader - Stream x transfer complete interrupt flag (x = 3..0)"] pub use Tcif0R as Tcif3R ; impl R { # [doc = "Bit 0 - Stream x FIFO error interrupt flag (x=3..0)"] # [inline (always)] pub fn feif0 (& self) -> Feif0R { Feif0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Stream x direct mode error interrupt flag (x=3..0)"] # [inline (always)] pub fn dmeif0 (& self) -> Dmeif0R { Dmeif0R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stream x transfer error interrupt flag (x=3..0)"] # [inline (always)] pub fn teif0 (& self) -> Teif0R { Teif0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Stream x half transfer interrupt flag (x=3..0)"] # [inline (always)] pub fn htif0 (& self) -> Htif0R { Htif0R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stream x transfer complete interrupt flag (x = 3..0)"] # [inline (always)] pub fn tcif0 (& self) -> Tcif0R { Tcif0R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Stream x FIFO error interrupt flag (x=3..0)"] # [inline (always)] pub fn feif1 (& self) -> Feif1R { Feif1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Stream x direct mode error interrupt flag (x=3..0)"] # [inline (always)] pub fn dmeif1 (& self) -> Dmeif1R { Dmeif1R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Stream x transfer error interrupt flag (x=3..0)"] # [inline (always)] pub fn teif1 (& self) -> Teif1R { Teif1R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Stream x half transfer interrupt flag (x=3..0)"] # [inline (always)] pub fn htif1 (& self) -> Htif1R { Htif1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Stream x transfer complete interrupt flag (x = 3..0)"] # [inline (always)] pub fn tcif1 (& self) -> Tcif1R { Tcif1R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 16 - Stream x FIFO error interrupt flag (x=3..0)"] # [inline (always)] pub fn feif2 (& self) -> Feif2R { Feif2R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 18 - Stream x direct mode error interrupt flag (x=3..0)"] # [inline (always)] pub fn dmeif2 (& self) -> Dmeif2R { Dmeif2R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Stream x transfer error interrupt flag (x=3..0)"] # [inline (always)] pub fn teif2 (& self) -> Teif2R { Teif2R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Stream x half transfer interrupt flag (x=3..0)"] # [inline (always)] pub fn htif2 (& self) -> Htif2R { Htif2R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Stream x transfer complete interrupt flag (x = 3..0)"] # [inline (always)] pub fn tcif2 (& self) -> Tcif2R { Tcif2R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Stream x FIFO error interrupt flag (x=3..0)"] # [inline (always)] pub fn feif3 (& self) -> Feif3R { Feif3R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 24 - Stream x direct mode error interrupt flag (x=3..0)"] # [inline (always)] pub fn dmeif3 (& self) -> Dmeif3R { Dmeif3R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Stream x transfer error interrupt flag (x=3..0)"] # [inline (always)] pub fn teif3 (& self) -> Teif3R { Teif3R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Stream x half transfer interrupt flag (x=3..0)"] # [inline (always)] pub fn htif3 (& self) -> Htif3R { Htif3R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Stream x transfer complete interrupt flag (x = 3..0)"] # [inline (always)] pub fn tcif3 (& self) -> Tcif3R { Tcif3R :: new (((self . bits >> 27) & 1) != 0) } } # [doc = "low interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`lisr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LisrSpec ; impl crate :: RegisterSpec for LisrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`lisr::R`](R) reader structure"] impl crate :: Readable for LisrSpec { } # [doc = "`reset()` method sets LISR to value 0"] impl crate :: Resettable for LisrSpec { }
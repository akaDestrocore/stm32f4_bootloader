# [doc = "Register `ALRM%sR` reader"] pub type R = crate :: R < AlrmrSpec > ; # [doc = "Register `ALRM%sR` writer"] pub type W = crate :: W < AlrmrSpec > ; # [doc = "Field `SU` reader - Second units in BCD format"] pub type SuR = crate :: FieldReader ; # [doc = "Field `SU` writer - Second units in BCD format"] pub type SuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `ST` reader - Second tens in BCD format"] pub type StR = crate :: FieldReader ; # [doc = "Field `ST` writer - Second tens in BCD format"] pub type StW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , u8 , crate :: Safe > ; # [doc = "Alarm seconds mask\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Msk1 { # [doc = "0: Alarm set if the date/day match"] Mask = 0 , # [doc = "1: Date/day don’t care in Alarm comparison"] NotMask = 1 , } impl From < Msk1 > for bool { # [inline (always)] fn from (variant : Msk1) -> Self { variant as u8 != 0 } } # [doc = "Field `MSK1` reader - Alarm seconds mask"] pub type Msk1R = crate :: BitReader < Msk1 > ; impl Msk1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Msk1 { match self . bits { false => Msk1 :: Mask , true => Msk1 :: NotMask , } } # [doc = "Alarm set if the date/day match"] # [inline (always)] pub fn is_mask (& self) -> bool { * self == Msk1 :: Mask } # [doc = "Date/day don’t care in Alarm comparison"] # [inline (always)] pub fn is_not_mask (& self) -> bool { * self == Msk1 :: NotMask } } # [doc = "Field `MSK1` writer - Alarm seconds mask"] pub type Msk1W < 'a , REG > = crate :: BitWriter < 'a , REG , Msk1 > ; impl < 'a , REG > Msk1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Alarm set if the date/day match"] # [inline (always)] pub fn mask (self) -> & 'a mut crate :: W < REG > { self . variant (Msk1 :: Mask) } # [doc = "Date/day don’t care in Alarm comparison"] # [inline (always)] pub fn not_mask (self) -> & 'a mut crate :: W < REG > { self . variant (Msk1 :: NotMask) } } # [doc = "Field `MNU` reader - Minute units in BCD format"] pub type MnuR = crate :: FieldReader ; # [doc = "Field `MNU` writer - Minute units in BCD format"] pub type MnuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `MNT` reader - Minute tens in BCD format"] pub type MntR = crate :: FieldReader ; # [doc = "Field `MNT` writer - Minute tens in BCD format"] pub type MntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , u8 , crate :: Safe > ; # [doc = "Field `MSK2` reader - Alarm minutes mask"] pub use Msk1R as Msk2R ; # [doc = "Field `MSK2` writer - Alarm minutes mask"] pub use Msk1W as Msk2W ; # [doc = "Field `HU` reader - Hour units in BCD format"] pub type HuR = crate :: FieldReader ; # [doc = "Field `HU` writer - Hour units in BCD format"] pub type HuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `HT` reader - Hour tens in BCD format"] pub type HtR = crate :: FieldReader ; # [doc = "Field `HT` writer - Hour tens in BCD format"] pub type HtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , u8 , crate :: Safe > ; # [doc = "AM/PM notation\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pm { # [doc = "0: AM or 24-hour format"] Am = 0 , # [doc = "1: PM"] Pm = 1 , } impl From < Pm > for bool { # [inline (always)] fn from (variant : Pm) -> Self { variant as u8 != 0 } } # [doc = "Field `PM` reader - AM/PM notation"] pub type PmR = crate :: BitReader < Pm > ; impl PmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pm { match self . bits { false => Pm :: Am , true => Pm :: Pm , } } # [doc = "AM or 24-hour format"] # [inline (always)] pub fn is_am (& self) -> bool { * self == Pm :: Am } # [doc = "PM"] # [inline (always)] pub fn is_pm (& self) -> bool { * self == Pm :: Pm } } # [doc = "Field `PM` writer - AM/PM notation"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG , Pm > ; impl < 'a , REG > PmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "AM or 24-hour format"] # [inline (always)] pub fn am (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Am) } # [doc = "PM"] # [inline (always)] pub fn pm (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Pm) } } # [doc = "Field `MSK3` reader - Alarm hours mask"] pub use Msk1R as Msk3R ; # [doc = "Field `MSK3` writer - Alarm hours mask"] pub use Msk1W as Msk3W ; # [doc = "Field `DU` reader - Date units or day in BCD format"] pub type DuR = crate :: FieldReader ; # [doc = "Field `DU` writer - Date units or day in BCD format"] pub type DuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `DT` reader - Date tens in BCD format"] pub type DtR = crate :: FieldReader ; # [doc = "Field `DT` writer - Date tens in BCD format"] pub type DtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , u8 , crate :: Safe > ; # [doc = "Week day selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wdsel { # [doc = "0: DU\\[3:0\\] represents the date units"] DateUnits = 0 , # [doc = "1: DU\\[3:0\\] represents the week day. DT\\[1:0\\] is don’t care."] WeekDay = 1 , } impl From < Wdsel > for bool { # [inline (always)] fn from (variant : Wdsel) -> Self { variant as u8 != 0 } } # [doc = "Field `WDSEL` reader - Week day selection"] pub type WdselR = crate :: BitReader < Wdsel > ; impl WdselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wdsel { match self . bits { false => Wdsel :: DateUnits , true => Wdsel :: WeekDay , } } # [doc = "DU\\[3:0\\] represents the date units"] # [inline (always)] pub fn is_date_units (& self) -> bool { * self == Wdsel :: DateUnits } # [doc = "DU\\[3:0\\] represents the week day. DT\\[1:0\\] is don’t care."] # [inline (always)] pub fn is_week_day (& self) -> bool { * self == Wdsel :: WeekDay } } # [doc = "Field `WDSEL` writer - Week day selection"] pub type WdselW < 'a , REG > = crate :: BitWriter < 'a , REG , Wdsel > ; impl < 'a , REG > WdselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DU\\[3:0\\] represents the date units"] # [inline (always)] pub fn date_units (self) -> & 'a mut crate :: W < REG > { self . variant (Wdsel :: DateUnits) } # [doc = "DU\\[3:0\\] represents the week day. DT\\[1:0\\] is don’t care."] # [inline (always)] pub fn week_day (self) -> & 'a mut crate :: W < REG > { self . variant (Wdsel :: WeekDay) } } # [doc = "Field `MSK4` reader - Alarm date mask"] pub use Msk1R as Msk4R ; # [doc = "Field `MSK4` writer - Alarm date mask"] pub use Msk1W as Msk4W ; impl R { # [doc = "Bits 0:3 - Second units in BCD format"] # [inline (always)] pub fn su (& self) -> SuR { SuR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:6 - Second tens in BCD format"] # [inline (always)] pub fn st (& self) -> StR { StR :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bit 7 - Alarm seconds mask"] # [inline (always)] pub fn msk1 (& self) -> Msk1R { Msk1R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Minute units in BCD format"] # [inline (always)] pub fn mnu (& self) -> MnuR { MnuR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bits 12:14 - Minute tens in BCD format"] # [inline (always)] pub fn mnt (& self) -> MntR { MntR :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bit 15 - Alarm minutes mask"] # [inline (always)] pub fn msk2 (& self) -> Msk2R { Msk2R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:19 - Hour units in BCD format"] # [inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:21 - Hour tens in BCD format"] # [inline (always)] pub fn ht (& self) -> HtR { HtR :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bit 22 - AM/PM notation"] # [inline (always)] pub fn pm (& self) -> PmR { PmR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Alarm hours mask"] # [inline (always)] pub fn msk3 (& self) -> Msk3R { Msk3R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:27 - Date units or day in BCD format"] # [inline (always)] pub fn du (& self) -> DuR { DuR :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:29 - Date tens in BCD format"] # [inline (always)] pub fn dt (& self) -> DtR { DtR :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bit 30 - Week day selection"] # [inline (always)] pub fn wdsel (& self) -> WdselR { WdselR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Alarm date mask"] # [inline (always)] pub fn msk4 (& self) -> Msk4R { Msk4R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Second units in BCD format"] # [inline (always)] pub fn su (& mut self) -> SuW < AlrmrSpec > { SuW :: new (self , 0) } # [doc = "Bits 4:6 - Second tens in BCD format"] # [inline (always)] pub fn st (& mut self) -> StW < AlrmrSpec > { StW :: new (self , 4) } # [doc = "Bit 7 - Alarm seconds mask"] # [inline (always)] pub fn msk1 (& mut self) -> Msk1W < AlrmrSpec > { Msk1W :: new (self , 7) } # [doc = "Bits 8:11 - Minute units in BCD format"] # [inline (always)] pub fn mnu (& mut self) -> MnuW < AlrmrSpec > { MnuW :: new (self , 8) } # [doc = "Bits 12:14 - Minute tens in BCD format"] # [inline (always)] pub fn mnt (& mut self) -> MntW < AlrmrSpec > { MntW :: new (self , 12) } # [doc = "Bit 15 - Alarm minutes mask"] # [inline (always)] pub fn msk2 (& mut self) -> Msk2W < AlrmrSpec > { Msk2W :: new (self , 15) } # [doc = "Bits 16:19 - Hour units in BCD format"] # [inline (always)] pub fn hu (& mut self) -> HuW < AlrmrSpec > { HuW :: new (self , 16) } # [doc = "Bits 20:21 - Hour tens in BCD format"] # [inline (always)] pub fn ht (& mut self) -> HtW < AlrmrSpec > { HtW :: new (self , 20) } # [doc = "Bit 22 - AM/PM notation"] # [inline (always)] pub fn pm (& mut self) -> PmW < AlrmrSpec > { PmW :: new (self , 22) } # [doc = "Bit 23 - Alarm hours mask"] # [inline (always)] pub fn msk3 (& mut self) -> Msk3W < AlrmrSpec > { Msk3W :: new (self , 23) } # [doc = "Bits 24:27 - Date units or day in BCD format"] # [inline (always)] pub fn du (& mut self) -> DuW < AlrmrSpec > { DuW :: new (self , 24) } # [doc = "Bits 28:29 - Date tens in BCD format"] # [inline (always)] pub fn dt (& mut self) -> DtW < AlrmrSpec > { DtW :: new (self , 28) } # [doc = "Bit 30 - Week day selection"] # [inline (always)] pub fn wdsel (& mut self) -> WdselW < AlrmrSpec > { WdselW :: new (self , 30) } # [doc = "Bit 31 - Alarm date mask"] # [inline (always)] pub fn msk4 (& mut self) -> Msk4W < AlrmrSpec > { Msk4W :: new (self , 31) } } # [doc = "Alarm %s register\n\nYou can [`read`](crate::Reg::read) this register and get [`alrmr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`alrmr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AlrmrSpec ; impl crate :: RegisterSpec for AlrmrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`alrmr::R`](R) reader structure"] impl crate :: Readable for AlrmrSpec { } # [doc = "`write(|w| ..)` method takes [`alrmr::W`](W) writer structure"] impl crate :: Writable for AlrmrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets ALRM%sR to value 0"] impl crate :: Resettable for AlrmrSpec { }
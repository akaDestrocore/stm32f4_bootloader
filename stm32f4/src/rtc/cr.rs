# [doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ; # [doc = "Wakeup clock selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Wucksel { # [doc = "0: RTC/16 clock is selected"] Div16 = 0 , # [doc = "1: RTC/8 clock is selected"] Div8 = 1 , # [doc = "2: RTC/4 clock is selected"] Div4 = 2 , # [doc = "3: RTC/2 clock is selected"] Div2 = 3 , # [doc = "4: ck_spre (usually 1 Hz) clock is selected"] ClockSpare = 4 , # [doc = "6: ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value"] ClockSpareWithOffset = 6 , } impl From < Wucksel > for u8 { # [inline (always)] fn from (variant : Wucksel) -> Self { variant as _ } } impl crate :: FieldSpec for Wucksel { type Ux = u8 ; } impl crate :: IsEnum for Wucksel { } # [doc = "Field `WUCKSEL` reader - Wakeup clock selection"] pub type WuckselR = crate :: FieldReader < Wucksel > ; impl WuckselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Wucksel > { match self . bits { 0 => Some (Wucksel :: Div16) , 1 => Some (Wucksel :: Div8) , 2 => Some (Wucksel :: Div4) , 3 => Some (Wucksel :: Div2) , 4 => Some (Wucksel :: ClockSpare) , 6 => Some (Wucksel :: ClockSpareWithOffset) , _ => None , } } # [doc = "RTC/16 clock is selected"] # [inline (always)] pub fn is_div16 (& self) -> bool { * self == Wucksel :: Div16 } # [doc = "RTC/8 clock is selected"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Wucksel :: Div8 } # [doc = "RTC/4 clock is selected"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Wucksel :: Div4 } # [doc = "RTC/2 clock is selected"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Wucksel :: Div2 } # [doc = "ck_spre (usually 1 Hz) clock is selected"] # [inline (always)] pub fn is_clock_spare (& self) -> bool { * self == Wucksel :: ClockSpare } # [doc = "ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value"] # [inline (always)] pub fn is_clock_spare_with_offset (& self) -> bool { * self == Wucksel :: ClockSpareWithOffset } } # [doc = "Field `WUCKSEL` writer - Wakeup clock selection"] pub type WuckselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Wucksel > ; impl < 'a , REG > WuckselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "RTC/16 clock is selected"] # [inline (always)] pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: Div16) } # [doc = "RTC/8 clock is selected"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: Div8) } # [doc = "RTC/4 clock is selected"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: Div4) } # [doc = "RTC/2 clock is selected"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: Div2) } # [doc = "ck_spre (usually 1 Hz) clock is selected"] # [inline (always)] pub fn clock_spare (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: ClockSpare) } # [doc = "ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value"] # [inline (always)] pub fn clock_spare_with_offset (self) -> & 'a mut crate :: W < REG > { self . variant (Wucksel :: ClockSpareWithOffset) } } # [doc = "Time-stamp event active edge\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tsedge { # [doc = "0: RTC_TS input rising edge generates a time-stamp event"] RisingEdge = 0 , # [doc = "1: RTC_TS input falling edge generates a time-stamp event"] FallingEdge = 1 , } impl From < Tsedge > for bool { # [inline (always)] fn from (variant : Tsedge) -> Self { variant as u8 != 0 } } # [doc = "Field `TSEDGE` reader - Time-stamp event active edge"] pub type TsedgeR = crate :: BitReader < Tsedge > ; impl TsedgeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsedge { match self . bits { false => Tsedge :: RisingEdge , true => Tsedge :: FallingEdge , } } # [doc = "RTC_TS input rising edge generates a time-stamp event"] # [inline (always)] pub fn is_rising_edge (& self) -> bool { * self == Tsedge :: RisingEdge } # [doc = "RTC_TS input falling edge generates a time-stamp event"] # [inline (always)] pub fn is_falling_edge (& self) -> bool { * self == Tsedge :: FallingEdge } } # [doc = "Field `TSEDGE` writer - Time-stamp event active edge"] pub type TsedgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Tsedge > ; impl < 'a , REG > TsedgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RTC_TS input rising edge generates a time-stamp event"] # [inline (always)] pub fn rising_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Tsedge :: RisingEdge) } # [doc = "RTC_TS input falling edge generates a time-stamp event"] # [inline (always)] pub fn falling_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Tsedge :: FallingEdge) } } # [doc = "Reference clock detection enable (50 or 60 Hz)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Refckon { # [doc = "0: RTC_REFIN detection disabled"] Disabled = 0 , # [doc = "1: RTC_REFIN detection enabled"] Enabled = 1 , } impl From < Refckon > for bool { # [inline (always)] fn from (variant : Refckon) -> Self { variant as u8 != 0 } } # [doc = "Field `REFCKON` reader - Reference clock detection enable (50 or 60 Hz)"] pub type RefckonR = crate :: BitReader < Refckon > ; impl RefckonR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Refckon { match self . bits { false => Refckon :: Disabled , true => Refckon :: Enabled , } } # [doc = "RTC_REFIN detection disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Refckon :: Disabled } # [doc = "RTC_REFIN detection enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Refckon :: Enabled } } # [doc = "Field `REFCKON` writer - Reference clock detection enable (50 or 60 Hz)"] pub type RefckonW < 'a , REG > = crate :: BitWriter < 'a , REG , Refckon > ; impl < 'a , REG > RefckonW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RTC_REFIN detection disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Refckon :: Disabled) } # [doc = "RTC_REFIN detection enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Refckon :: Enabled) } } # [doc = "Bypass the shadow registers\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bypshad { # [doc = "0: Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles"] ShadowReg = 0 , # [doc = "1: Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters"] BypassShadowReg = 1 , } impl From < Bypshad > for bool { # [inline (always)] fn from (variant : Bypshad) -> Self { variant as u8 != 0 } } # [doc = "Field `BYPSHAD` reader - Bypass the shadow registers"] pub type BypshadR = crate :: BitReader < Bypshad > ; impl BypshadR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bypshad { match self . bits { false => Bypshad :: ShadowReg , true => Bypshad :: BypassShadowReg , } } # [doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles"] # [inline (always)] pub fn is_shadow_reg (& self) -> bool { * self == Bypshad :: ShadowReg } # [doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters"] # [inline (always)] pub fn is_bypass_shadow_reg (& self) -> bool { * self == Bypshad :: BypassShadowReg } } # [doc = "Field `BYPSHAD` writer - Bypass the shadow registers"] pub type BypshadW < 'a , REG > = crate :: BitWriter < 'a , REG , Bypshad > ; impl < 'a , REG > BypshadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles"] # [inline (always)] pub fn shadow_reg (self) -> & 'a mut crate :: W < REG > { self . variant (Bypshad :: ShadowReg) } # [doc = "Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters"] # [inline (always)] pub fn bypass_shadow_reg (self) -> & 'a mut crate :: W < REG > { self . variant (Bypshad :: BypassShadowReg) } } # [doc = "Hour format\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fmt { # [doc = "0: 24 hour/day format"] TwentyFourHour = 0 , # [doc = "1: AM/PM hour format"] AmPm = 1 , } impl From < Fmt > for bool { # [inline (always)] fn from (variant : Fmt) -> Self { variant as u8 != 0 } } # [doc = "Field `FMT` reader - Hour format"] pub type FmtR = crate :: BitReader < Fmt > ; impl FmtR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fmt { match self . bits { false => Fmt :: TwentyFourHour , true => Fmt :: AmPm , } } # [doc = "24 hour/day format"] # [inline (always)] pub fn is_twenty_four_hour (& self) -> bool { * self == Fmt :: TwentyFourHour } # [doc = "AM/PM hour format"] # [inline (always)] pub fn is_am_pm (& self) -> bool { * self == Fmt :: AmPm } } # [doc = "Field `FMT` writer - Hour format"] pub type FmtW < 'a , REG > = crate :: BitWriter < 'a , REG , Fmt > ; impl < 'a , REG > FmtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "24 hour/day format"] # [inline (always)] pub fn twenty_four_hour (self) -> & 'a mut crate :: W < REG > { self . variant (Fmt :: TwentyFourHour) } # [doc = "AM/PM hour format"] # [inline (always)] pub fn am_pm (self) -> & 'a mut crate :: W < REG > { self . variant (Fmt :: AmPm) } } # [doc = "Field `DCE` reader - Coarse digital calibration enable"] pub type DceR = crate :: BitReader ; # [doc = "Field `DCE` writer - Coarse digital calibration enable"] pub type DceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Alarm %s enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Alrae { # [doc = "0: Alarm disabled"] Disabled = 0 , # [doc = "1: Alarm enabled"] Enabled = 1 , } impl From < Alrae > for bool { # [inline (always)] fn from (variant : Alrae) -> Self { variant as u8 != 0 } } # [doc = "Field `ALRE(A,B)` reader - Alarm %s enable"] pub type AlreR = crate :: BitReader < Alrae > ; impl AlreR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Alrae { match self . bits { false => Alrae :: Disabled , true => Alrae :: Enabled , } } # [doc = "Alarm disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Alrae :: Disabled } # [doc = "Alarm enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Alrae :: Enabled } } # [doc = "Field `ALRE(A,B)` writer - Alarm %s enable"] pub type AlreW < 'a , REG > = crate :: BitWriter < 'a , REG , Alrae > ; impl < 'a , REG > AlreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Alarm disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Alrae :: Disabled) } # [doc = "Alarm enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Alrae :: Enabled) } } # [doc = "Wakeup timer enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wute { # [doc = "0: Wakeup timer disabled"] Disabled = 0 , # [doc = "1: Wakeup timer enabled"] Enabled = 1 , } impl From < Wute > for bool { # [inline (always)] fn from (variant : Wute) -> Self { variant as u8 != 0 } } # [doc = "Field `WUTE` reader - Wakeup timer enable"] pub type WuteR = crate :: BitReader < Wute > ; impl WuteR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wute { match self . bits { false => Wute :: Disabled , true => Wute :: Enabled , } } # [doc = "Wakeup timer disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Wute :: Disabled } # [doc = "Wakeup timer enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Wute :: Enabled } } # [doc = "Field `WUTE` writer - Wakeup timer enable"] pub type WuteW < 'a , REG > = crate :: BitWriter < 'a , REG , Wute > ; impl < 'a , REG > WuteW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Wakeup timer disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wute :: Disabled) } # [doc = "Wakeup timer enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wute :: Enabled) } } # [doc = "Time stamp enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tse { # [doc = "0: Timestamp disabled"] Disabled = 0 , # [doc = "1: Timestamp enabled"] Enabled = 1 , } impl From < Tse > for bool { # [inline (always)] fn from (variant : Tse) -> Self { variant as u8 != 0 } } # [doc = "Field `TSE` reader - Time stamp enable"] pub type TseR = crate :: BitReader < Tse > ; impl TseR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tse { match self . bits { false => Tse :: Disabled , true => Tse :: Enabled , } } # [doc = "Timestamp disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Tse :: Disabled } # [doc = "Timestamp enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Tse :: Enabled } } # [doc = "Field `TSE` writer - Time stamp enable"] pub type TseW < 'a , REG > = crate :: BitWriter < 'a , REG , Tse > ; impl < 'a , REG > TseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Timestamp disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tse :: Disabled) } # [doc = "Timestamp enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tse :: Enabled) } } # [doc = "Alarm %s interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Alraie { # [doc = "0: Alarm Interrupt disabled"] Disabled = 0 , # [doc = "1: Alarm Interrupt enabled"] Enabled = 1 , } impl From < Alraie > for bool { # [inline (always)] fn from (variant : Alraie) -> Self { variant as u8 != 0 } } # [doc = "Field `ALRIE(A,B)` reader - Alarm %s interrupt enable"] pub type AlrieR = crate :: BitReader < Alraie > ; impl AlrieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Alraie { match self . bits { false => Alraie :: Disabled , true => Alraie :: Enabled , } } # [doc = "Alarm Interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Alraie :: Disabled } # [doc = "Alarm Interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Alraie :: Enabled } } # [doc = "Field `ALRIE(A,B)` writer - Alarm %s interrupt enable"] pub type AlrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Alraie > ; impl < 'a , REG > AlrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Alarm Interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Alraie :: Disabled) } # [doc = "Alarm Interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Alraie :: Enabled) } } # [doc = "Wakeup timer interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wutie { # [doc = "0: Wakeup timer interrupt disabled"] Disabled = 0 , # [doc = "1: Wakeup timer interrupt enabled"] Enabled = 1 , } impl From < Wutie > for bool { # [inline (always)] fn from (variant : Wutie) -> Self { variant as u8 != 0 } } # [doc = "Field `WUTIE` reader - Wakeup timer interrupt enable"] pub type WutieR = crate :: BitReader < Wutie > ; impl WutieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wutie { match self . bits { false => Wutie :: Disabled , true => Wutie :: Enabled , } } # [doc = "Wakeup timer interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Wutie :: Disabled } # [doc = "Wakeup timer interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Wutie :: Enabled } } # [doc = "Field `WUTIE` writer - Wakeup timer interrupt enable"] pub type WutieW < 'a , REG > = crate :: BitWriter < 'a , REG , Wutie > ; impl < 'a , REG > WutieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Wakeup timer interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wutie :: Disabled) } # [doc = "Wakeup timer interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wutie :: Enabled) } } # [doc = "Time-stamp interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Tsie { # [doc = "0: Time-stamp Interrupt disabled"] Disabled = 0 , # [doc = "1: Time-stamp Interrupt enabled"] Enabled = 1 , } impl From < Tsie > for bool { # [inline (always)] fn from (variant : Tsie) -> Self { variant as u8 != 0 } } # [doc = "Field `TSIE` reader - Time-stamp interrupt enable"] pub type TsieR = crate :: BitReader < Tsie > ; impl TsieR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsie { match self . bits { false => Tsie :: Disabled , true => Tsie :: Enabled , } } # [doc = "Time-stamp Interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Tsie :: Disabled } # [doc = "Time-stamp Interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Tsie :: Enabled } } # [doc = "Field `TSIE` writer - Time-stamp interrupt enable"] pub type TsieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tsie > ; impl < 'a , REG > TsieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Time-stamp Interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tsie :: Disabled) } # [doc = "Time-stamp Interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Tsie :: Enabled) } } # [doc = "Add 1 hour (summer time change)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Add1hw { # [doc = "1: Adds 1 hour to the current time. This can be used for summer time change outside initialization mode"] Add1 = 1 , } impl From < Add1hw > for bool { # [inline (always)] fn from (variant : Add1hw) -> Self { variant as u8 != 0 } } # [doc = "Field `ADD1H` reader - Add 1 hour (summer time change)"] pub type Add1hR = crate :: BitReader < Add1hw > ; impl Add1hR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Add1hw > { match self . bits { true => Some (Add1hw :: Add1) , _ => None , } } # [doc = "Adds 1 hour to the current time. This can be used for summer time change outside initialization mode"] # [inline (always)] pub fn is_add1 (& self) -> bool { * self == Add1hw :: Add1 } } # [doc = "Field `ADD1H` writer - Add 1 hour (summer time change)"] pub type Add1hW < 'a , REG > = crate :: BitWriter < 'a , REG , Add1hw > ; impl < 'a , REG > Add1hW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Adds 1 hour to the current time. This can be used for summer time change outside initialization mode"] # [inline (always)] pub fn add1 (self) -> & 'a mut crate :: W < REG > { self . variant (Add1hw :: Add1) } } # [doc = "Subtract 1 hour (winter time change)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sub1hw { # [doc = "1: Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode"] Sub1 = 1 , } impl From < Sub1hw > for bool { # [inline (always)] fn from (variant : Sub1hw) -> Self { variant as u8 != 0 } } # [doc = "Field `SUB1H` reader - Subtract 1 hour (winter time change)"] pub type Sub1hR = crate :: BitReader < Sub1hw > ; impl Sub1hR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Sub1hw > { match self . bits { true => Some (Sub1hw :: Sub1) , _ => None , } } # [doc = "Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode"] # [inline (always)] pub fn is_sub1 (& self) -> bool { * self == Sub1hw :: Sub1 } } # [doc = "Field `SUB1H` writer - Subtract 1 hour (winter time change)"] pub type Sub1hW < 'a , REG > = crate :: BitWriter < 'a , REG , Sub1hw > ; impl < 'a , REG > Sub1hW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode"] # [inline (always)] pub fn sub1 (self) -> & 'a mut crate :: W < REG > { self . variant (Sub1hw :: Sub1) } } # [doc = "Backup\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bkp { # [doc = "0: Daylight Saving Time change has not been performed"] DstNotChanged = 0 , # [doc = "1: Daylight Saving Time change has been performed"] DstChanged = 1 , } impl From < Bkp > for bool { # [inline (always)] fn from (variant : Bkp) -> Self { variant as u8 != 0 } } # [doc = "Field `BKP` reader - Backup"] pub type BkpR = crate :: BitReader < Bkp > ; impl BkpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bkp { match self . bits { false => Bkp :: DstNotChanged , true => Bkp :: DstChanged , } } # [doc = "Daylight Saving Time change has not been performed"] # [inline (always)] pub fn is_dst_not_changed (& self) -> bool { * self == Bkp :: DstNotChanged } # [doc = "Daylight Saving Time change has been performed"] # [inline (always)] pub fn is_dst_changed (& self) -> bool { * self == Bkp :: DstChanged } } # [doc = "Field `BKP` writer - Backup"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG , Bkp > ; impl < 'a , REG > BkpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Daylight Saving Time change has not been performed"] # [inline (always)] pub fn dst_not_changed (self) -> & 'a mut crate :: W < REG > { self . variant (Bkp :: DstNotChanged) } # [doc = "Daylight Saving Time change has been performed"] # [inline (always)] pub fn dst_changed (self) -> & 'a mut crate :: W < REG > { self . variant (Bkp :: DstChanged) } } # [doc = "Calibration output selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cosel { # [doc = "0: Calibration output is 512 Hz (with default prescaler setting)"] CalFreq512hz = 0 , # [doc = "1: Calibration output is 1 Hz (with default prescaler setting)"] CalFreq1hz = 1 , } impl From < Cosel > for bool { # [inline (always)] fn from (variant : Cosel) -> Self { variant as u8 != 0 } } # [doc = "Field `COSEL` reader - Calibration output selection"] pub type CoselR = crate :: BitReader < Cosel > ; impl CoselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cosel { match self . bits { false => Cosel :: CalFreq512hz , true => Cosel :: CalFreq1hz , } } # [doc = "Calibration output is 512 Hz (with default prescaler setting)"] # [inline (always)] pub fn is_cal_freq_512hz (& self) -> bool { * self == Cosel :: CalFreq512hz } # [doc = "Calibration output is 1 Hz (with default prescaler setting)"] # [inline (always)] pub fn is_cal_freq_1hz (& self) -> bool { * self == Cosel :: CalFreq1hz } } # [doc = "Field `COSEL` writer - Calibration output selection"] pub type CoselW < 'a , REG > = crate :: BitWriter < 'a , REG , Cosel > ; impl < 'a , REG > CoselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Calibration output is 512 Hz (with default prescaler setting)"] # [inline (always)] pub fn cal_freq_512hz (self) -> & 'a mut crate :: W < REG > { self . variant (Cosel :: CalFreq512hz) } # [doc = "Calibration output is 1 Hz (with default prescaler setting)"] # [inline (always)] pub fn cal_freq_1hz (self) -> & 'a mut crate :: W < REG > { self . variant (Cosel :: CalFreq1hz) } } # [doc = "Output polarity\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pol { # [doc = "0: The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] High = 0 , # [doc = "1: The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] Low = 1 , } impl From < Pol > for bool { # [inline (always)] fn from (variant : Pol) -> Self { variant as u8 != 0 } } # [doc = "Field `POL` reader - Output polarity"] pub type PolR = crate :: BitReader < Pol > ; impl PolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pol { match self . bits { false => Pol :: High , true => Pol :: Low , } } # [doc = "The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] # [inline (always)] pub fn is_high (& self) -> bool { * self == Pol :: High } # [doc = "The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] # [inline (always)] pub fn is_low (& self) -> bool { * self == Pol :: Low } } # [doc = "Field `POL` writer - Output polarity"] pub type PolW < 'a , REG > = crate :: BitWriter < 'a , REG , Pol > ; impl < 'a , REG > PolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] # [inline (always)] pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Pol :: High) } # [doc = "The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL\\[1:0\\])"] # [inline (always)] pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Pol :: Low) } } # [doc = "Output selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Osel { # [doc = "0: Output disabled"] Disabled = 0 , # [doc = "1: Alarm A output enabled"] AlarmA = 1 , # [doc = "2: Alarm B output enabled"] AlarmB = 2 , # [doc = "3: Wakeup output enabled"] Wakeup = 3 , } impl From < Osel > for u8 { # [inline (always)] fn from (variant : Osel) -> Self { variant as _ } } impl crate :: FieldSpec for Osel { type Ux = u8 ; } impl crate :: IsEnum for Osel { } # [doc = "Field `OSEL` reader - Output selection"] pub type OselR = crate :: FieldReader < Osel > ; impl OselR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Osel { match self . bits { 0 => Osel :: Disabled , 1 => Osel :: AlarmA , 2 => Osel :: AlarmB , 3 => Osel :: Wakeup , _ => unreachable ! () , } } # [doc = "Output disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Osel :: Disabled } # [doc = "Alarm A output enabled"] # [inline (always)] pub fn is_alarm_a (& self) -> bool { * self == Osel :: AlarmA } # [doc = "Alarm B output enabled"] # [inline (always)] pub fn is_alarm_b (& self) -> bool { * self == Osel :: AlarmB } # [doc = "Wakeup output enabled"] # [inline (always)] pub fn is_wakeup (& self) -> bool { * self == Osel :: Wakeup } } # [doc = "Field `OSEL` writer - Output selection"] pub type OselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Osel , crate :: Safe > ; impl < 'a , REG > OselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Output disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Osel :: Disabled) } # [doc = "Alarm A output enabled"] # [inline (always)] pub fn alarm_a (self) -> & 'a mut crate :: W < REG > { self . variant (Osel :: AlarmA) } # [doc = "Alarm B output enabled"] # [inline (always)] pub fn alarm_b (self) -> & 'a mut crate :: W < REG > { self . variant (Osel :: AlarmB) } # [doc = "Wakeup output enabled"] # [inline (always)] pub fn wakeup (self) -> & 'a mut crate :: W < REG > { self . variant (Osel :: Wakeup) } } # [doc = "Calibration output enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Coe { # [doc = "0: Calibration output disabled"] Disabled = 0 , # [doc = "1: Calibration output enabled"] Enabled = 1 , } impl From < Coe > for bool { # [inline (always)] fn from (variant : Coe) -> Self { variant as u8 != 0 } } # [doc = "Field `COE` reader - Calibration output enable"] pub type CoeR = crate :: BitReader < Coe > ; impl CoeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Coe { match self . bits { false => Coe :: Disabled , true => Coe :: Enabled , } } # [doc = "Calibration output disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Coe :: Disabled } # [doc = "Calibration output enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Coe :: Enabled } } # [doc = "Field `COE` writer - Calibration output enable"] pub type CoeW < 'a , REG > = crate :: BitWriter < 'a , REG , Coe > ; impl < 'a , REG > CoeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Calibration output disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Coe :: Disabled) } # [doc = "Calibration output enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Coe :: Enabled) } } impl R { # [doc = "Bits 0:2 - Wakeup clock selection"] # [inline (always)] pub fn wucksel (& self) -> WuckselR { WuckselR :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - Time-stamp event active edge"] # [inline (always)] pub fn tsedge (& self) -> TsedgeR { TsedgeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)"] # [inline (always)] pub fn refckon (& self) -> RefckonR { RefckonR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Bypass the shadow registers"] # [inline (always)] pub fn bypshad (& self) -> BypshadR { BypshadR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Hour format"] # [inline (always)] pub fn fmt (& self) -> FmtR { FmtR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Coarse digital calibration enable"] # [inline (always)] pub fn dce (& self) -> DceR { DceR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Alarm (A,B) enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `ALRAE` field.</div>"] # [inline (always)] pub fn alre (& self , n : u8) -> AlreR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; AlreR :: new (((self . bits >> (n + 8)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Alarm (A,B) enable"] # [inline (always)] pub fn alre_iter (& self) -> impl Iterator < Item = AlreR > + '_ { (0 .. 2) . map (move | n | AlreR :: new (((self . bits >> (n + 8)) & 1) != 0)) } # [doc = "Bit 8 - Alarm A enable"] # [inline (always)] pub fn alrae (& self) -> AlreR { AlreR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Alarm B enable"] # [inline (always)] pub fn alrbe (& self) -> AlreR { AlreR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Wakeup timer enable"] # [inline (always)] pub fn wute (& self) -> WuteR { WuteR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Time stamp enable"] # [inline (always)] pub fn tse (& self) -> TseR { TseR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Alarm (A,B) interrupt enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `ALRAIE` field.</div>"] # [inline (always)] pub fn alrie (& self , n : u8) -> AlrieR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; AlrieR :: new (((self . bits >> (n + 12)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Alarm (A,B) interrupt enable"] # [inline (always)] pub fn alrie_iter (& self) -> impl Iterator < Item = AlrieR > + '_ { (0 .. 2) . map (move | n | AlrieR :: new (((self . bits >> (n + 12)) & 1) != 0)) } # [doc = "Bit 12 - Alarm A interrupt enable"] # [inline (always)] pub fn alraie (& self) -> AlrieR { AlrieR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Alarm B interrupt enable"] # [inline (always)] pub fn alrbie (& self) -> AlrieR { AlrieR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Wakeup timer interrupt enable"] # [inline (always)] pub fn wutie (& self) -> WutieR { WutieR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Time-stamp interrupt enable"] # [inline (always)] pub fn tsie (& self) -> TsieR { TsieR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Add 1 hour (summer time change)"] # [inline (always)] pub fn add1h (& self) -> Add1hR { Add1hR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Subtract 1 hour (winter time change)"] # [inline (always)] pub fn sub1h (& self) -> Sub1hR { Sub1hR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Backup"] # [inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Calibration output selection"] # [inline (always)] pub fn cosel (& self) -> CoselR { CoselR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Output polarity"] # [inline (always)] pub fn pol (& self) -> PolR { PolR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bits 21:22 - Output selection"] # [inline (always)] pub fn osel (& self) -> OselR { OselR :: new (((self . bits >> 21) & 3) as u8) } # [doc = "Bit 23 - Calibration output enable"] # [inline (always)] pub fn coe (& self) -> CoeR { CoeR :: new (((self . bits >> 23) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Wakeup clock selection"] # [inline (always)] pub fn wucksel (& mut self) -> WuckselW < CrSpec > { WuckselW :: new (self , 0) } # [doc = "Bit 3 - Time-stamp event active edge"] # [inline (always)] pub fn tsedge (& mut self) -> TsedgeW < CrSpec > { TsedgeW :: new (self , 3) } # [doc = "Bit 4 - Reference clock detection enable (50 or 60 Hz)"] # [inline (always)] pub fn refckon (& mut self) -> RefckonW < CrSpec > { RefckonW :: new (self , 4) } # [doc = "Bit 5 - Bypass the shadow registers"] # [inline (always)] pub fn bypshad (& mut self) -> BypshadW < CrSpec > { BypshadW :: new (self , 5) } # [doc = "Bit 6 - Hour format"] # [inline (always)] pub fn fmt (& mut self) -> FmtW < CrSpec > { FmtW :: new (self , 6) } # [doc = "Bit 7 - Coarse digital calibration enable"] # [inline (always)] pub fn dce (& mut self) -> DceW < CrSpec > { DceW :: new (self , 7) } # [doc = "Alarm (A,B) enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `ALRAE` field.</div>"] # [inline (always)] pub fn alre (& mut self , n : u8) -> AlreW < CrSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; AlreW :: new (self , n + 8) } # [doc = "Bit 8 - Alarm A enable"] # [inline (always)] pub fn alrae (& mut self) -> AlreW < CrSpec > { AlreW :: new (self , 8) } # [doc = "Bit 9 - Alarm B enable"] # [inline (always)] pub fn alrbe (& mut self) -> AlreW < CrSpec > { AlreW :: new (self , 9) } # [doc = "Bit 10 - Wakeup timer enable"] # [inline (always)] pub fn wute (& mut self) -> WuteW < CrSpec > { WuteW :: new (self , 10) } # [doc = "Bit 11 - Time stamp enable"] # [inline (always)] pub fn tse (& mut self) -> TseW < CrSpec > { TseW :: new (self , 11) } # [doc = "Alarm (A,B) interrupt enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `ALRAIE` field.</div>"] # [inline (always)] pub fn alrie (& mut self , n : u8) -> AlrieW < CrSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; AlrieW :: new (self , n + 12) } # [doc = "Bit 12 - Alarm A interrupt enable"] # [inline (always)] pub fn alraie (& mut self) -> AlrieW < CrSpec > { AlrieW :: new (self , 12) } # [doc = "Bit 13 - Alarm B interrupt enable"] # [inline (always)] pub fn alrbie (& mut self) -> AlrieW < CrSpec > { AlrieW :: new (self , 13) } # [doc = "Bit 14 - Wakeup timer interrupt enable"] # [inline (always)] pub fn wutie (& mut self) -> WutieW < CrSpec > { WutieW :: new (self , 14) } # [doc = "Bit 15 - Time-stamp interrupt enable"] # [inline (always)] pub fn tsie (& mut self) -> TsieW < CrSpec > { TsieW :: new (self , 15) } # [doc = "Bit 16 - Add 1 hour (summer time change)"] # [inline (always)] pub fn add1h (& mut self) -> Add1hW < CrSpec > { Add1hW :: new (self , 16) } # [doc = "Bit 17 - Subtract 1 hour (winter time change)"] # [inline (always)] pub fn sub1h (& mut self) -> Sub1hW < CrSpec > { Sub1hW :: new (self , 17) } # [doc = "Bit 18 - Backup"] # [inline (always)] pub fn bkp (& mut self) -> BkpW < CrSpec > { BkpW :: new (self , 18) } # [doc = "Bit 19 - Calibration output selection"] # [inline (always)] pub fn cosel (& mut self) -> CoselW < CrSpec > { CoselW :: new (self , 19) } # [doc = "Bit 20 - Output polarity"] # [inline (always)] pub fn pol (& mut self) -> PolW < CrSpec > { PolW :: new (self , 20) } # [doc = "Bits 21:22 - Output selection"] # [inline (always)] pub fn osel (& mut self) -> OselW < CrSpec > { OselW :: new (self , 21) } # [doc = "Bit 23 - Calibration output enable"] # [inline (always)] pub fn coe (& mut self) -> CoeW < CrSpec > { CoeW :: new (self , 23) } } # [doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { }
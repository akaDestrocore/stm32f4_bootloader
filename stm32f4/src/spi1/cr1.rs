# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Clock phase\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cpha { # [doc = "0: The first clock transition is the first data capture edge"] FirstEdge = 0 , # [doc = "1: The second clock transition is the first data capture edge"] SecondEdge = 1 , } impl From < Cpha > for bool { # [inline (always)] fn from (variant : Cpha) -> Self { variant as u8 != 0 } } # [doc = "Field `CPHA` reader - Clock phase"] pub type CphaR = crate :: BitReader < Cpha > ; impl CphaR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cpha { match self . bits { false => Cpha :: FirstEdge , true => Cpha :: SecondEdge , } } # [doc = "The first clock transition is the first data capture edge"] # [inline (always)] pub fn is_first_edge (& self) -> bool { * self == Cpha :: FirstEdge } # [doc = "The second clock transition is the first data capture edge"] # [inline (always)] pub fn is_second_edge (& self) -> bool { * self == Cpha :: SecondEdge } } # [doc = "Field `CPHA` writer - Clock phase"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpha > ; impl < 'a , REG > CphaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The first clock transition is the first data capture edge"] # [inline (always)] pub fn first_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: FirstEdge) } # [doc = "The second clock transition is the first data capture edge"] # [inline (always)] pub fn second_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: SecondEdge) } } # [doc = "Clock polarity\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cpol { # [doc = "0: CK to 0 when idle"] IdleLow = 0 , # [doc = "1: CK to 1 when idle"] IdleHigh = 1 , } impl From < Cpol > for bool { # [inline (always)] fn from (variant : Cpol) -> Self { variant as u8 != 0 } } # [doc = "Field `CPOL` reader - Clock polarity"] pub type CpolR = crate :: BitReader < Cpol > ; impl CpolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cpol { match self . bits { false => Cpol :: IdleLow , true => Cpol :: IdleHigh , } } # [doc = "CK to 0 when idle"] # [inline (always)] pub fn is_idle_low (& self) -> bool { * self == Cpol :: IdleLow } # [doc = "CK to 1 when idle"] # [inline (always)] pub fn is_idle_high (& self) -> bool { * self == Cpol :: IdleHigh } } # [doc = "Field `CPOL` writer - Clock polarity"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpol > ; impl < 'a , REG > CpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CK to 0 when idle"] # [inline (always)] pub fn idle_low (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: IdleLow) } # [doc = "CK to 1 when idle"] # [inline (always)] pub fn idle_high (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: IdleHigh) } } # [doc = "Master selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mstr { # [doc = "0: Slave configuration"] Slave = 0 , # [doc = "1: Master configuration"] Master = 1 , } impl From < Mstr > for bool { # [inline (always)] fn from (variant : Mstr) -> Self { variant as u8 != 0 } } # [doc = "Field `MSTR` reader - Master selection"] pub type MstrR = crate :: BitReader < Mstr > ; impl MstrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mstr { match self . bits { false => Mstr :: Slave , true => Mstr :: Master , } } # [doc = "Slave configuration"] # [inline (always)] pub fn is_slave (& self) -> bool { * self == Mstr :: Slave } # [doc = "Master configuration"] # [inline (always)] pub fn is_master (& self) -> bool { * self == Mstr :: Master } } # [doc = "Field `MSTR` writer - Master selection"] pub type MstrW < 'a , REG > = crate :: BitWriter < 'a , REG , Mstr > ; impl < 'a , REG > MstrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Slave configuration"] # [inline (always)] pub fn slave (self) -> & 'a mut crate :: W < REG > { self . variant (Mstr :: Slave) } # [doc = "Master configuration"] # [inline (always)] pub fn master (self) -> & 'a mut crate :: W < REG > { self . variant (Mstr :: Master) } } # [doc = "Baud rate control\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Br { # [doc = "0: f_PCLK / 2"] Div2 = 0 , # [doc = "1: f_PCLK / 4"] Div4 = 1 , # [doc = "2: f_PCLK / 8"] Div8 = 2 , # [doc = "3: f_PCLK / 16"] Div16 = 3 , # [doc = "4: f_PCLK / 32"] Div32 = 4 , # [doc = "5: f_PCLK / 64"] Div64 = 5 , # [doc = "6: f_PCLK / 128"] Div128 = 6 , # [doc = "7: f_PCLK / 256"] Div256 = 7 , } impl From < Br > for u8 { # [inline (always)] fn from (variant : Br) -> Self { variant as _ } } impl crate :: FieldSpec for Br { type Ux = u8 ; } impl crate :: IsEnum for Br { } # [doc = "Field `BR` reader - Baud rate control"] pub type BrR = crate :: FieldReader < Br > ; impl BrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Br { match self . bits { 0 => Br :: Div2 , 1 => Br :: Div4 , 2 => Br :: Div8 , 3 => Br :: Div16 , 4 => Br :: Div32 , 5 => Br :: Div64 , 6 => Br :: Div128 , 7 => Br :: Div256 , _ => unreachable ! () , } } # [doc = "f_PCLK / 2"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Br :: Div2 } # [doc = "f_PCLK / 4"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Br :: Div4 } # [doc = "f_PCLK / 8"] # [inline (always)] pub fn is_div8 (& self) -> bool { * self == Br :: Div8 } # [doc = "f_PCLK / 16"] # [inline (always)] pub fn is_div16 (& self) -> bool { * self == Br :: Div16 } # [doc = "f_PCLK / 32"] # [inline (always)] pub fn is_div32 (& self) -> bool { * self == Br :: Div32 } # [doc = "f_PCLK / 64"] # [inline (always)] pub fn is_div64 (& self) -> bool { * self == Br :: Div64 } # [doc = "f_PCLK / 128"] # [inline (always)] pub fn is_div128 (& self) -> bool { * self == Br :: Div128 } # [doc = "f_PCLK / 256"] # [inline (always)] pub fn is_div256 (& self) -> bool { * self == Br :: Div256 } } # [doc = "Field `BR` writer - Baud rate control"] pub type BrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Br , crate :: Safe > ; impl < 'a , REG > BrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "f_PCLK / 2"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div2) } # [doc = "f_PCLK / 4"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div4) } # [doc = "f_PCLK / 8"] # [inline (always)] pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div8) } # [doc = "f_PCLK / 16"] # [inline (always)] pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div16) } # [doc = "f_PCLK / 32"] # [inline (always)] pub fn div32 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div32) } # [doc = "f_PCLK / 64"] # [inline (always)] pub fn div64 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div64) } # [doc = "f_PCLK / 128"] # [inline (always)] pub fn div128 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div128) } # [doc = "f_PCLK / 256"] # [inline (always)] pub fn div256 (self) -> & 'a mut crate :: W < REG > { self . variant (Br :: Div256) } } # [doc = "SPI enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Spe { # [doc = "0: Peripheral disabled"] Disabled = 0 , # [doc = "1: Peripheral enabled"] Enabled = 1 , } impl From < Spe > for bool { # [inline (always)] fn from (variant : Spe) -> Self { variant as u8 != 0 } } # [doc = "Field `SPE` reader - SPI enable"] pub type SpeR = crate :: BitReader < Spe > ; impl SpeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Spe { match self . bits { false => Spe :: Disabled , true => Spe :: Enabled , } } # [doc = "Peripheral disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Spe :: Disabled } # [doc = "Peripheral enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Spe :: Enabled } } # [doc = "Field `SPE` writer - SPI enable"] pub type SpeW < 'a , REG > = crate :: BitWriter < 'a , REG , Spe > ; impl < 'a , REG > SpeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Peripheral disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Spe :: Disabled) } # [doc = "Peripheral enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Spe :: Enabled) } } # [doc = "Frame format\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lsbfirst { # [doc = "0: Data is transmitted/received with the MSB first"] Msbfirst = 0 , # [doc = "1: Data is transmitted/received with the LSB first"] Lsbfirst = 1 , } impl From < Lsbfirst > for bool { # [inline (always)] fn from (variant : Lsbfirst) -> Self { variant as u8 != 0 } } # [doc = "Field `LSBFIRST` reader - Frame format"] pub type LsbfirstR = crate :: BitReader < Lsbfirst > ; impl LsbfirstR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lsbfirst { match self . bits { false => Lsbfirst :: Msbfirst , true => Lsbfirst :: Lsbfirst , } } # [doc = "Data is transmitted/received with the MSB first"] # [inline (always)] pub fn is_msbfirst (& self) -> bool { * self == Lsbfirst :: Msbfirst } # [doc = "Data is transmitted/received with the LSB first"] # [inline (always)] pub fn is_lsbfirst (& self) -> bool { * self == Lsbfirst :: Lsbfirst } } # [doc = "Field `LSBFIRST` writer - Frame format"] pub type LsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG , Lsbfirst > ; impl < 'a , REG > LsbfirstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Data is transmitted/received with the MSB first"] # [inline (always)] pub fn msbfirst (self) -> & 'a mut crate :: W < REG > { self . variant (Lsbfirst :: Msbfirst) } # [doc = "Data is transmitted/received with the LSB first"] # [inline (always)] pub fn lsbfirst (self) -> & 'a mut crate :: W < REG > { self . variant (Lsbfirst :: Lsbfirst) } } # [doc = "Internal slave select\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ssi { # [doc = "0: 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] SlaveSelected = 0 , # [doc = "1: 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] SlaveNotSelected = 1 , } impl From < Ssi > for bool { # [inline (always)] fn from (variant : Ssi) -> Self { variant as u8 != 0 } } # [doc = "Field `SSI` reader - Internal slave select"] pub type SsiR = crate :: BitReader < Ssi > ; impl SsiR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ssi { match self . bits { false => Ssi :: SlaveSelected , true => Ssi :: SlaveNotSelected , } } # [doc = "0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] # [inline (always)] pub fn is_slave_selected (& self) -> bool { * self == Ssi :: SlaveSelected } # [doc = "1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] # [inline (always)] pub fn is_slave_not_selected (& self) -> bool { * self == Ssi :: SlaveNotSelected } } # [doc = "Field `SSI` writer - Internal slave select"] pub type SsiW < 'a , REG > = crate :: BitWriter < 'a , REG , Ssi > ; impl < 'a , REG > SsiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] # [inline (always)] pub fn slave_selected (self) -> & 'a mut crate :: W < REG > { self . variant (Ssi :: SlaveSelected) } # [doc = "1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored"] # [inline (always)] pub fn slave_not_selected (self) -> & 'a mut crate :: W < REG > { self . variant (Ssi :: SlaveNotSelected) } } # [doc = "Software slave management\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ssm { # [doc = "0: Software slave management disabled"] Disabled = 0 , # [doc = "1: Software slave management enabled"] Enabled = 1 , } impl From < Ssm > for bool { # [inline (always)] fn from (variant : Ssm) -> Self { variant as u8 != 0 } } # [doc = "Field `SSM` reader - Software slave management"] pub type SsmR = crate :: BitReader < Ssm > ; impl SsmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ssm { match self . bits { false => Ssm :: Disabled , true => Ssm :: Enabled , } } # [doc = "Software slave management disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ssm :: Disabled } # [doc = "Software slave management enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ssm :: Enabled } } # [doc = "Field `SSM` writer - Software slave management"] pub type SsmW < 'a , REG > = crate :: BitWriter < 'a , REG , Ssm > ; impl < 'a , REG > SsmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Software slave management disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ssm :: Disabled) } # [doc = "Software slave management enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ssm :: Enabled) } } # [doc = "Receive only\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxonly { # [doc = "0: Full duplex (Transmit and receive)"] FullDuplex = 0 , # [doc = "1: Output disabled (Receive-only mode)"] OutputDisabled = 1 , } impl From < Rxonly > for bool { # [inline (always)] fn from (variant : Rxonly) -> Self { variant as u8 != 0 } } # [doc = "Field `RXONLY` reader - Receive only"] pub type RxonlyR = crate :: BitReader < Rxonly > ; impl RxonlyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxonly { match self . bits { false => Rxonly :: FullDuplex , true => Rxonly :: OutputDisabled , } } # [doc = "Full duplex (Transmit and receive)"] # [inline (always)] pub fn is_full_duplex (& self) -> bool { * self == Rxonly :: FullDuplex } # [doc = "Output disabled (Receive-only mode)"] # [inline (always)] pub fn is_output_disabled (& self) -> bool { * self == Rxonly :: OutputDisabled } } # [doc = "Field `RXONLY` writer - Receive only"] pub type RxonlyW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxonly > ; impl < 'a , REG > RxonlyW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Full duplex (Transmit and receive)"] # [inline (always)] pub fn full_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Rxonly :: FullDuplex) } # [doc = "Output disabled (Receive-only mode)"] # [inline (always)] pub fn output_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rxonly :: OutputDisabled) } } # [doc = "Data frame format\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dff { # [doc = "0: 8-bit data frame format is selected for transmission/reception"] EightBit = 0 , # [doc = "1: 16-bit data frame format is selected for transmission/reception"] SixteenBit = 1 , } impl From < Dff > for bool { # [inline (always)] fn from (variant : Dff) -> Self { variant as u8 != 0 } } # [doc = "Field `DFF` reader - Data frame format"] pub type DffR = crate :: BitReader < Dff > ; impl DffR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dff { match self . bits { false => Dff :: EightBit , true => Dff :: SixteenBit , } } # [doc = "8-bit data frame format is selected for transmission/reception"] # [inline (always)] pub fn is_eight_bit (& self) -> bool { * self == Dff :: EightBit } # [doc = "16-bit data frame format is selected for transmission/reception"] # [inline (always)] pub fn is_sixteen_bit (& self) -> bool { * self == Dff :: SixteenBit } } # [doc = "Field `DFF` writer - Data frame format"] pub type DffW < 'a , REG > = crate :: BitWriter < 'a , REG , Dff > ; impl < 'a , REG > DffW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "8-bit data frame format is selected for transmission/reception"] # [inline (always)] pub fn eight_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Dff :: EightBit) } # [doc = "16-bit data frame format is selected for transmission/reception"] # [inline (always)] pub fn sixteen_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Dff :: SixteenBit) } } # [doc = "CRC transfer next\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Crcnext { # [doc = "0: Next transmit value is from Tx buffer"] TxBuffer = 0 , # [doc = "1: Next transmit value is from Tx CRC register"] Crc = 1 , } impl From < Crcnext > for bool { # [inline (always)] fn from (variant : Crcnext) -> Self { variant as u8 != 0 } } # [doc = "Field `CRCNEXT` reader - CRC transfer next"] pub type CrcnextR = crate :: BitReader < Crcnext > ; impl CrcnextR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Crcnext { match self . bits { false => Crcnext :: TxBuffer , true => Crcnext :: Crc , } } # [doc = "Next transmit value is from Tx buffer"] # [inline (always)] pub fn is_tx_buffer (& self) -> bool { * self == Crcnext :: TxBuffer } # [doc = "Next transmit value is from Tx CRC register"] # [inline (always)] pub fn is_crc (& self) -> bool { * self == Crcnext :: Crc } } # [doc = "Field `CRCNEXT` writer - CRC transfer next"] pub type CrcnextW < 'a , REG > = crate :: BitWriter < 'a , REG , Crcnext > ; impl < 'a , REG > CrcnextW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Next transmit value is from Tx buffer"] # [inline (always)] pub fn tx_buffer (self) -> & 'a mut crate :: W < REG > { self . variant (Crcnext :: TxBuffer) } # [doc = "Next transmit value is from Tx CRC register"] # [inline (always)] pub fn crc (self) -> & 'a mut crate :: W < REG > { self . variant (Crcnext :: Crc) } } # [doc = "Hardware CRC calculation enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Crcen { # [doc = "0: CRC calculation disabled"] Disabled = 0 , # [doc = "1: CRC calculation enabled"] Enabled = 1 , } impl From < Crcen > for bool { # [inline (always)] fn from (variant : Crcen) -> Self { variant as u8 != 0 } } # [doc = "Field `CRCEN` reader - Hardware CRC calculation enable"] pub type CrcenR = crate :: BitReader < Crcen > ; impl CrcenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Crcen { match self . bits { false => Crcen :: Disabled , true => Crcen :: Enabled , } } # [doc = "CRC calculation disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Crcen :: Disabled } # [doc = "CRC calculation enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Crcen :: Enabled } } # [doc = "Field `CRCEN` writer - Hardware CRC calculation enable"] pub type CrcenW < 'a , REG > = crate :: BitWriter < 'a , REG , Crcen > ; impl < 'a , REG > CrcenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CRC calculation disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Crcen :: Disabled) } # [doc = "CRC calculation enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Crcen :: Enabled) } } # [doc = "Output enable in bidirectional mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bidioe { # [doc = "0: Output disabled (receive-only mode)"] OutputDisabled = 0 , # [doc = "1: Output enabled (transmit-only mode)"] OutputEnabled = 1 , } impl From < Bidioe > for bool { # [inline (always)] fn from (variant : Bidioe) -> Self { variant as u8 != 0 } } # [doc = "Field `BIDIOE` reader - Output enable in bidirectional mode"] pub type BidioeR = crate :: BitReader < Bidioe > ; impl BidioeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bidioe { match self . bits { false => Bidioe :: OutputDisabled , true => Bidioe :: OutputEnabled , } } # [doc = "Output disabled (receive-only mode)"] # [inline (always)] pub fn is_output_disabled (& self) -> bool { * self == Bidioe :: OutputDisabled } # [doc = "Output enabled (transmit-only mode)"] # [inline (always)] pub fn is_output_enabled (& self) -> bool { * self == Bidioe :: OutputEnabled } } # [doc = "Field `BIDIOE` writer - Output enable in bidirectional mode"] pub type BidioeW < 'a , REG > = crate :: BitWriter < 'a , REG , Bidioe > ; impl < 'a , REG > BidioeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Output disabled (receive-only mode)"] # [inline (always)] pub fn output_disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bidioe :: OutputDisabled) } # [doc = "Output enabled (transmit-only mode)"] # [inline (always)] pub fn output_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bidioe :: OutputEnabled) } } # [doc = "Bidirectional data mode enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bidimode { # [doc = "0: 2-line unidirectional data mode selected"] Unidirectional = 0 , # [doc = "1: 1-line bidirectional data mode selected"] Bidirectional = 1 , } impl From < Bidimode > for bool { # [inline (always)] fn from (variant : Bidimode) -> Self { variant as u8 != 0 } } # [doc = "Field `BIDIMODE` reader - Bidirectional data mode enable"] pub type BidimodeR = crate :: BitReader < Bidimode > ; impl BidimodeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bidimode { match self . bits { false => Bidimode :: Unidirectional , true => Bidimode :: Bidirectional , } } # [doc = "2-line unidirectional data mode selected"] # [inline (always)] pub fn is_unidirectional (& self) -> bool { * self == Bidimode :: Unidirectional } # [doc = "1-line bidirectional data mode selected"] # [inline (always)] pub fn is_bidirectional (& self) -> bool { * self == Bidimode :: Bidirectional } } # [doc = "Field `BIDIMODE` writer - Bidirectional data mode enable"] pub type BidimodeW < 'a , REG > = crate :: BitWriter < 'a , REG , Bidimode > ; impl < 'a , REG > BidimodeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "2-line unidirectional data mode selected"] # [inline (always)] pub fn unidirectional (self) -> & 'a mut crate :: W < REG > { self . variant (Bidimode :: Unidirectional) } # [doc = "1-line bidirectional data mode selected"] # [inline (always)] pub fn bidirectional (self) -> & 'a mut crate :: W < REG > { self . variant (Bidimode :: Bidirectional) } } impl R { # [doc = "Bit 0 - Clock phase"] # [inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Clock polarity"] # [inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Master selection"] # [inline (always)] pub fn mstr (& self) -> MstrR { MstrR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - Baud rate control"] # [inline (always)] pub fn br (& self) -> BrR { BrR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bit 6 - SPI enable"] # [inline (always)] pub fn spe (& self) -> SpeR { SpeR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Frame format"] # [inline (always)] pub fn lsbfirst (& self) -> LsbfirstR { LsbfirstR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Internal slave select"] # [inline (always)] pub fn ssi (& self) -> SsiR { SsiR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Software slave management"] # [inline (always)] pub fn ssm (& self) -> SsmR { SsmR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Receive only"] # [inline (always)] pub fn rxonly (& self) -> RxonlyR { RxonlyR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Data frame format"] # [inline (always)] pub fn dff (& self) -> DffR { DffR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - CRC transfer next"] # [inline (always)] pub fn crcnext (& self) -> CrcnextR { CrcnextR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Hardware CRC calculation enable"] # [inline (always)] pub fn crcen (& self) -> CrcenR { CrcenR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Output enable in bidirectional mode"] # [inline (always)] pub fn bidioe (& self) -> BidioeR { BidioeR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Bidirectional data mode enable"] # [inline (always)] pub fn bidimode (& self) -> BidimodeR { BidimodeR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock phase"] # [inline (always)] pub fn cpha (& mut self) -> CphaW < Cr1Spec > { CphaW :: new (self , 0) } # [doc = "Bit 1 - Clock polarity"] # [inline (always)] pub fn cpol (& mut self) -> CpolW < Cr1Spec > { CpolW :: new (self , 1) } # [doc = "Bit 2 - Master selection"] # [inline (always)] pub fn mstr (& mut self) -> MstrW < Cr1Spec > { MstrW :: new (self , 2) } # [doc = "Bits 3:5 - Baud rate control"] # [inline (always)] pub fn br (& mut self) -> BrW < Cr1Spec > { BrW :: new (self , 3) } # [doc = "Bit 6 - SPI enable"] # [inline (always)] pub fn spe (& mut self) -> SpeW < Cr1Spec > { SpeW :: new (self , 6) } # [doc = "Bit 7 - Frame format"] # [inline (always)] pub fn lsbfirst (& mut self) -> LsbfirstW < Cr1Spec > { LsbfirstW :: new (self , 7) } # [doc = "Bit 8 - Internal slave select"] # [inline (always)] pub fn ssi (& mut self) -> SsiW < Cr1Spec > { SsiW :: new (self , 8) } # [doc = "Bit 9 - Software slave management"] # [inline (always)] pub fn ssm (& mut self) -> SsmW < Cr1Spec > { SsmW :: new (self , 9) } # [doc = "Bit 10 - Receive only"] # [inline (always)] pub fn rxonly (& mut self) -> RxonlyW < Cr1Spec > { RxonlyW :: new (self , 10) } # [doc = "Bit 11 - Data frame format"] # [inline (always)] pub fn dff (& mut self) -> DffW < Cr1Spec > { DffW :: new (self , 11) } # [doc = "Bit 12 - CRC transfer next"] # [inline (always)] pub fn crcnext (& mut self) -> CrcnextW < Cr1Spec > { CrcnextW :: new (self , 12) } # [doc = "Bit 13 - Hardware CRC calculation enable"] # [inline (always)] pub fn crcen (& mut self) -> CrcenW < Cr1Spec > { CrcenW :: new (self , 13) } # [doc = "Bit 14 - Output enable in bidirectional mode"] # [inline (always)] pub fn bidioe (& mut self) -> BidioeW < Cr1Spec > { BidioeW :: new (self , 14) } # [doc = "Bit 15 - Bidirectional data mode enable"] # [inline (always)] pub fn bidimode (& mut self) -> BidimodeW < Cr1Spec > { BidimodeW :: new (self , 15) } } # [doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u16 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
# [doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "Receive buffer not empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxne { # [doc = "0: Rx buffer empty"] Empty = 0 , # [doc = "1: Rx buffer not empty"] NotEmpty = 1 , } impl From < Rxne > for bool { # [inline (always)] fn from (variant : Rxne) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNE` reader - Receive buffer not empty"] pub type RxneR = crate :: BitReader < Rxne > ; impl RxneR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxne { match self . bits { false => Rxne :: Empty , true => Rxne :: NotEmpty , } } # [doc = "Rx buffer empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Rxne :: Empty } # [doc = "Rx buffer not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == Rxne :: NotEmpty } } # [doc = "Transmit buffer empty\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txe { # [doc = "0: Tx buffer not empty"] NotEmpty = 0 , # [doc = "1: Tx buffer empty"] Empty = 1 , } impl From < Txe > for bool { # [inline (always)] fn from (variant : Txe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXE` reader - Transmit buffer empty"] pub type TxeR = crate :: BitReader < Txe > ; impl TxeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txe { match self . bits { false => Txe :: NotEmpty , true => Txe :: Empty , } } # [doc = "Tx buffer not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == Txe :: NotEmpty } # [doc = "Tx buffer empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Txe :: Empty } } # [doc = "Channel side\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Chside { # [doc = "0: Channel left has to be transmitted or has been received"] Left = 0 , # [doc = "1: Channel right has to be transmitted or has been received"] Right = 1 , } impl From < Chside > for bool { # [inline (always)] fn from (variant : Chside) -> Self { variant as u8 != 0 } } # [doc = "Field `CHSIDE` reader - Channel side"] pub type ChsideR = crate :: BitReader < Chside > ; impl ChsideR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Chside { match self . bits { false => Chside :: Left , true => Chside :: Right , } } # [doc = "Channel left has to be transmitted or has been received"] # [inline (always)] pub fn is_left (& self) -> bool { * self == Chside :: Left } # [doc = "Channel right has to be transmitted or has been received"] # [inline (always)] pub fn is_right (& self) -> bool { * self == Chside :: Right } } # [doc = "Underrun flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Udrr { # [doc = "0: No underrun occurred"] NoUnderrun = 0 , # [doc = "1: Underrun occurred"] Underrun = 1 , } impl From < Udrr > for bool { # [inline (always)] fn from (variant : Udrr) -> Self { variant as u8 != 0 } } # [doc = "Field `UDR` reader - Underrun flag"] pub type UdrR = crate :: BitReader < Udrr > ; impl UdrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Udrr { match self . bits { false => Udrr :: NoUnderrun , true => Udrr :: Underrun , } } # [doc = "No underrun occurred"] # [inline (always)] pub fn is_no_underrun (& self) -> bool { * self == Udrr :: NoUnderrun } # [doc = "Underrun occurred"] # [inline (always)] pub fn is_underrun (& self) -> bool { * self == Udrr :: Underrun } } # [doc = "CRC error flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Crcerrr { # [doc = "0: CRC value received matches the SPIx_RXCRCR value"] Match = 0 , # [doc = "1: CRC value received does not match the SPIx_RXCRCR value"] NoMatch = 1 , } impl From < Crcerrr > for bool { # [inline (always)] fn from (variant : Crcerrr) -> Self { variant as u8 != 0 } } # [doc = "Field `CRCERR` reader - CRC error flag"] pub type CrcerrR = crate :: BitReader < Crcerrr > ; impl CrcerrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Crcerrr { match self . bits { false => Crcerrr :: Match , true => Crcerrr :: NoMatch , } } # [doc = "CRC value received matches the SPIx_RXCRCR value"] # [inline (always)] pub fn is_match (& self) -> bool { * self == Crcerrr :: Match } # [doc = "CRC value received does not match the SPIx_RXCRCR value"] # [inline (always)] pub fn is_no_match (& self) -> bool { * self == Crcerrr :: NoMatch } } # [doc = "CRC error flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CrcerrwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < CrcerrwWO > for bool { # [inline (always)] fn from (variant : CrcerrwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CRCERR` writer - CRC error flag"] pub type CrcerrW < 'a , REG > = crate :: BitWriter0C < 'a , REG , CrcerrwWO > ; impl < 'a , REG > CrcerrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (CrcerrwWO :: Clear) } } # [doc = "Mode fault\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Modfr { # [doc = "0: No mode fault occurred"] NoFault = 0 , # [doc = "1: Mode fault occurred"] Fault = 1 , } impl From < Modfr > for bool { # [inline (always)] fn from (variant : Modfr) -> Self { variant as u8 != 0 } } # [doc = "Field `MODF` reader - Mode fault"] pub type ModfR = crate :: BitReader < Modfr > ; impl ModfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Modfr { match self . bits { false => Modfr :: NoFault , true => Modfr :: Fault , } } # [doc = "No mode fault occurred"] # [inline (always)] pub fn is_no_fault (& self) -> bool { * self == Modfr :: NoFault } # [doc = "Mode fault occurred"] # [inline (always)] pub fn is_fault (& self) -> bool { * self == Modfr :: Fault } } # [doc = "Overrun flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ovrr { # [doc = "0: No overrun occurred"] NoOverrun = 0 , # [doc = "1: Overrun occurred"] Overrun = 1 , } impl From < Ovrr > for bool { # [inline (always)] fn from (variant : Ovrr) -> Self { variant as u8 != 0 } } # [doc = "Field `OVR` reader - Overrun flag"] pub type OvrR = crate :: BitReader < Ovrr > ; impl OvrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ovrr { match self . bits { false => Ovrr :: NoOverrun , true => Ovrr :: Overrun , } } # [doc = "No overrun occurred"] # [inline (always)] pub fn is_no_overrun (& self) -> bool { * self == Ovrr :: NoOverrun } # [doc = "Overrun occurred"] # [inline (always)] pub fn is_overrun (& self) -> bool { * self == Ovrr :: Overrun } } # [doc = "Busy flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bsyr { # [doc = "0: SPI not busy"] NotBusy = 0 , # [doc = "1: SPI busy"] Busy = 1 , } impl From < Bsyr > for bool { # [inline (always)] fn from (variant : Bsyr) -> Self { variant as u8 != 0 } } # [doc = "Field `BSY` reader - Busy flag"] pub type BsyR = crate :: BitReader < Bsyr > ; impl BsyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bsyr { match self . bits { false => Bsyr :: NotBusy , true => Bsyr :: Busy , } } # [doc = "SPI not busy"] # [inline (always)] pub fn is_not_busy (& self) -> bool { * self == Bsyr :: NotBusy } # [doc = "SPI busy"] # [inline (always)] pub fn is_busy (& self) -> bool { * self == Bsyr :: Busy } } # [doc = "TI frame format error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Frer { # [doc = "0: No frame format error"] NoError = 0 , # [doc = "1: A frame format error occurred"] Error = 1 , } impl From < Frer > for bool { # [inline (always)] fn from (variant : Frer) -> Self { variant as u8 != 0 } } # [doc = "Field `FRE` reader - TI frame format error"] pub type FreR = crate :: BitReader < Frer > ; impl FreR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Frer { match self . bits { false => Frer :: NoError , true => Frer :: Error , } } # [doc = "No frame format error"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Frer :: NoError } # [doc = "A frame format error occurred"] # [inline (always)] pub fn is_error (& self) -> bool { * self == Frer :: Error } } impl R { # [doc = "Bit 0 - Receive buffer not empty"] # [inline (always)] pub fn rxne (& self) -> RxneR { RxneR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit buffer empty"] # [inline (always)] pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel side"] # [inline (always)] pub fn chside (& self) -> ChsideR { ChsideR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Underrun flag"] # [inline (always)] pub fn udr (& self) -> UdrR { UdrR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - CRC error flag"] # [inline (always)] pub fn crcerr (& self) -> CrcerrR { CrcerrR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Mode fault"] # [inline (always)] pub fn modf (& self) -> ModfR { ModfR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Overrun flag"] # [inline (always)] pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Busy flag"] # [inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - TI frame format error"] # [inline (always)] pub fn fre (& self) -> FreR { FreR :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bit 4 - CRC error flag"] # [inline (always)] pub fn crcerr (& mut self) -> CrcerrW < SrSpec > { CrcerrW :: new (self , 4) } } # [doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u16 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u16 = 0x10 ; } # [doc = "`reset()` method sets SR to value 0x02"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u16 = 0x02 ; }
# [doc = "Register `I2SCFGR` reader"] pub type R = crate :: R < I2scfgrSpec > ; # [doc = "Register `I2SCFGR` writer"] pub type W = crate :: W < I2scfgrSpec > ; # [doc = "Channel length (number of bits per audio channel)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Chlen { # [doc = "0: 16-bit wide"] SixteenBit = 0 , # [doc = "1: 32-bit wide"] ThirtyTwoBit = 1 , } impl From < Chlen > for bool { # [inline (always)] fn from (variant : Chlen) -> Self { variant as u8 != 0 } } # [doc = "Field `CHLEN` reader - Channel length (number of bits per audio channel)"] pub type ChlenR = crate :: BitReader < Chlen > ; impl ChlenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Chlen { match self . bits { false => Chlen :: SixteenBit , true => Chlen :: ThirtyTwoBit , } } # [doc = "16-bit wide"] # [inline (always)] pub fn is_sixteen_bit (& self) -> bool { * self == Chlen :: SixteenBit } # [doc = "32-bit wide"] # [inline (always)] pub fn is_thirty_two_bit (& self) -> bool { * self == Chlen :: ThirtyTwoBit } } # [doc = "Field `CHLEN` writer - Channel length (number of bits per audio channel)"] pub type ChlenW < 'a , REG > = crate :: BitWriter < 'a , REG , Chlen > ; impl < 'a , REG > ChlenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "16-bit wide"] # [inline (always)] pub fn sixteen_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Chlen :: SixteenBit) } # [doc = "32-bit wide"] # [inline (always)] pub fn thirty_two_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Chlen :: ThirtyTwoBit) } } # [doc = "Data length to be transferred\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Datlen { # [doc = "0: 16-bit data length"] SixteenBit = 0 , # [doc = "1: 24-bit data length"] TwentyFourBit = 1 , # [doc = "2: 32-bit data length"] ThirtyTwoBit = 2 , } impl From < Datlen > for u8 { # [inline (always)] fn from (variant : Datlen) -> Self { variant as _ } } impl crate :: FieldSpec for Datlen { type Ux = u8 ; } impl crate :: IsEnum for Datlen { } # [doc = "Field `DATLEN` reader - Data length to be transferred"] pub type DatlenR = crate :: FieldReader < Datlen > ; impl DatlenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Datlen > { match self . bits { 0 => Some (Datlen :: SixteenBit) , 1 => Some (Datlen :: TwentyFourBit) , 2 => Some (Datlen :: ThirtyTwoBit) , _ => None , } } # [doc = "16-bit data length"] # [inline (always)] pub fn is_sixteen_bit (& self) -> bool { * self == Datlen :: SixteenBit } # [doc = "24-bit data length"] # [inline (always)] pub fn is_twenty_four_bit (& self) -> bool { * self == Datlen :: TwentyFourBit } # [doc = "32-bit data length"] # [inline (always)] pub fn is_thirty_two_bit (& self) -> bool { * self == Datlen :: ThirtyTwoBit } } # [doc = "Field `DATLEN` writer - Data length to be transferred"] pub type DatlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Datlen > ; impl < 'a , REG > DatlenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "16-bit data length"] # [inline (always)] pub fn sixteen_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Datlen :: SixteenBit) } # [doc = "24-bit data length"] # [inline (always)] pub fn twenty_four_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Datlen :: TwentyFourBit) } # [doc = "32-bit data length"] # [inline (always)] pub fn thirty_two_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Datlen :: ThirtyTwoBit) } } # [doc = "Steady state clock polarity\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ckpol { # [doc = "0: I2S clock inactive state is low level"] IdleLow = 0 , # [doc = "1: I2S clock inactive state is high level"] IdleHigh = 1 , } impl From < Ckpol > for bool { # [inline (always)] fn from (variant : Ckpol) -> Self { variant as u8 != 0 } } # [doc = "Field `CKPOL` reader - Steady state clock polarity"] pub type CkpolR = crate :: BitReader < Ckpol > ; impl CkpolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ckpol { match self . bits { false => Ckpol :: IdleLow , true => Ckpol :: IdleHigh , } } # [doc = "I2S clock inactive state is low level"] # [inline (always)] pub fn is_idle_low (& self) -> bool { * self == Ckpol :: IdleLow } # [doc = "I2S clock inactive state is high level"] # [inline (always)] pub fn is_idle_high (& self) -> bool { * self == Ckpol :: IdleHigh } } # [doc = "Field `CKPOL` writer - Steady state clock polarity"] pub type CkpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Ckpol > ; impl < 'a , REG > CkpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "I2S clock inactive state is low level"] # [inline (always)] pub fn idle_low (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: IdleLow) } # [doc = "I2S clock inactive state is high level"] # [inline (always)] pub fn idle_high (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: IdleHigh) } } # [doc = "I2S standard selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum I2sstd { # [doc = "0: I2S Philips standard"] Philips = 0 , # [doc = "1: MSB justified standard"] Msb = 1 , # [doc = "2: LSB justified standard"] Lsb = 2 , # [doc = "3: PCM standard"] Pcm = 3 , } impl From < I2sstd > for u8 { # [inline (always)] fn from (variant : I2sstd) -> Self { variant as _ } } impl crate :: FieldSpec for I2sstd { type Ux = u8 ; } impl crate :: IsEnum for I2sstd { } # [doc = "Field `I2SSTD` reader - I2S standard selection"] pub type I2sstdR = crate :: FieldReader < I2sstd > ; impl I2sstdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> I2sstd { match self . bits { 0 => I2sstd :: Philips , 1 => I2sstd :: Msb , 2 => I2sstd :: Lsb , 3 => I2sstd :: Pcm , _ => unreachable ! () , } } # [doc = "I2S Philips standard"] # [inline (always)] pub fn is_philips (& self) -> bool { * self == I2sstd :: Philips } # [doc = "MSB justified standard"] # [inline (always)] pub fn is_msb (& self) -> bool { * self == I2sstd :: Msb } # [doc = "LSB justified standard"] # [inline (always)] pub fn is_lsb (& self) -> bool { * self == I2sstd :: Lsb } # [doc = "PCM standard"] # [inline (always)] pub fn is_pcm (& self) -> bool { * self == I2sstd :: Pcm } } # [doc = "Field `I2SSTD` writer - I2S standard selection"] pub type I2sstdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , I2sstd , crate :: Safe > ; impl < 'a , REG > I2sstdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "I2S Philips standard"] # [inline (always)] pub fn philips (self) -> & 'a mut crate :: W < REG > { self . variant (I2sstd :: Philips) } # [doc = "MSB justified standard"] # [inline (always)] pub fn msb (self) -> & 'a mut crate :: W < REG > { self . variant (I2sstd :: Msb) } # [doc = "LSB justified standard"] # [inline (always)] pub fn lsb (self) -> & 'a mut crate :: W < REG > { self . variant (I2sstd :: Lsb) } # [doc = "PCM standard"] # [inline (always)] pub fn pcm (self) -> & 'a mut crate :: W < REG > { self . variant (I2sstd :: Pcm) } } # [doc = "PCM frame synchronization\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pcmsync { # [doc = "0: Short frame synchronisation"] Short = 0 , # [doc = "1: Long frame synchronisation"] Long = 1 , } impl From < Pcmsync > for bool { # [inline (always)] fn from (variant : Pcmsync) -> Self { variant as u8 != 0 } } # [doc = "Field `PCMSYNC` reader - PCM frame synchronization"] pub type PcmsyncR = crate :: BitReader < Pcmsync > ; impl PcmsyncR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pcmsync { match self . bits { false => Pcmsync :: Short , true => Pcmsync :: Long , } } # [doc = "Short frame synchronisation"] # [inline (always)] pub fn is_short (& self) -> bool { * self == Pcmsync :: Short } # [doc = "Long frame synchronisation"] # [inline (always)] pub fn is_long (& self) -> bool { * self == Pcmsync :: Long } } # [doc = "Field `PCMSYNC` writer - PCM frame synchronization"] pub type PcmsyncW < 'a , REG > = crate :: BitWriter < 'a , REG , Pcmsync > ; impl < 'a , REG > PcmsyncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Short frame synchronisation"] # [inline (always)] pub fn short (self) -> & 'a mut crate :: W < REG > { self . variant (Pcmsync :: Short) } # [doc = "Long frame synchronisation"] # [inline (always)] pub fn long (self) -> & 'a mut crate :: W < REG > { self . variant (Pcmsync :: Long) } } # [doc = "I2S configuration mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum I2scfg { # [doc = "0: Slave - transmit"] SlaveTx = 0 , # [doc = "1: Slave - receive"] SlaveRx = 1 , # [doc = "2: Master - transmit"] MasterTx = 2 , # [doc = "3: Master - receive"] MasterRx = 3 , } impl From < I2scfg > for u8 { # [inline (always)] fn from (variant : I2scfg) -> Self { variant as _ } } impl crate :: FieldSpec for I2scfg { type Ux = u8 ; } impl crate :: IsEnum for I2scfg { } # [doc = "Field `I2SCFG` reader - I2S configuration mode"] pub type I2scfgR = crate :: FieldReader < I2scfg > ; impl I2scfgR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> I2scfg { match self . bits { 0 => I2scfg :: SlaveTx , 1 => I2scfg :: SlaveRx , 2 => I2scfg :: MasterTx , 3 => I2scfg :: MasterRx , _ => unreachable ! () , } } # [doc = "Slave - transmit"] # [inline (always)] pub fn is_slave_tx (& self) -> bool { * self == I2scfg :: SlaveTx } # [doc = "Slave - receive"] # [inline (always)] pub fn is_slave_rx (& self) -> bool { * self == I2scfg :: SlaveRx } # [doc = "Master - transmit"] # [inline (always)] pub fn is_master_tx (& self) -> bool { * self == I2scfg :: MasterTx } # [doc = "Master - receive"] # [inline (always)] pub fn is_master_rx (& self) -> bool { * self == I2scfg :: MasterRx } } # [doc = "Field `I2SCFG` writer - I2S configuration mode"] pub type I2scfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , I2scfg , crate :: Safe > ; impl < 'a , REG > I2scfgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Slave - transmit"] # [inline (always)] pub fn slave_tx (self) -> & 'a mut crate :: W < REG > { self . variant (I2scfg :: SlaveTx) } # [doc = "Slave - receive"] # [inline (always)] pub fn slave_rx (self) -> & 'a mut crate :: W < REG > { self . variant (I2scfg :: SlaveRx) } # [doc = "Master - transmit"] # [inline (always)] pub fn master_tx (self) -> & 'a mut crate :: W < REG > { self . variant (I2scfg :: MasterTx) } # [doc = "Master - receive"] # [inline (always)] pub fn master_rx (self) -> & 'a mut crate :: W < REG > { self . variant (I2scfg :: MasterRx) } } # [doc = "I2S Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum I2se { # [doc = "0: I2S peripheral is disabled"] Disabled = 0 , # [doc = "1: I2S peripheral is enabled"] Enabled = 1 , } impl From < I2se > for bool { # [inline (always)] fn from (variant : I2se) -> Self { variant as u8 != 0 } } # [doc = "Field `I2SE` reader - I2S Enable"] pub type I2seR = crate :: BitReader < I2se > ; impl I2seR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> I2se { match self . bits { false => I2se :: Disabled , true => I2se :: Enabled , } } # [doc = "I2S peripheral is disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == I2se :: Disabled } # [doc = "I2S peripheral is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == I2se :: Enabled } } # [doc = "Field `I2SE` writer - I2S Enable"] pub type I2seW < 'a , REG > = crate :: BitWriter < 'a , REG , I2se > ; impl < 'a , REG > I2seW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "I2S peripheral is disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (I2se :: Disabled) } # [doc = "I2S peripheral is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (I2se :: Enabled) } } # [doc = "I2S mode selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum I2smod { # [doc = "0: SPI mode is selected"] Spimode = 0 , # [doc = "1: I2S mode is selected"] I2smode = 1 , } impl From < I2smod > for bool { # [inline (always)] fn from (variant : I2smod) -> Self { variant as u8 != 0 } } # [doc = "Field `I2SMOD` reader - I2S mode selection"] pub type I2smodR = crate :: BitReader < I2smod > ; impl I2smodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> I2smod { match self . bits { false => I2smod :: Spimode , true => I2smod :: I2smode , } } # [doc = "SPI mode is selected"] # [inline (always)] pub fn is_spimode (& self) -> bool { * self == I2smod :: Spimode } # [doc = "I2S mode is selected"] # [inline (always)] pub fn is_i2smode (& self) -> bool { * self == I2smod :: I2smode } } # [doc = "Field `I2SMOD` writer - I2S mode selection"] pub type I2smodW < 'a , REG > = crate :: BitWriter < 'a , REG , I2smod > ; impl < 'a , REG > I2smodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SPI mode is selected"] # [inline (always)] pub fn spimode (self) -> & 'a mut crate :: W < REG > { self . variant (I2smod :: Spimode) } # [doc = "I2S mode is selected"] # [inline (always)] pub fn i2smode (self) -> & 'a mut crate :: W < REG > { self . variant (I2smod :: I2smode) } } impl R { # [doc = "Bit 0 - Channel length (number of bits per audio channel)"] # [inline (always)] pub fn chlen (& self) -> ChlenR { ChlenR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Data length to be transferred"] # [inline (always)] pub fn datlen (& self) -> DatlenR { DatlenR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - Steady state clock polarity"] # [inline (always)] pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - I2S standard selection"] # [inline (always)] pub fn i2sstd (& self) -> I2sstdR { I2sstdR :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 7 - PCM frame synchronization"] # [inline (always)] pub fn pcmsync (& self) -> PcmsyncR { PcmsyncR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - I2S configuration mode"] # [inline (always)] pub fn i2scfg (& self) -> I2scfgR { I2scfgR :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bit 10 - I2S Enable"] # [inline (always)] pub fn i2se (& self) -> I2seR { I2seR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - I2S mode selection"] # [inline (always)] pub fn i2smod (& self) -> I2smodR { I2smodR :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel length (number of bits per audio channel)"] # [inline (always)] pub fn chlen (& mut self) -> ChlenW < I2scfgrSpec > { ChlenW :: new (self , 0) } # [doc = "Bits 1:2 - Data length to be transferred"] # [inline (always)] pub fn datlen (& mut self) -> DatlenW < I2scfgrSpec > { DatlenW :: new (self , 1) } # [doc = "Bit 3 - Steady state clock polarity"] # [inline (always)] pub fn ckpol (& mut self) -> CkpolW < I2scfgrSpec > { CkpolW :: new (self , 3) } # [doc = "Bits 4:5 - I2S standard selection"] # [inline (always)] pub fn i2sstd (& mut self) -> I2sstdW < I2scfgrSpec > { I2sstdW :: new (self , 4) } # [doc = "Bit 7 - PCM frame synchronization"] # [inline (always)] pub fn pcmsync (& mut self) -> PcmsyncW < I2scfgrSpec > { PcmsyncW :: new (self , 7) } # [doc = "Bits 8:9 - I2S configuration mode"] # [inline (always)] pub fn i2scfg (& mut self) -> I2scfgW < I2scfgrSpec > { I2scfgW :: new (self , 8) } # [doc = "Bit 10 - I2S Enable"] # [inline (always)] pub fn i2se (& mut self) -> I2seW < I2scfgrSpec > { I2seW :: new (self , 10) } # [doc = "Bit 11 - I2S mode selection"] # [inline (always)] pub fn i2smod (& mut self) -> I2smodW < I2scfgrSpec > { I2smodW :: new (self , 11) } } # [doc = "I2S configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`i2scfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`i2scfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct I2scfgrSpec ; impl crate :: RegisterSpec for I2scfgrSpec { type Ux = u16 ; } # [doc = "`read()` method returns [`i2scfgr::R`](R) reader structure"] impl crate :: Readable for I2scfgrSpec { } # [doc = "`write(|w| ..)` method takes [`i2scfgr::W`](W) writer structure"] impl crate :: Writable for I2scfgrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets I2SCFGR to value 0"] impl crate :: Resettable for I2scfgrSpec { }
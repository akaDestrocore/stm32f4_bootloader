# [doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "Update interrupt flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Uifr { # [doc = "0: No update occurred"] NoUpdateOccurred = 0 , # [doc = "1: Update interrupt pending"] UpdatePending = 1 , } impl From < Uifr > for bool { # [inline (always)] fn from (variant : Uifr) -> Self { variant as u8 != 0 } } # [doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader < Uifr > ; impl UifR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Uifr { match self . bits { false => Uifr :: NoUpdateOccurred , true => Uifr :: UpdatePending , } } # [doc = "No update occurred"] # [inline (always)] pub fn is_no_update_occurred (& self) -> bool { * self == Uifr :: NoUpdateOccurred } # [doc = "Update interrupt pending"] # [inline (always)] pub fn is_update_pending (& self) -> bool { * self == Uifr :: UpdatePending } } # [doc = "Update interrupt flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum UifwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < UifwWO > for bool { # [inline (always)] fn from (variant : UifwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter0C < 'a , REG , UifwWO > ; impl < 'a , REG > UifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (UifwWO :: Clear) } } # [doc = "Capture/compare %s interrupt flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cc1ifr { # [doc = "0: No campture/compare has been detected"] NoMatch = 0 , # [doc = "1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."] Match = 1 , } impl From < Cc1ifr > for bool { # [inline (always)] fn from (variant : Cc1ifr) -> Self { variant as u8 != 0 } } # [doc = "Field `CCIF(1-1)` reader - Capture/compare %s interrupt flag"] pub type CcifR = crate :: BitReader < Cc1ifr > ; impl CcifR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cc1ifr { match self . bits { false => Cc1ifr :: NoMatch , true => Cc1ifr :: Match , } } # [doc = "No campture/compare has been detected"] # [inline (always)] pub fn is_no_match (& self) -> bool { * self == Cc1ifr :: NoMatch } # [doc = "If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."] # [inline (always)] pub fn is_match (& self) -> bool { * self == Cc1ifr :: Match } } # [doc = "Capture/compare %s interrupt flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cc1ifwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < Cc1ifwWO > for bool { # [inline (always)] fn from (variant : Cc1ifwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CCIF(1-1)` writer - Capture/compare %s interrupt flag"] pub type CcifW < 'a , REG > = crate :: BitWriter0C < 'a , REG , Cc1ifwWO > ; impl < 'a , REG > CcifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (Cc1ifwWO :: Clear) } } # [doc = "Capture/Compare %s overcapture flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cc1ofr { # [doc = "0: No overcapture has been detected"] NoOvercapture = 0 , # [doc = "1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"] Overcapture = 1 , } impl From < Cc1ofr > for bool { # [inline (always)] fn from (variant : Cc1ofr) -> Self { variant as u8 != 0 } } # [doc = "Field `CCOF(1-1)` reader - Capture/Compare %s overcapture flag"] pub type CcofR = crate :: BitReader < Cc1ofr > ; impl CcofR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cc1ofr { match self . bits { false => Cc1ofr :: NoOvercapture , true => Cc1ofr :: Overcapture , } } # [doc = "No overcapture has been detected"] # [inline (always)] pub fn is_no_overcapture (& self) -> bool { * self == Cc1ofr :: NoOvercapture } # [doc = "The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"] # [inline (always)] pub fn is_overcapture (& self) -> bool { * self == Cc1ofr :: Overcapture } } # [doc = "Capture/Compare %s overcapture flag\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cc1ofwWO { # [doc = "0: Clear flag"] Clear = 0 , } impl From < Cc1ofwWO > for bool { # [inline (always)] fn from (variant : Cc1ofwWO) -> Self { variant as u8 != 0 } } # [doc = "Field `CCOF(1-1)` writer - Capture/Compare %s overcapture flag"] pub type CcofW < 'a , REG > = crate :: BitWriter0C < 'a , REG , Cc1ofwWO > ; impl < 'a , REG > CcofW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Clear flag"] # [inline (always)] pub fn clear (self) -> & 'a mut crate :: W < REG > { self . variant (Cc1ofwWO :: Clear) } } impl R { # [doc = "Bit 0 - Update interrupt flag"] # [inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) } # [doc = "Capture/compare (1-1) interrupt flag"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC1IF` field.</div>"] # [inline (always)] pub fn ccif (& self , n : u8) -> CcifR { # [allow (clippy :: no_effect)] [() ; 1] [n as usize] ; CcifR :: new (((self . bits >> (n * 0 + 1)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Capture/compare (1-1) interrupt flag"] # [inline (always)] pub fn ccif_iter (& self) -> impl Iterator < Item = CcifR > + '_ { (0 .. 1) . map (move | n | CcifR :: new (((self . bits >> (n * 0 + 1)) & 1) != 0)) } # [doc = "Bit 1 - Capture/compare 1 interrupt flag"] # [inline (always)] pub fn cc1if (& self) -> CcifR { CcifR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Capture/Compare (1-1) overcapture flag"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC1OF` field.</div>"] # [inline (always)] pub fn ccof (& self , n : u8) -> CcofR { # [allow (clippy :: no_effect)] [() ; 1] [n as usize] ; CcofR :: new (((self . bits >> (n * 0 + 9)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Capture/Compare (1-1) overcapture flag"] # [inline (always)] pub fn ccof_iter (& self) -> impl Iterator < Item = CcofR > + '_ { (0 .. 1) . map (move | n | CcofR :: new (((self . bits >> (n * 0 + 9)) & 1) != 0)) } # [doc = "Bit 9 - Capture/Compare 1 overcapture flag"] # [inline (always)] pub fn cc1of (& self) -> CcofR { CcofR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Update interrupt flag"] # [inline (always)] pub fn uif (& mut self) -> UifW < SrSpec > { UifW :: new (self , 0) } # [doc = "Capture/compare (1-1) interrupt flag"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC1IF` field.</div>"] # [inline (always)] pub fn ccif (& mut self , n : u8) -> CcifW < SrSpec > { # [allow (clippy :: no_effect)] [() ; 1] [n as usize] ; CcifW :: new (self , n * 0 + 1) } # [doc = "Bit 1 - Capture/compare 1 interrupt flag"] # [inline (always)] pub fn cc1if (& mut self) -> CcifW < SrSpec > { CcifW :: new (self , 1) } # [doc = "Capture/Compare (1-1) overcapture flag"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC1OF` field.</div>"] # [inline (always)] pub fn ccof (& mut self , n : u8) -> CcofW < SrSpec > { # [allow (clippy :: no_effect)] [() ; 1] [n as usize] ; CcofW :: new (self , n * 0 + 9) } # [doc = "Bit 9 - Capture/Compare 1 overcapture flag"] # [inline (always)] pub fn cc1of (& mut self) -> CcofW < SrSpec > { CcofW :: new (self , 9) } } # [doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0x0203 ; } # [doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { }
# [doc = "Register `ESR` reader"] pub type R = crate :: R < EsrSpec > ; # [doc = "Register `ESR` writer"] pub type W = crate :: W < EsrSpec > ; # [doc = "Field `EWGF` reader - EWGF"] pub type EwgfR = crate :: BitReader ; # [doc = "Field `EPVF` reader - EPVF"] pub type EpvfR = crate :: BitReader ; # [doc = "Field `BOFF` reader - BOFF"] pub type BoffR = crate :: BitReader ; # [doc = "LEC\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Lec { # [doc = "0: No Error"] NoError = 0 , # [doc = "1: Stuff Error"] Stuff = 1 , # [doc = "2: Form Error"] Form = 2 , # [doc = "3: Acknowledgment Error"] Ack = 3 , # [doc = "4: Bit recessive Error"] BitRecessive = 4 , # [doc = "5: Bit dominant Error"] BitDominant = 5 , # [doc = "6: CRC Error"] Crc = 6 , # [doc = "7: Set by software"] Custom = 7 , } impl From < Lec > for u8 { # [inline (always)] fn from (variant : Lec) -> Self { variant as _ } } impl crate :: FieldSpec for Lec { type Ux = u8 ; } impl crate :: IsEnum for Lec { } # [doc = "Field `LEC` reader - LEC"] pub type LecR = crate :: FieldReader < Lec > ; impl LecR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lec { match self . bits { 0 => Lec :: NoError , 1 => Lec :: Stuff , 2 => Lec :: Form , 3 => Lec :: Ack , 4 => Lec :: BitRecessive , 5 => Lec :: BitDominant , 6 => Lec :: Crc , 7 => Lec :: Custom , _ => unreachable ! () , } } # [doc = "No Error"] # [inline (always)] pub fn is_no_error (& self) -> bool { * self == Lec :: NoError } # [doc = "Stuff Error"] # [inline (always)] pub fn is_stuff (& self) -> bool { * self == Lec :: Stuff } # [doc = "Form Error"] # [inline (always)] pub fn is_form (& self) -> bool { * self == Lec :: Form } # [doc = "Acknowledgment Error"] # [inline (always)] pub fn is_ack (& self) -> bool { * self == Lec :: Ack } # [doc = "Bit recessive Error"] # [inline (always)] pub fn is_bit_recessive (& self) -> bool { * self == Lec :: BitRecessive } # [doc = "Bit dominant Error"] # [inline (always)] pub fn is_bit_dominant (& self) -> bool { * self == Lec :: BitDominant } # [doc = "CRC Error"] # [inline (always)] pub fn is_crc (& self) -> bool { * self == Lec :: Crc } # [doc = "Set by software"] # [inline (always)] pub fn is_custom (& self) -> bool { * self == Lec :: Custom } } # [doc = "Field `LEC` writer - LEC"] pub type LecW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Lec , crate :: Safe > ; impl < 'a , REG > LecW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No Error"] # [inline (always)] pub fn no_error (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: NoError) } # [doc = "Stuff Error"] # [inline (always)] pub fn stuff (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: Stuff) } # [doc = "Form Error"] # [inline (always)] pub fn form (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: Form) } # [doc = "Acknowledgment Error"] # [inline (always)] pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: Ack) } # [doc = "Bit recessive Error"] # [inline (always)] pub fn bit_recessive (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: BitRecessive) } # [doc = "Bit dominant Error"] # [inline (always)] pub fn bit_dominant (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: BitDominant) } # [doc = "CRC Error"] # [inline (always)] pub fn crc (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: Crc) } # [doc = "Set by software"] # [inline (always)] pub fn custom (self) -> & 'a mut crate :: W < REG > { self . variant (Lec :: Custom) } } # [doc = "Field `TEC` reader - TEC"] pub type TecR = crate :: FieldReader ; # [doc = "Field `REC` reader - REC"] pub type RecR = crate :: FieldReader ; impl R { # [doc = "Bit 0 - EWGF"] # [inline (always)] pub fn ewgf (& self) -> EwgfR { EwgfR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EPVF"] # [inline (always)] pub fn epvf (& self) -> EpvfR { EpvfR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - BOFF"] # [inline (always)] pub fn boff (& self) -> BoffR { BoffR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:6 - LEC"] # [inline (always)] pub fn lec (& self) -> LecR { LecR :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bits 16:23 - TEC"] # [inline (always)] pub fn tec (& self) -> TecR { TecR :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:31 - REC"] # [inline (always)] pub fn rec (& self) -> RecR { RecR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bits 4:6 - LEC"] # [inline (always)] pub fn lec (& mut self) -> LecW < EsrSpec > { LecW :: new (self , 4) } } # [doc = "interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`esr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`esr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EsrSpec ; impl crate :: RegisterSpec for EsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`esr::R`](R) reader structure"] impl crate :: Readable for EsrSpec { } # [doc = "`write(|w| ..)` method takes [`esr::W`](W) writer structure"] impl crate :: Writable for EsrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets ESR to value 0"] impl crate :: Resettable for EsrSpec { }
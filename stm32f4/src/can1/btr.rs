# [doc = "Register `BTR` reader"] pub type R = crate :: R < BtrSpec > ; # [doc = "Register `BTR` writer"] pub type W = crate :: W < BtrSpec > ; # [doc = "Field `BRP` reader - BRP"] pub type BrpR = crate :: FieldReader < u16 > ; # [doc = "Field `BRP` writer - BRP"] pub type BrpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `TS1` reader - TS1"] pub type Ts1R = crate :: FieldReader ; # [doc = "Field `TS1` writer - TS1"] pub type Ts1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TS2` reader - TS2"] pub type Ts2R = crate :: FieldReader ; # [doc = "Field `TS2` writer - TS2"] pub type Ts2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `SJW` reader - SJW"] pub type SjwR = crate :: FieldReader ; # [doc = "Field `SJW` writer - SJW"] pub type SjwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "LBKM\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lbkm { # [doc = "0: Loop Back Mode disabled"] Disabled = 0 , # [doc = "1: Loop Back Mode enabled"] Enabled = 1 , } impl From < Lbkm > for bool { # [inline (always)] fn from (variant : Lbkm) -> Self { variant as u8 != 0 } } # [doc = "Field `LBKM` reader - LBKM"] pub type LbkmR = crate :: BitReader < Lbkm > ; impl LbkmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lbkm { match self . bits { false => Lbkm :: Disabled , true => Lbkm :: Enabled , } } # [doc = "Loop Back Mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Lbkm :: Disabled } # [doc = "Loop Back Mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Lbkm :: Enabled } } # [doc = "Field `LBKM` writer - LBKM"] pub type LbkmW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbkm > ; impl < 'a , REG > LbkmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Loop Back Mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Lbkm :: Disabled) } # [doc = "Loop Back Mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Lbkm :: Enabled) } } # [doc = "SILM\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Silm { # [doc = "0: Normal operation"] Normal = 0 , # [doc = "1: Silent Mode"] Silent = 1 , } impl From < Silm > for bool { # [inline (always)] fn from (variant : Silm) -> Self { variant as u8 != 0 } } # [doc = "Field `SILM` reader - SILM"] pub type SilmR = crate :: BitReader < Silm > ; impl SilmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Silm { match self . bits { false => Silm :: Normal , true => Silm :: Silent , } } # [doc = "Normal operation"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Silm :: Normal } # [doc = "Silent Mode"] # [inline (always)] pub fn is_silent (& self) -> bool { * self == Silm :: Silent } } # [doc = "Field `SILM` writer - SILM"] pub type SilmW < 'a , REG > = crate :: BitWriter < 'a , REG , Silm > ; impl < 'a , REG > SilmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal operation"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Silm :: Normal) } # [doc = "Silent Mode"] # [inline (always)] pub fn silent (self) -> & 'a mut crate :: W < REG > { self . variant (Silm :: Silent) } } impl R { # [doc = "Bits 0:9 - BRP"] # [inline (always)] pub fn brp (& self) -> BrpR { BrpR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 16:19 - TS1"] # [inline (always)] pub fn ts1 (& self) -> Ts1R { Ts1R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:22 - TS2"] # [inline (always)] pub fn ts2 (& self) -> Ts2R { Ts2R :: new (((self . bits >> 20) & 7) as u8) } # [doc = "Bits 24:25 - SJW"] # [inline (always)] pub fn sjw (& self) -> SjwR { SjwR :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bit 30 - LBKM"] # [inline (always)] pub fn lbkm (& self) -> LbkmR { LbkmR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - SILM"] # [inline (always)] pub fn silm (& self) -> SilmR { SilmR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - BRP"] # [inline (always)] pub fn brp (& mut self) -> BrpW < BtrSpec > { BrpW :: new (self , 0) } # [doc = "Bits 16:19 - TS1"] # [inline (always)] pub fn ts1 (& mut self) -> Ts1W < BtrSpec > { Ts1W :: new (self , 16) } # [doc = "Bits 20:22 - TS2"] # [inline (always)] pub fn ts2 (& mut self) -> Ts2W < BtrSpec > { Ts2W :: new (self , 20) } # [doc = "Bits 24:25 - SJW"] # [inline (always)] pub fn sjw (& mut self) -> SjwW < BtrSpec > { SjwW :: new (self , 24) } # [doc = "Bit 30 - LBKM"] # [inline (always)] pub fn lbkm (& mut self) -> LbkmW < BtrSpec > { LbkmW :: new (self , 30) } # [doc = "Bit 31 - SILM"] # [inline (always)] pub fn silm (& mut self) -> SilmW < BtrSpec > { SilmW :: new (self , 31) } } # [doc = "bit timing register\n\nYou can [`read`](crate::Reg::read) this register and get [`btr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`btr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BtrSpec ; impl crate :: RegisterSpec for BtrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`btr::R`](R) reader structure"] impl crate :: Readable for BtrSpec { } # [doc = "`write(|w| ..)` method takes [`btr::W`](W) writer structure"] impl crate :: Writable for BtrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets BTR to value 0"] impl crate :: Resettable for BtrSpec { }
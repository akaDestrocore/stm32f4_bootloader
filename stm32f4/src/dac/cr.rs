# [doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ; # [doc = "DAC channel1 enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum En1 { # [doc = "0: DAC channel X disabled"] Disabled = 0 , # [doc = "1: DAC channel X enabled"] Enabled = 1 , } impl From < En1 > for bool { # [inline (always)] fn from (variant : En1) -> Self { variant as u8 != 0 } } # [doc = "Field `EN1` reader - DAC channel1 enable"] pub type En1R = crate :: BitReader < En1 > ; impl En1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> En1 { match self . bits { false => En1 :: Disabled , true => En1 :: Enabled , } } # [doc = "DAC channel X disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == En1 :: Disabled } # [doc = "DAC channel X enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == En1 :: Enabled } } # [doc = "Field `EN1` writer - DAC channel1 enable"] pub type En1W < 'a , REG > = crate :: BitWriter < 'a , REG , En1 > ; impl < 'a , REG > En1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DAC channel X disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (En1 :: Disabled) } # [doc = "DAC channel X enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (En1 :: Enabled) } } # [doc = "DAC channel1 output buffer disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Boff1 { # [doc = "0: DAC channel X output buffer enabled"] Enabled = 0 , # [doc = "1: DAC channel X output buffer disabled"] Disabled = 1 , } impl From < Boff1 > for bool { # [inline (always)] fn from (variant : Boff1) -> Self { variant as u8 != 0 } } # [doc = "Field `BOFF1` reader - DAC channel1 output buffer disable"] pub type Boff1R = crate :: BitReader < Boff1 > ; impl Boff1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Boff1 { match self . bits { false => Boff1 :: Enabled , true => Boff1 :: Disabled , } } # [doc = "DAC channel X output buffer enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Boff1 :: Enabled } # [doc = "DAC channel X output buffer disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Boff1 :: Disabled } } # [doc = "Field `BOFF1` writer - DAC channel1 output buffer disable"] pub type Boff1W < 'a , REG > = crate :: BitWriter < 'a , REG , Boff1 > ; impl < 'a , REG > Boff1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DAC channel X output buffer enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Boff1 :: Enabled) } # [doc = "DAC channel X output buffer disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Boff1 :: Disabled) } } # [doc = "DAC channel1 trigger enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ten1 { # [doc = "0: DAC channel X trigger disabled"] Disabled = 0 , # [doc = "1: DAC channel X trigger enabled"] Enabled = 1 , } impl From < Ten1 > for bool { # [inline (always)] fn from (variant : Ten1) -> Self { variant as u8 != 0 } } # [doc = "Field `TEN1` reader - DAC channel1 trigger enable"] pub type Ten1R = crate :: BitReader < Ten1 > ; impl Ten1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ten1 { match self . bits { false => Ten1 :: Disabled , true => Ten1 :: Enabled , } } # [doc = "DAC channel X trigger disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ten1 :: Disabled } # [doc = "DAC channel X trigger enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ten1 :: Enabled } } # [doc = "Field `TEN1` writer - DAC channel1 trigger enable"] pub type Ten1W < 'a , REG > = crate :: BitWriter < 'a , REG , Ten1 > ; impl < 'a , REG > Ten1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DAC channel X trigger disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ten1 :: Disabled) } # [doc = "DAC channel X trigger enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ten1 :: Enabled) } } # [doc = "DAC channel1 trigger selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Tsel1 { # [doc = "0: Timer 6 TRGO event"] Tim6Trgo = 0 , # [doc = "1: Timer 3 TRGO event"] Tim3Trgo = 1 , # [doc = "2: Timer 7 TRGO event"] Tim7Trgo = 2 , # [doc = "3: Timer 15 TRGO event"] Tim15Trgo = 3 , # [doc = "4: Timer 2 TRGO event"] Tim2Trgo = 4 , # [doc = "6: EXTI line9"] Exti9 = 6 , # [doc = "7: Software trigger"] Software = 7 , } impl From < Tsel1 > for u8 { # [inline (always)] fn from (variant : Tsel1) -> Self { variant as _ } } impl crate :: FieldSpec for Tsel1 { type Ux = u8 ; } impl crate :: IsEnum for Tsel1 { } # [doc = "Field `TSEL1` reader - DAC channel1 trigger selection"] pub type Tsel1R = crate :: FieldReader < Tsel1 > ; impl Tsel1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Tsel1 > { match self . bits { 0 => Some (Tsel1 :: Tim6Trgo) , 1 => Some (Tsel1 :: Tim3Trgo) , 2 => Some (Tsel1 :: Tim7Trgo) , 3 => Some (Tsel1 :: Tim15Trgo) , 4 => Some (Tsel1 :: Tim2Trgo) , 6 => Some (Tsel1 :: Exti9) , 7 => Some (Tsel1 :: Software) , _ => None , } } # [doc = "Timer 6 TRGO event"] # [inline (always)] pub fn is_tim6_trgo (& self) -> bool { * self == Tsel1 :: Tim6Trgo } # [doc = "Timer 3 TRGO event"] # [inline (always)] pub fn is_tim3_trgo (& self) -> bool { * self == Tsel1 :: Tim3Trgo } # [doc = "Timer 7 TRGO event"] # [inline (always)] pub fn is_tim7_trgo (& self) -> bool { * self == Tsel1 :: Tim7Trgo } # [doc = "Timer 15 TRGO event"] # [inline (always)] pub fn is_tim15_trgo (& self) -> bool { * self == Tsel1 :: Tim15Trgo } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn is_tim2_trgo (& self) -> bool { * self == Tsel1 :: Tim2Trgo } # [doc = "EXTI line9"] # [inline (always)] pub fn is_exti9 (& self) -> bool { * self == Tsel1 :: Exti9 } # [doc = "Software trigger"] # [inline (always)] pub fn is_software (& self) -> bool { * self == Tsel1 :: Software } } # [doc = "Field `TSEL1` writer - DAC channel1 trigger selection"] pub type Tsel1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Tsel1 > ; impl < 'a , REG > Tsel1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Timer 6 TRGO event"] # [inline (always)] pub fn tim6_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Tim6Trgo) } # [doc = "Timer 3 TRGO event"] # [inline (always)] pub fn tim3_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Tim3Trgo) } # [doc = "Timer 7 TRGO event"] # [inline (always)] pub fn tim7_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Tim7Trgo) } # [doc = "Timer 15 TRGO event"] # [inline (always)] pub fn tim15_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Tim15Trgo) } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn tim2_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Tim2Trgo) } # [doc = "EXTI line9"] # [inline (always)] pub fn exti9 (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Exti9) } # [doc = "Software trigger"] # [inline (always)] pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel1 :: Software) } } # [doc = "DAC channel1 noise/triangle wave generation enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Wave1 { # [doc = "0: Wave generation disabled"] Disabled = 0 , # [doc = "1: Noise wave generation enabled"] Noise = 1 , # [doc = "2: Triangle wave generation enabled"] Triangle = 2 , } impl From < Wave1 > for u8 { # [inline (always)] fn from (variant : Wave1) -> Self { variant as _ } } impl crate :: FieldSpec for Wave1 { type Ux = u8 ; } impl crate :: IsEnum for Wave1 { } # [doc = "Field `WAVE1` reader - DAC channel1 noise/triangle wave generation enable"] pub type Wave1R = crate :: FieldReader < Wave1 > ; impl Wave1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Wave1 > { match self . bits { 0 => Some (Wave1 :: Disabled) , 1 => Some (Wave1 :: Noise) , 2 => Some (Wave1 :: Triangle) , _ => None , } } # [doc = "Wave generation disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Wave1 :: Disabled } # [doc = "Noise wave generation enabled"] # [inline (always)] pub fn is_noise (& self) -> bool { * self == Wave1 :: Noise } # [doc = "Triangle wave generation enabled"] # [inline (always)] pub fn is_triangle (& self) -> bool { * self == Wave1 :: Triangle } } # [doc = "Field `WAVE1` writer - DAC channel1 noise/triangle wave generation enable"] pub type Wave1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Wave1 > ; impl < 'a , REG > Wave1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Wave generation disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wave1 :: Disabled) } # [doc = "Noise wave generation enabled"] # [inline (always)] pub fn noise (self) -> & 'a mut crate :: W < REG > { self . variant (Wave1 :: Noise) } # [doc = "Triangle wave generation enabled"] # [inline (always)] pub fn triangle (self) -> & 'a mut crate :: W < REG > { self . variant (Wave1 :: Triangle) } } # [doc = "Field `MAMP1` reader - DAC channel1 mask/amplitude selector"] pub type Mamp1R = crate :: FieldReader ; # [doc = "Field `MAMP1` writer - DAC channel1 mask/amplitude selector"] pub type Mamp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "DAC channel1 DMA enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaen1 { # [doc = "0: DAC channel X DMA mode disabled"] Disabled = 0 , # [doc = "1: DAC channel X DMA mode enabled"] Enabled = 1 , } impl From < Dmaen1 > for bool { # [inline (always)] fn from (variant : Dmaen1) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN1` reader - DAC channel1 DMA enable"] pub type Dmaen1R = crate :: BitReader < Dmaen1 > ; impl Dmaen1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaen1 { match self . bits { false => Dmaen1 :: Disabled , true => Dmaen1 :: Enabled , } } # [doc = "DAC channel X DMA mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmaen1 :: Disabled } # [doc = "DAC channel X DMA mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmaen1 :: Enabled } } # [doc = "Field `DMAEN1` writer - DAC channel1 DMA enable"] pub type Dmaen1W < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen1 > ; impl < 'a , REG > Dmaen1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DAC channel X DMA mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen1 :: Disabled) } # [doc = "DAC channel X DMA mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen1 :: Enabled) } } # [doc = "DAC channel1 DMA Underrun Interrupt enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaudrie1 { # [doc = "0: DAC channel X DMA Underrun Interrupt disabled"] Disabled = 0 , # [doc = "1: DAC channel X DMA Underrun Interrupt enabled"] Enabled = 1 , } impl From < Dmaudrie1 > for bool { # [inline (always)] fn from (variant : Dmaudrie1) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAUDRIE1` reader - DAC channel1 DMA Underrun Interrupt enable"] pub type Dmaudrie1R = crate :: BitReader < Dmaudrie1 > ; impl Dmaudrie1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaudrie1 { match self . bits { false => Dmaudrie1 :: Disabled , true => Dmaudrie1 :: Enabled , } } # [doc = "DAC channel X DMA Underrun Interrupt disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmaudrie1 :: Disabled } # [doc = "DAC channel X DMA Underrun Interrupt enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmaudrie1 :: Enabled } } # [doc = "Field `DMAUDRIE1` writer - DAC channel1 DMA Underrun Interrupt enable"] pub type Dmaudrie1W < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaudrie1 > ; impl < 'a , REG > Dmaudrie1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "DAC channel X DMA Underrun Interrupt disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaudrie1 :: Disabled) } # [doc = "DAC channel X DMA Underrun Interrupt enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaudrie1 :: Enabled) } } # [doc = "Field `EN2` reader - DAC channel2 enable"] pub use En1R as En2R ; # [doc = "Field `EN2` writer - DAC channel2 enable"] pub use En1W as En2W ; # [doc = "Field `BOFF2` reader - DAC channel2 output buffer disable"] pub use Boff1R as Boff2R ; # [doc = "Field `BOFF2` writer - DAC channel2 output buffer disable"] pub use Boff1W as Boff2W ; # [doc = "Field `TEN2` reader - DAC channel2 trigger enable"] pub use Ten1R as Ten2R ; # [doc = "Field `TEN2` writer - DAC channel2 trigger enable"] pub use Ten1W as Ten2W ; # [doc = "DAC channel2 trigger selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Tsel2 { # [doc = "0: Timer 6 TRGO event"] Tim6Trgo = 0 , # [doc = "1: Timer 8 TRGO event"] Tim8Trgo = 1 , # [doc = "2: Timer 7 TRGO event"] Tim7Trgo = 2 , # [doc = "3: Timer 5 TRGO event"] Tim5Trgo = 3 , # [doc = "4: Timer 2 TRGO event"] Tim2Trgo = 4 , # [doc = "5: Timer 4 TRGO event"] Tim4Trgo = 5 , # [doc = "6: EXTI line9"] Exti9 = 6 , # [doc = "7: Software trigger"] Software = 7 , } impl From < Tsel2 > for u8 { # [inline (always)] fn from (variant : Tsel2) -> Self { variant as _ } } impl crate :: FieldSpec for Tsel2 { type Ux = u8 ; } impl crate :: IsEnum for Tsel2 { } # [doc = "Field `TSEL2` reader - DAC channel2 trigger selection"] pub type Tsel2R = crate :: FieldReader < Tsel2 > ; impl Tsel2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Tsel2 { match self . bits { 0 => Tsel2 :: Tim6Trgo , 1 => Tsel2 :: Tim8Trgo , 2 => Tsel2 :: Tim7Trgo , 3 => Tsel2 :: Tim5Trgo , 4 => Tsel2 :: Tim2Trgo , 5 => Tsel2 :: Tim4Trgo , 6 => Tsel2 :: Exti9 , 7 => Tsel2 :: Software , _ => unreachable ! () , } } # [doc = "Timer 6 TRGO event"] # [inline (always)] pub fn is_tim6_trgo (& self) -> bool { * self == Tsel2 :: Tim6Trgo } # [doc = "Timer 8 TRGO event"] # [inline (always)] pub fn is_tim8_trgo (& self) -> bool { * self == Tsel2 :: Tim8Trgo } # [doc = "Timer 7 TRGO event"] # [inline (always)] pub fn is_tim7_trgo (& self) -> bool { * self == Tsel2 :: Tim7Trgo } # [doc = "Timer 5 TRGO event"] # [inline (always)] pub fn is_tim5_trgo (& self) -> bool { * self == Tsel2 :: Tim5Trgo } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn is_tim2_trgo (& self) -> bool { * self == Tsel2 :: Tim2Trgo } # [doc = "Timer 4 TRGO event"] # [inline (always)] pub fn is_tim4_trgo (& self) -> bool { * self == Tsel2 :: Tim4Trgo } # [doc = "EXTI line9"] # [inline (always)] pub fn is_exti9 (& self) -> bool { * self == Tsel2 :: Exti9 } # [doc = "Software trigger"] # [inline (always)] pub fn is_software (& self) -> bool { * self == Tsel2 :: Software } } # [doc = "Field `TSEL2` writer - DAC channel2 trigger selection"] pub type Tsel2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Tsel2 , crate :: Safe > ; impl < 'a , REG > Tsel2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Timer 6 TRGO event"] # [inline (always)] pub fn tim6_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim6Trgo) } # [doc = "Timer 8 TRGO event"] # [inline (always)] pub fn tim8_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim8Trgo) } # [doc = "Timer 7 TRGO event"] # [inline (always)] pub fn tim7_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim7Trgo) } # [doc = "Timer 5 TRGO event"] # [inline (always)] pub fn tim5_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim5Trgo) } # [doc = "Timer 2 TRGO event"] # [inline (always)] pub fn tim2_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim2Trgo) } # [doc = "Timer 4 TRGO event"] # [inline (always)] pub fn tim4_trgo (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Tim4Trgo) } # [doc = "EXTI line9"] # [inline (always)] pub fn exti9 (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Exti9) } # [doc = "Software trigger"] # [inline (always)] pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (Tsel2 :: Software) } } # [doc = "Field `WAVE2` reader - DAC channel2 noise/triangle wave generation enable"] pub use Wave1R as Wave2R ; # [doc = "Field `WAVE2` writer - DAC channel2 noise/triangle wave generation enable"] pub use Wave1W as Wave2W ; # [doc = "Field `MAMP2` reader - DAC channel2 mask/amplitude selector"] pub type Mamp2R = crate :: FieldReader ; # [doc = "Field `MAMP2` writer - DAC channel2 mask/amplitude selector"] pub type Mamp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `DMAEN2` reader - DAC channel2 DMA enable"] pub use Dmaen1R as Dmaen2R ; # [doc = "Field `DMAEN2` writer - DAC channel2 DMA enable"] pub use Dmaen1W as Dmaen2W ; # [doc = "Field `DMAUDRIE2` reader - DAC channel2 DMA underrun interrupt enable"] pub use Dmaudrie1R as Dmaudrie2R ; # [doc = "Field `DMAUDRIE2` writer - DAC channel2 DMA underrun interrupt enable"] pub use Dmaudrie1W as Dmaudrie2W ; impl R { # [doc = "Bit 0 - DAC channel1 enable"] # [inline (always)] pub fn en1 (& self) -> En1R { En1R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DAC channel1 output buffer disable"] # [inline (always)] pub fn boff1 (& self) -> Boff1R { Boff1R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DAC channel1 trigger enable"] # [inline (always)] pub fn ten1 (& self) -> Ten1R { Ten1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - DAC channel1 trigger selection"] # [inline (always)] pub fn tsel1 (& self) -> Tsel1R { Tsel1R :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"] # [inline (always)] pub fn wave1 (& self) -> Wave1R { Wave1R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"] # [inline (always)] pub fn mamp1 (& self) -> Mamp1R { Mamp1R :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 12 - DAC channel1 DMA enable"] # [inline (always)] pub fn dmaen1 (& self) -> Dmaen1R { Dmaen1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - DAC channel1 DMA Underrun Interrupt enable"] # [inline (always)] pub fn dmaudrie1 (& self) -> Dmaudrie1R { Dmaudrie1R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 16 - DAC channel2 enable"] # [inline (always)] pub fn en2 (& self) -> En2R { En2R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - DAC channel2 output buffer disable"] # [inline (always)] pub fn boff2 (& self) -> Boff2R { Boff2R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - DAC channel2 trigger enable"] # [inline (always)] pub fn ten2 (& self) -> Ten2R { Ten2R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bits 19:21 - DAC channel2 trigger selection"] # [inline (always)] pub fn tsel2 (& self) -> Tsel2R { Tsel2R :: new (((self . bits >> 19) & 7) as u8) } # [doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"] # [inline (always)] pub fn wave2 (& self) -> Wave2R { Wave2R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"] # [inline (always)] pub fn mamp2 (& self) -> Mamp2R { Mamp2R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bit 28 - DAC channel2 DMA enable"] # [inline (always)] pub fn dmaen2 (& self) -> Dmaen2R { Dmaen2R :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"] # [inline (always)] pub fn dmaudrie2 (& self) -> Dmaudrie2R { Dmaudrie2R :: new (((self . bits >> 29) & 1) != 0) } } impl W { # [doc = "Bit 0 - DAC channel1 enable"] # [inline (always)] pub fn en1 (& mut self) -> En1W < CrSpec > { En1W :: new (self , 0) } # [doc = "Bit 1 - DAC channel1 output buffer disable"] # [inline (always)] pub fn boff1 (& mut self) -> Boff1W < CrSpec > { Boff1W :: new (self , 1) } # [doc = "Bit 2 - DAC channel1 trigger enable"] # [inline (always)] pub fn ten1 (& mut self) -> Ten1W < CrSpec > { Ten1W :: new (self , 2) } # [doc = "Bits 3:5 - DAC channel1 trigger selection"] # [inline (always)] pub fn tsel1 (& mut self) -> Tsel1W < CrSpec > { Tsel1W :: new (self , 3) } # [doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"] # [inline (always)] pub fn wave1 (& mut self) -> Wave1W < CrSpec > { Wave1W :: new (self , 6) } # [doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"] # [inline (always)] pub fn mamp1 (& mut self) -> Mamp1W < CrSpec > { Mamp1W :: new (self , 8) } # [doc = "Bit 12 - DAC channel1 DMA enable"] # [inline (always)] pub fn dmaen1 (& mut self) -> Dmaen1W < CrSpec > { Dmaen1W :: new (self , 12) } # [doc = "Bit 13 - DAC channel1 DMA Underrun Interrupt enable"] # [inline (always)] pub fn dmaudrie1 (& mut self) -> Dmaudrie1W < CrSpec > { Dmaudrie1W :: new (self , 13) } # [doc = "Bit 16 - DAC channel2 enable"] # [inline (always)] pub fn en2 (& mut self) -> En2W < CrSpec > { En2W :: new (self , 16) } # [doc = "Bit 17 - DAC channel2 output buffer disable"] # [inline (always)] pub fn boff2 (& mut self) -> Boff2W < CrSpec > { Boff2W :: new (self , 17) } # [doc = "Bit 18 - DAC channel2 trigger enable"] # [inline (always)] pub fn ten2 (& mut self) -> Ten2W < CrSpec > { Ten2W :: new (self , 18) } # [doc = "Bits 19:21 - DAC channel2 trigger selection"] # [inline (always)] pub fn tsel2 (& mut self) -> Tsel2W < CrSpec > { Tsel2W :: new (self , 19) } # [doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"] # [inline (always)] pub fn wave2 (& mut self) -> Wave2W < CrSpec > { Wave2W :: new (self , 22) } # [doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"] # [inline (always)] pub fn mamp2 (& mut self) -> Mamp2W < CrSpec > { Mamp2W :: new (self , 24) } # [doc = "Bit 28 - DAC channel2 DMA enable"] # [inline (always)] pub fn dmaen2 (& mut self) -> Dmaen2W < CrSpec > { Dmaen2W :: new (self , 28) } # [doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"] # [inline (always)] pub fn dmaudrie2 (& mut self) -> Dmaudrie2W < CrSpec > { Dmaudrie2W :: new (self , 29) } } # [doc = "control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { }
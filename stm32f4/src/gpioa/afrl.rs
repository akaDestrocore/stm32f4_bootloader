# [doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ; # [doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ; # [doc = "Alternate function selection for port x bit y (y = 0..7)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum AlternateFunction { # [doc = "0: AF0"] Af0 = 0 , # [doc = "1: AF1"] Af1 = 1 , # [doc = "2: AF2"] Af2 = 2 , # [doc = "3: AF3"] Af3 = 3 , # [doc = "4: AF4"] Af4 = 4 , # [doc = "5: AF5"] Af5 = 5 , # [doc = "6: AF6"] Af6 = 6 , # [doc = "7: AF7"] Af7 = 7 , # [doc = "8: AF8"] Af8 = 8 , # [doc = "9: AF9"] Af9 = 9 , # [doc = "10: AF10"] Af10 = 10 , # [doc = "11: AF11"] Af11 = 11 , # [doc = "12: AF12"] Af12 = 12 , # [doc = "13: AF13"] Af13 = 13 , # [doc = "14: AF14"] Af14 = 14 , # [doc = "15: AF15"] Af15 = 15 , } impl From < AlternateFunction > for u8 { # [inline (always)] fn from (variant : AlternateFunction) -> Self { variant as _ } } impl crate :: FieldSpec for AlternateFunction { type Ux = u8 ; } impl crate :: IsEnum for AlternateFunction { } # [doc = "Field `AFR(L0,L1,L2,L3,L4,L5,L6,L7)` reader - Alternate function selection for port x bit y (y = 0..7)"] pub type AfrR = crate :: FieldReader < AlternateFunction > ; impl AfrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> AlternateFunction { match self . bits { 0 => AlternateFunction :: Af0 , 1 => AlternateFunction :: Af1 , 2 => AlternateFunction :: Af2 , 3 => AlternateFunction :: Af3 , 4 => AlternateFunction :: Af4 , 5 => AlternateFunction :: Af5 , 6 => AlternateFunction :: Af6 , 7 => AlternateFunction :: Af7 , 8 => AlternateFunction :: Af8 , 9 => AlternateFunction :: Af9 , 10 => AlternateFunction :: Af10 , 11 => AlternateFunction :: Af11 , 12 => AlternateFunction :: Af12 , 13 => AlternateFunction :: Af13 , 14 => AlternateFunction :: Af14 , 15 => AlternateFunction :: Af15 , _ => unreachable ! () , } } # [doc = "AF0"] # [inline (always)] pub fn is_af0 (& self) -> bool { * self == AlternateFunction :: Af0 } # [doc = "AF1"] # [inline (always)] pub fn is_af1 (& self) -> bool { * self == AlternateFunction :: Af1 } # [doc = "AF2"] # [inline (always)] pub fn is_af2 (& self) -> bool { * self == AlternateFunction :: Af2 } # [doc = "AF3"] # [inline (always)] pub fn is_af3 (& self) -> bool { * self == AlternateFunction :: Af3 } # [doc = "AF4"] # [inline (always)] pub fn is_af4 (& self) -> bool { * self == AlternateFunction :: Af4 } # [doc = "AF5"] # [inline (always)] pub fn is_af5 (& self) -> bool { * self == AlternateFunction :: Af5 } # [doc = "AF6"] # [inline (always)] pub fn is_af6 (& self) -> bool { * self == AlternateFunction :: Af6 } # [doc = "AF7"] # [inline (always)] pub fn is_af7 (& self) -> bool { * self == AlternateFunction :: Af7 } # [doc = "AF8"] # [inline (always)] pub fn is_af8 (& self) -> bool { * self == AlternateFunction :: Af8 } # [doc = "AF9"] # [inline (always)] pub fn is_af9 (& self) -> bool { * self == AlternateFunction :: Af9 } # [doc = "AF10"] # [inline (always)] pub fn is_af10 (& self) -> bool { * self == AlternateFunction :: Af10 } # [doc = "AF11"] # [inline (always)] pub fn is_af11 (& self) -> bool { * self == AlternateFunction :: Af11 } # [doc = "AF12"] # [inline (always)] pub fn is_af12 (& self) -> bool { * self == AlternateFunction :: Af12 } # [doc = "AF13"] # [inline (always)] pub fn is_af13 (& self) -> bool { * self == AlternateFunction :: Af13 } # [doc = "AF14"] # [inline (always)] pub fn is_af14 (& self) -> bool { * self == AlternateFunction :: Af14 } # [doc = "AF15"] # [inline (always)] pub fn is_af15 (& self) -> bool { * self == AlternateFunction :: Af15 } } # [doc = "Field `AFR(L0,L1,L2,L3,L4,L5,L6,L7)` writer - Alternate function selection for port x bit y (y = 0..7)"] pub type AfrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , AlternateFunction , crate :: Safe > ; impl < 'a , REG > AfrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "AF0"] # [inline (always)] pub fn af0 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af0) } # [doc = "AF1"] # [inline (always)] pub fn af1 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af1) } # [doc = "AF2"] # [inline (always)] pub fn af2 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af2) } # [doc = "AF3"] # [inline (always)] pub fn af3 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af3) } # [doc = "AF4"] # [inline (always)] pub fn af4 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af4) } # [doc = "AF5"] # [inline (always)] pub fn af5 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af5) } # [doc = "AF6"] # [inline (always)] pub fn af6 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af6) } # [doc = "AF7"] # [inline (always)] pub fn af7 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af7) } # [doc = "AF8"] # [inline (always)] pub fn af8 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af8) } # [doc = "AF9"] # [inline (always)] pub fn af9 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af9) } # [doc = "AF10"] # [inline (always)] pub fn af10 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af10) } # [doc = "AF11"] # [inline (always)] pub fn af11 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af11) } # [doc = "AF12"] # [inline (always)] pub fn af12 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af12) } # [doc = "AF13"] # [inline (always)] pub fn af13 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af13) } # [doc = "AF14"] # [inline (always)] pub fn af14 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af14) } # [doc = "AF15"] # [inline (always)] pub fn af15 (self) -> & 'a mut crate :: W < REG > { self . variant (AlternateFunction :: Af15) } } impl R { # [doc = "Alternate function selection for port x bit y (y = 0..7)"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `AFRL0` field.</div>"] # [inline (always)] pub fn afr (& self , n : u8) -> AfrR { # [allow (clippy :: no_effect)] [() ; 8] [n as usize] ; AfrR :: new (((self . bits >> (n * 4)) & 0x0f) as u8) } # [doc = "Iterator for array of:"] # [doc = "Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afr_iter (& self) -> impl Iterator < Item = AfrR > + '_ { (0 .. 8) . map (move | n | AfrR :: new (((self . bits >> (n * 4)) & 0x0f) as u8)) } # [doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl0 (& self) -> AfrR { AfrR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl1 (& self) -> AfrR { AfrR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl2 (& self) -> AfrR { AfrR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl3 (& self) -> AfrR { AfrR :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl4 (& self) -> AfrR { AfrR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl5 (& self) -> AfrR { AfrR :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl6 (& self) -> AfrR { AfrR :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl7 (& self) -> AfrR { AfrR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Alternate function selection for port x bit y (y = 0..7)"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `AFRL0` field.</div>"] # [inline (always)] pub fn afr (& mut self , n : u8) -> AfrW < AfrlSpec > { # [allow (clippy :: no_effect)] [() ; 8] [n as usize] ; AfrW :: new (self , n * 4) } # [doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl0 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 0) } # [doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl1 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 4) } # [doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl2 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 8) } # [doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl3 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 12) } # [doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl4 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 16) } # [doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl5 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 20) } # [doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl6 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 24) } # [doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"] # [inline (always)] pub fn afrl7 (& mut self) -> AfrW < AfrlSpec > { AfrW :: new (self , 28) } } # [doc = "GPIO alternate function low register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { } # [doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { }
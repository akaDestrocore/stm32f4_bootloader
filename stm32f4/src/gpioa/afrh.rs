# [doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ; # [doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ; # [doc = "Alternate function selection for port x bit y (y = 8..15)"] pub use super :: afrl :: AlternateFunction as AlternateFunction ; # [doc = "Field `AFR(H8,H9,H10,H11,H12,H13,H14,H15)` reader - Alternate function selection for port x bit y (y = 8..15)"] pub use super :: afrl :: AfrR as AfrR ; # [doc = "Field `AFR(H8,H9,H10,H11,H12,H13,H14,H15)` writer - Alternate function selection for port x bit y (y = 8..15)"] pub use super :: afrl :: AfrW as AfrW ; impl R { # [doc = "Alternate function selection for port x bit y (y = 8..15)"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `AFRH8` field.</div>"] # [inline (always)] pub fn afr (& self , n : u8) -> AfrR { # [allow (clippy :: no_effect)] [() ; 8] [n as usize] ; AfrR :: new (((self . bits >> (n * 4)) & 0x0f) as u8) } # [doc = "Iterator for array of:"] # [doc = "Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afr_iter (& self) -> impl Iterator < Item = AfrR > + '_ { (0 .. 8) . map (move | n | AfrR :: new (((self . bits >> (n * 4)) & 0x0f) as u8)) } # [doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh8 (& self) -> AfrR { AfrR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh9 (& self) -> AfrR { AfrR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh10 (& self) -> AfrR { AfrR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh11 (& self) -> AfrR { AfrR :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh12 (& self) -> AfrR { AfrR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh13 (& self) -> AfrR { AfrR :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh14 (& self) -> AfrR { AfrR :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh15 (& self) -> AfrR { AfrR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Alternate function selection for port x bit y (y = 8..15)"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `AFRH8` field.</div>"] # [inline (always)] pub fn afr (& mut self , n : u8) -> AfrW < AfrhSpec > { # [allow (clippy :: no_effect)] [() ; 8] [n as usize] ; AfrW :: new (self , n * 4) } # [doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh8 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 0) } # [doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh9 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 4) } # [doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh10 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 8) } # [doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh11 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 12) } # [doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh12 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 16) } # [doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh13 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 20) } # [doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh14 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 24) } # [doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"] # [inline (always)] pub fn afrh15 (& mut self) -> AfrW < AfrhSpec > { AfrW :: new (self , 28) } } # [doc = "GPIO alternate function high register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { } # [doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { }
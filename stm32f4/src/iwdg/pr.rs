# [doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ; # [doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ; # [doc = "Prescaler divider\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pr { # [doc = "0: Divider /4"] DivideBy4 = 0 , # [doc = "1: Divider /8"] DivideBy8 = 1 , # [doc = "2: Divider /16"] DivideBy16 = 2 , # [doc = "3: Divider /32"] DivideBy32 = 3 , # [doc = "4: Divider /64"] DivideBy64 = 4 , # [doc = "5: Divider /128"] DivideBy128 = 5 , # [doc = "6: Divider /256"] DivideBy256 = 6 , } impl From < Pr > for u8 { # [inline (always)] fn from (variant : Pr) -> Self { variant as _ } } impl crate :: FieldSpec for Pr { type Ux = u8 ; } impl crate :: IsEnum for Pr { } # [doc = "Field `PR` reader - Prescaler divider"] pub type PrR = crate :: FieldReader < Pr > ; impl PrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pr { match self . bits { 0 => Pr :: DivideBy4 , 1 => Pr :: DivideBy8 , 2 => Pr :: DivideBy16 , 3 => Pr :: DivideBy32 , 4 => Pr :: DivideBy64 , 5 => Pr :: DivideBy128 , _ => Pr :: DivideBy256 , } } # [doc = "Divider /4"] # [inline (always)] pub fn is_divide_by4 (& self) -> bool { * self == Pr :: DivideBy4 } # [doc = "Divider /8"] # [inline (always)] pub fn is_divide_by8 (& self) -> bool { * self == Pr :: DivideBy8 } # [doc = "Divider /16"] # [inline (always)] pub fn is_divide_by16 (& self) -> bool { * self == Pr :: DivideBy16 } # [doc = "Divider /32"] # [inline (always)] pub fn is_divide_by32 (& self) -> bool { * self == Pr :: DivideBy32 } # [doc = "Divider /64"] # [inline (always)] pub fn is_divide_by64 (& self) -> bool { * self == Pr :: DivideBy64 } # [doc = "Divider /128"] # [inline (always)] pub fn is_divide_by128 (& self) -> bool { * self == Pr :: DivideBy128 } # [doc = "Divider /256"] # [inline (always)] pub fn is_divide_by256 (& self) -> bool { matches ! (self . variant () , Pr :: DivideBy256) } } # [doc = "Field `PR` writer - Prescaler divider"] pub type PrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Pr , crate :: Safe > ; impl < 'a , REG > PrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Divider /4"] # [inline (always)] pub fn divide_by4 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy4) } # [doc = "Divider /8"] # [inline (always)] pub fn divide_by8 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy8) } # [doc = "Divider /16"] # [inline (always)] pub fn divide_by16 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy16) } # [doc = "Divider /32"] # [inline (always)] pub fn divide_by32 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy32) } # [doc = "Divider /64"] # [inline (always)] pub fn divide_by64 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy64) } # [doc = "Divider /128"] # [inline (always)] pub fn divide_by128 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy128) } # [doc = "Divider /256"] # [inline (always)] pub fn divide_by256 (self) -> & 'a mut crate :: W < REG > { self . variant (Pr :: DivideBy256) } } impl R { # [doc = "Bits 0:2 - Prescaler divider"] # [inline (always)] pub fn pr (& self) -> PrR { PrR :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Prescaler divider"] # [inline (always)] pub fn pr (& mut self) -> PrW < PrSpec > { PrW :: new (self , 0) } } # [doc = "Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u16 ; } # [doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { } # [doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { }
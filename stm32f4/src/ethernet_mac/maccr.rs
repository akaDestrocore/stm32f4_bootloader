# [doc = "Register `MACCR` reader"] pub type R = crate :: R < MaccrSpec > ; # [doc = "Register `MACCR` writer"] pub type W = crate :: W < MaccrSpec > ; # [doc = "Receiver enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Re { # [doc = "0: MAC receive state machine is disabled after the completion of the reception of the current frame"] Disabled = 0 , # [doc = "1: MAC receive state machine is enabled"] Enabled = 1 , } impl From < Re > for bool { # [inline (always)] fn from (variant : Re) -> Self { variant as u8 != 0 } } # [doc = "Field `RE` reader - Receiver enable"] pub type ReR = crate :: BitReader < Re > ; impl ReR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Re { match self . bits { false => Re :: Disabled , true => Re :: Enabled , } } # [doc = "MAC receive state machine is disabled after the completion of the reception of the current frame"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Re :: Disabled } # [doc = "MAC receive state machine is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Re :: Enabled } } # [doc = "Field `RE` writer - Receiver enable"] pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG , Re > ; impl < 'a , REG > ReW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC receive state machine is disabled after the completion of the reception of the current frame"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Disabled) } # [doc = "MAC receive state machine is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Enabled) } } # [doc = "Transmitter enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Te { # [doc = "0: MAC transmit state machine is disabled after completion of the transmission of the current frame"] Disabled = 0 , # [doc = "1: MAC transmit state machine is enabled"] Enabled = 1 , } impl From < Te > for bool { # [inline (always)] fn from (variant : Te) -> Self { variant as u8 != 0 } } # [doc = "Field `TE` reader - Transmitter enable"] pub type TeR = crate :: BitReader < Te > ; impl TeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Te { match self . bits { false => Te :: Disabled , true => Te :: Enabled , } } # [doc = "MAC transmit state machine is disabled after completion of the transmission of the current frame"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Te :: Disabled } # [doc = "MAC transmit state machine is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Te :: Enabled } } # [doc = "Field `TE` writer - Transmitter enable"] pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG , Te > ; impl < 'a , REG > TeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC transmit state machine is disabled after completion of the transmission of the current frame"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Disabled) } # [doc = "MAC transmit state machine is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Enabled) } } # [doc = "Deferral check\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dc { # [doc = "0: MAC defers until CRS signal goes inactive"] Disabled = 0 , # [doc = "1: Deferral check function enabled"] Enabled = 1 , } impl From < Dc > for bool { # [inline (always)] fn from (variant : Dc) -> Self { variant as u8 != 0 } } # [doc = "Field `DC` reader - Deferral check"] pub type DcR = crate :: BitReader < Dc > ; impl DcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dc { match self . bits { false => Dc :: Disabled , true => Dc :: Enabled , } } # [doc = "MAC defers until CRS signal goes inactive"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dc :: Disabled } # [doc = "Deferral check function enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dc :: Enabled } } # [doc = "Field `DC` writer - Deferral check"] pub type DcW < 'a , REG > = crate :: BitWriter < 'a , REG , Dc > ; impl < 'a , REG > DcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC defers until CRS signal goes inactive"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dc :: Disabled) } # [doc = "Deferral check function enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dc :: Enabled) } } # [doc = "Back-off limit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Bl { # [doc = "0: For retransmission n, wait up to 2^min(n, 10) time slots"] Bl10 = 0 , # [doc = "1: For retransmission n, wait up to 2^min(n, 8) time slots"] Bl8 = 1 , # [doc = "2: For retransmission n, wait up to 2^min(n, 4) time slots"] Bl4 = 2 , # [doc = "3: For retransmission n, wait up to 2^min(n, 1) time slots"] Bl1 = 3 , } impl From < Bl > for u8 { # [inline (always)] fn from (variant : Bl) -> Self { variant as _ } } impl crate :: FieldSpec for Bl { type Ux = u8 ; } impl crate :: IsEnum for Bl { } # [doc = "Field `BL` reader - Back-off limit"] pub type BlR = crate :: FieldReader < Bl > ; impl BlR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bl { match self . bits { 0 => Bl :: Bl10 , 1 => Bl :: Bl8 , 2 => Bl :: Bl4 , 3 => Bl :: Bl1 , _ => unreachable ! () , } } # [doc = "For retransmission n, wait up to 2^min(n, 10) time slots"] # [inline (always)] pub fn is_bl10 (& self) -> bool { * self == Bl :: Bl10 } # [doc = "For retransmission n, wait up to 2^min(n, 8) time slots"] # [inline (always)] pub fn is_bl8 (& self) -> bool { * self == Bl :: Bl8 } # [doc = "For retransmission n, wait up to 2^min(n, 4) time slots"] # [inline (always)] pub fn is_bl4 (& self) -> bool { * self == Bl :: Bl4 } # [doc = "For retransmission n, wait up to 2^min(n, 1) time slots"] # [inline (always)] pub fn is_bl1 (& self) -> bool { * self == Bl :: Bl1 } } # [doc = "Field `BL` writer - Back-off limit"] pub type BlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Bl , crate :: Safe > ; impl < 'a , REG > BlW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "For retransmission n, wait up to 2^min(n, 10) time slots"] # [inline (always)] pub fn bl10 (self) -> & 'a mut crate :: W < REG > { self . variant (Bl :: Bl10) } # [doc = "For retransmission n, wait up to 2^min(n, 8) time slots"] # [inline (always)] pub fn bl8 (self) -> & 'a mut crate :: W < REG > { self . variant (Bl :: Bl8) } # [doc = "For retransmission n, wait up to 2^min(n, 4) time slots"] # [inline (always)] pub fn bl4 (self) -> & 'a mut crate :: W < REG > { self . variant (Bl :: Bl4) } # [doc = "For retransmission n, wait up to 2^min(n, 1) time slots"] # [inline (always)] pub fn bl1 (self) -> & 'a mut crate :: W < REG > { self . variant (Bl :: Bl1) } } # [doc = "Automatic pad/CRC stripping\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Apcs { # [doc = "0: MAC passes all incoming frames unmodified"] Disabled = 0 , # [doc = "1: MAC strips the Pad/FCS field on incoming frames only for lengths less than or equal to 1500 bytes"] Strip = 1 , } impl From < Apcs > for bool { # [inline (always)] fn from (variant : Apcs) -> Self { variant as u8 != 0 } } # [doc = "Field `APCS` reader - Automatic pad/CRC stripping"] pub type ApcsR = crate :: BitReader < Apcs > ; impl ApcsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Apcs { match self . bits { false => Apcs :: Disabled , true => Apcs :: Strip , } } # [doc = "MAC passes all incoming frames unmodified"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Apcs :: Disabled } # [doc = "MAC strips the Pad/FCS field on incoming frames only for lengths less than or equal to 1500 bytes"] # [inline (always)] pub fn is_strip (& self) -> bool { * self == Apcs :: Strip } } # [doc = "Field `APCS` writer - Automatic pad/CRC stripping"] pub type ApcsW < 'a , REG > = crate :: BitWriter < 'a , REG , Apcs > ; impl < 'a , REG > ApcsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC passes all incoming frames unmodified"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Apcs :: Disabled) } # [doc = "MAC strips the Pad/FCS field on incoming frames only for lengths less than or equal to 1500 bytes"] # [inline (always)] pub fn strip (self) -> & 'a mut crate :: W < REG > { self . variant (Apcs :: Strip) } } # [doc = "Retry disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rd { # [doc = "0: MAC attempts retries based on the settings of BL"] Enabled = 0 , # [doc = "1: MAC attempts only 1 transmission"] Disabled = 1 , } impl From < Rd > for bool { # [inline (always)] fn from (variant : Rd) -> Self { variant as u8 != 0 } } # [doc = "Field `RD` reader - Retry disable"] pub type RdR = crate :: BitReader < Rd > ; impl RdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rd { match self . bits { false => Rd :: Enabled , true => Rd :: Disabled , } } # [doc = "MAC attempts retries based on the settings of BL"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rd :: Enabled } # [doc = "MAC attempts only 1 transmission"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rd :: Disabled } } # [doc = "Field `RD` writer - Retry disable"] pub type RdW < 'a , REG > = crate :: BitWriter < 'a , REG , Rd > ; impl < 'a , REG > RdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC attempts retries based on the settings of BL"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rd :: Enabled) } # [doc = "MAC attempts only 1 transmission"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rd :: Disabled) } } # [doc = "IPv4 checksum offload\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ipco { # [doc = "0: IPv4 checksum offload disabled"] Disabled = 0 , # [doc = "1: IPv4 checksums are checked in received frames"] Offload = 1 , } impl From < Ipco > for bool { # [inline (always)] fn from (variant : Ipco) -> Self { variant as u8 != 0 } } # [doc = "Field `IPCO` reader - IPv4 checksum offload"] pub type IpcoR = crate :: BitReader < Ipco > ; impl IpcoR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ipco { match self . bits { false => Ipco :: Disabled , true => Ipco :: Offload , } } # [doc = "IPv4 checksum offload disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ipco :: Disabled } # [doc = "IPv4 checksums are checked in received frames"] # [inline (always)] pub fn is_offload (& self) -> bool { * self == Ipco :: Offload } } # [doc = "Field `IPCO` writer - IPv4 checksum offload"] pub type IpcoW < 'a , REG > = crate :: BitWriter < 'a , REG , Ipco > ; impl < 'a , REG > IpcoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "IPv4 checksum offload disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ipco :: Disabled) } # [doc = "IPv4 checksums are checked in received frames"] # [inline (always)] pub fn offload (self) -> & 'a mut crate :: W < REG > { self . variant (Ipco :: Offload) } } # [doc = "Duplex mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dm { # [doc = "0: MAC operates in half-duplex mode"] HalfDuplex = 0 , # [doc = "1: MAC operates in full-duplex mode"] FullDuplex = 1 , } impl From < Dm > for bool { # [inline (always)] fn from (variant : Dm) -> Self { variant as u8 != 0 } } # [doc = "Field `DM` reader - Duplex mode"] pub type DmR = crate :: BitReader < Dm > ; impl DmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dm { match self . bits { false => Dm :: HalfDuplex , true => Dm :: FullDuplex , } } # [doc = "MAC operates in half-duplex mode"] # [inline (always)] pub fn is_half_duplex (& self) -> bool { * self == Dm :: HalfDuplex } # [doc = "MAC operates in full-duplex mode"] # [inline (always)] pub fn is_full_duplex (& self) -> bool { * self == Dm :: FullDuplex } } # [doc = "Field `DM` writer - Duplex mode"] pub type DmW < 'a , REG > = crate :: BitWriter < 'a , REG , Dm > ; impl < 'a , REG > DmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC operates in half-duplex mode"] # [inline (always)] pub fn half_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Dm :: HalfDuplex) } # [doc = "MAC operates in full-duplex mode"] # [inline (always)] pub fn full_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Dm :: FullDuplex) } } # [doc = "Loopback mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Lm { # [doc = "0: Normal mode"] Normal = 0 , # [doc = "1: MAC operates in loopback mode at the MII"] Loopback = 1 , } impl From < Lm > for bool { # [inline (always)] fn from (variant : Lm) -> Self { variant as u8 != 0 } } # [doc = "Field `LM` reader - Loopback mode"] pub type LmR = crate :: BitReader < Lm > ; impl LmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lm { match self . bits { false => Lm :: Normal , true => Lm :: Loopback , } } # [doc = "Normal mode"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Lm :: Normal } # [doc = "MAC operates in loopback mode at the MII"] # [inline (always)] pub fn is_loopback (& self) -> bool { * self == Lm :: Loopback } } # [doc = "Field `LM` writer - Loopback mode"] pub type LmW < 'a , REG > = crate :: BitWriter < 'a , REG , Lm > ; impl < 'a , REG > LmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal mode"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Lm :: Normal) } # [doc = "MAC operates in loopback mode at the MII"] # [inline (always)] pub fn loopback (self) -> & 'a mut crate :: W < REG > { self . variant (Lm :: Loopback) } } # [doc = "Receive own disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rod { # [doc = "0: MAC receives all packets from PHY while transmitting"] Enabled = 0 , # [doc = "1: MAC disables reception of frames in half-duplex mode"] Disabled = 1 , } impl From < Rod > for bool { # [inline (always)] fn from (variant : Rod) -> Self { variant as u8 != 0 } } # [doc = "Field `ROD` reader - Receive own disable"] pub type RodR = crate :: BitReader < Rod > ; impl RodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rod { match self . bits { false => Rod :: Enabled , true => Rod :: Disabled , } } # [doc = "MAC receives all packets from PHY while transmitting"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rod :: Enabled } # [doc = "MAC disables reception of frames in half-duplex mode"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rod :: Disabled } } # [doc = "Field `ROD` writer - Receive own disable"] pub type RodW < 'a , REG > = crate :: BitWriter < 'a , REG , Rod > ; impl < 'a , REG > RodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC receives all packets from PHY while transmitting"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rod :: Enabled) } # [doc = "MAC disables reception of frames in half-duplex mode"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rod :: Disabled) } } # [doc = "Fast Ethernet speed\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fes { # [doc = "0: 10 Mbit/s"] Fes10 = 0 , # [doc = "1: 100 Mbit/s"] Fes100 = 1 , } impl From < Fes > for bool { # [inline (always)] fn from (variant : Fes) -> Self { variant as u8 != 0 } } # [doc = "Field `FES` reader - Fast Ethernet speed"] pub type FesR = crate :: BitReader < Fes > ; impl FesR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fes { match self . bits { false => Fes :: Fes10 , true => Fes :: Fes100 , } } # [doc = "10 Mbit/s"] # [inline (always)] pub fn is_fes10 (& self) -> bool { * self == Fes :: Fes10 } # [doc = "100 Mbit/s"] # [inline (always)] pub fn is_fes100 (& self) -> bool { * self == Fes :: Fes100 } } # [doc = "Field `FES` writer - Fast Ethernet speed"] pub type FesW < 'a , REG > = crate :: BitWriter < 'a , REG , Fes > ; impl < 'a , REG > FesW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "10 Mbit/s"] # [inline (always)] pub fn fes10 (self) -> & 'a mut crate :: W < REG > { self . variant (Fes :: Fes10) } # [doc = "100 Mbit/s"] # [inline (always)] pub fn fes100 (self) -> & 'a mut crate :: W < REG > { self . variant (Fes :: Fes100) } } # [doc = "Carrier sense disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Csd { # [doc = "0: Errors generated due to loss of carrier"] Enabled = 0 , # [doc = "1: No error generated due to loss of carrier"] Disabled = 1 , } impl From < Csd > for bool { # [inline (always)] fn from (variant : Csd) -> Self { variant as u8 != 0 } } # [doc = "Field `CSD` reader - Carrier sense disable"] pub type CsdR = crate :: BitReader < Csd > ; impl CsdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Csd { match self . bits { false => Csd :: Enabled , true => Csd :: Disabled , } } # [doc = "Errors generated due to loss of carrier"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Csd :: Enabled } # [doc = "No error generated due to loss of carrier"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Csd :: Disabled } } # [doc = "Field `CSD` writer - Carrier sense disable"] pub type CsdW < 'a , REG > = crate :: BitWriter < 'a , REG , Csd > ; impl < 'a , REG > CsdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Errors generated due to loss of carrier"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Csd :: Enabled) } # [doc = "No error generated due to loss of carrier"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Csd :: Disabled) } } # [doc = "Interframe gap\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ifg { # [doc = "0: 96 bit times"] Ifg96 = 0 , # [doc = "1: 88 bit times"] Ifg88 = 1 , # [doc = "2: 80 bit times"] Ifg80 = 2 , # [doc = "3: 72 bit times"] Ifg72 = 3 , # [doc = "4: 64 bit times"] Ifg64 = 4 , # [doc = "5: 56 bit times"] Ifg56 = 5 , # [doc = "6: 48 bit times"] Ifg48 = 6 , # [doc = "7: 40 bit times"] Ifg40 = 7 , } impl From < Ifg > for u8 { # [inline (always)] fn from (variant : Ifg) -> Self { variant as _ } } impl crate :: FieldSpec for Ifg { type Ux = u8 ; } impl crate :: IsEnum for Ifg { } # [doc = "Field `IFG` reader - Interframe gap"] pub type IfgR = crate :: FieldReader < Ifg > ; impl IfgR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ifg { match self . bits { 0 => Ifg :: Ifg96 , 1 => Ifg :: Ifg88 , 2 => Ifg :: Ifg80 , 3 => Ifg :: Ifg72 , 4 => Ifg :: Ifg64 , 5 => Ifg :: Ifg56 , 6 => Ifg :: Ifg48 , 7 => Ifg :: Ifg40 , _ => unreachable ! () , } } # [doc = "96 bit times"] # [inline (always)] pub fn is_ifg96 (& self) -> bool { * self == Ifg :: Ifg96 } # [doc = "88 bit times"] # [inline (always)] pub fn is_ifg88 (& self) -> bool { * self == Ifg :: Ifg88 } # [doc = "80 bit times"] # [inline (always)] pub fn is_ifg80 (& self) -> bool { * self == Ifg :: Ifg80 } # [doc = "72 bit times"] # [inline (always)] pub fn is_ifg72 (& self) -> bool { * self == Ifg :: Ifg72 } # [doc = "64 bit times"] # [inline (always)] pub fn is_ifg64 (& self) -> bool { * self == Ifg :: Ifg64 } # [doc = "56 bit times"] # [inline (always)] pub fn is_ifg56 (& self) -> bool { * self == Ifg :: Ifg56 } # [doc = "48 bit times"] # [inline (always)] pub fn is_ifg48 (& self) -> bool { * self == Ifg :: Ifg48 } # [doc = "40 bit times"] # [inline (always)] pub fn is_ifg40 (& self) -> bool { * self == Ifg :: Ifg40 } } # [doc = "Field `IFG` writer - Interframe gap"] pub type IfgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Ifg , crate :: Safe > ; impl < 'a , REG > IfgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "96 bit times"] # [inline (always)] pub fn ifg96 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg96) } # [doc = "88 bit times"] # [inline (always)] pub fn ifg88 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg88) } # [doc = "80 bit times"] # [inline (always)] pub fn ifg80 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg80) } # [doc = "72 bit times"] # [inline (always)] pub fn ifg72 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg72) } # [doc = "64 bit times"] # [inline (always)] pub fn ifg64 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg64) } # [doc = "56 bit times"] # [inline (always)] pub fn ifg56 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg56) } # [doc = "48 bit times"] # [inline (always)] pub fn ifg48 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg48) } # [doc = "40 bit times"] # [inline (always)] pub fn ifg40 (self) -> & 'a mut crate :: W < REG > { self . variant (Ifg :: Ifg40) } } # [doc = "Jabber disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Jd { # [doc = "0: Jabber enabled, transmit frames up to 2048 bytes"] Enabled = 0 , # [doc = "1: Jabber disabled, transmit frames up to 16384 bytes"] Disabled = 1 , } impl From < Jd > for bool { # [inline (always)] fn from (variant : Jd) -> Self { variant as u8 != 0 } } # [doc = "Field `JD` reader - Jabber disable"] pub type JdR = crate :: BitReader < Jd > ; impl JdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Jd { match self . bits { false => Jd :: Enabled , true => Jd :: Disabled , } } # [doc = "Jabber enabled, transmit frames up to 2048 bytes"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Jd :: Enabled } # [doc = "Jabber disabled, transmit frames up to 16384 bytes"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Jd :: Disabled } } # [doc = "Field `JD` writer - Jabber disable"] pub type JdW < 'a , REG > = crate :: BitWriter < 'a , REG , Jd > ; impl < 'a , REG > JdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Jabber enabled, transmit frames up to 2048 bytes"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jd :: Enabled) } # [doc = "Jabber disabled, transmit frames up to 16384 bytes"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Jd :: Disabled) } } # [doc = "Watchdog disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wd { # [doc = "0: Watchdog enabled, receive frames limited to 2048 bytes"] Enabled = 0 , # [doc = "1: Watchdog disabled, receive frames may be up to to 16384 bytes"] Disabled = 1 , } impl From < Wd > for bool { # [inline (always)] fn from (variant : Wd) -> Self { variant as u8 != 0 } } # [doc = "Field `WD` reader - Watchdog disable"] pub type WdR = crate :: BitReader < Wd > ; impl WdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wd { match self . bits { false => Wd :: Enabled , true => Wd :: Disabled , } } # [doc = "Watchdog enabled, receive frames limited to 2048 bytes"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Wd :: Enabled } # [doc = "Watchdog disabled, receive frames may be up to to 16384 bytes"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Wd :: Disabled } } # [doc = "Field `WD` writer - Watchdog disable"] pub type WdW < 'a , REG > = crate :: BitWriter < 'a , REG , Wd > ; impl < 'a , REG > WdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Watchdog enabled, receive frames limited to 2048 bytes"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wd :: Enabled) } # [doc = "Watchdog disabled, receive frames may be up to to 16384 bytes"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wd :: Disabled) } } # [doc = "CRC stripping for type frames\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cstf { # [doc = "0: CRC not stripped"] Disabled = 0 , # [doc = "1: CRC stripped"] Enabled = 1 , } impl From < Cstf > for bool { # [inline (always)] fn from (variant : Cstf) -> Self { variant as u8 != 0 } } # [doc = "Field `CSTF` reader - CRC stripping for type frames"] pub type CstfR = crate :: BitReader < Cstf > ; impl CstfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cstf { match self . bits { false => Cstf :: Disabled , true => Cstf :: Enabled , } } # [doc = "CRC not stripped"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Cstf :: Disabled } # [doc = "CRC stripped"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Cstf :: Enabled } } # [doc = "Field `CSTF` writer - CRC stripping for type frames"] pub type CstfW < 'a , REG > = crate :: BitWriter < 'a , REG , Cstf > ; impl < 'a , REG > CstfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CRC not stripped"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cstf :: Disabled) } # [doc = "CRC stripped"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cstf :: Enabled) } } impl R { # [doc = "Bit 2 - Receiver enable"] # [inline (always)] pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter enable"] # [inline (always)] pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Deferral check"] # [inline (always)] pub fn dc (& self) -> DcR { DcR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Back-off limit"] # [inline (always)] pub fn bl (& self) -> BlR { BlR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Automatic pad/CRC stripping"] # [inline (always)] pub fn apcs (& self) -> ApcsR { ApcsR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 9 - Retry disable"] # [inline (always)] pub fn rd (& self) -> RdR { RdR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - IPv4 checksum offload"] # [inline (always)] pub fn ipco (& self) -> IpcoR { IpcoR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Duplex mode"] # [inline (always)] pub fn dm (& self) -> DmR { DmR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Loopback mode"] # [inline (always)] pub fn lm (& self) -> LmR { LmR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Receive own disable"] # [inline (always)] pub fn rod (& self) -> RodR { RodR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Fast Ethernet speed"] # [inline (always)] pub fn fes (& self) -> FesR { FesR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 16 - Carrier sense disable"] # [inline (always)] pub fn csd (& self) -> CsdR { CsdR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 17:19 - Interframe gap"] # [inline (always)] pub fn ifg (& self) -> IfgR { IfgR :: new (((self . bits >> 17) & 7) as u8) } # [doc = "Bit 22 - Jabber disable"] # [inline (always)] pub fn jd (& self) -> JdR { JdR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Watchdog disable"] # [inline (always)] pub fn wd (& self) -> WdR { WdR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 25 - CRC stripping for type frames"] # [inline (always)] pub fn cstf (& self) -> CstfR { CstfR :: new (((self . bits >> 25) & 1) != 0) } } impl W { # [doc = "Bit 2 - Receiver enable"] # [inline (always)] pub fn re (& mut self) -> ReW < MaccrSpec > { ReW :: new (self , 2) } # [doc = "Bit 3 - Transmitter enable"] # [inline (always)] pub fn te (& mut self) -> TeW < MaccrSpec > { TeW :: new (self , 3) } # [doc = "Bit 4 - Deferral check"] # [inline (always)] pub fn dc (& mut self) -> DcW < MaccrSpec > { DcW :: new (self , 4) } # [doc = "Bits 5:6 - Back-off limit"] # [inline (always)] pub fn bl (& mut self) -> BlW < MaccrSpec > { BlW :: new (self , 5) } # [doc = "Bit 7 - Automatic pad/CRC stripping"] # [inline (always)] pub fn apcs (& mut self) -> ApcsW < MaccrSpec > { ApcsW :: new (self , 7) } # [doc = "Bit 9 - Retry disable"] # [inline (always)] pub fn rd (& mut self) -> RdW < MaccrSpec > { RdW :: new (self , 9) } # [doc = "Bit 10 - IPv4 checksum offload"] # [inline (always)] pub fn ipco (& mut self) -> IpcoW < MaccrSpec > { IpcoW :: new (self , 10) } # [doc = "Bit 11 - Duplex mode"] # [inline (always)] pub fn dm (& mut self) -> DmW < MaccrSpec > { DmW :: new (self , 11) } # [doc = "Bit 12 - Loopback mode"] # [inline (always)] pub fn lm (& mut self) -> LmW < MaccrSpec > { LmW :: new (self , 12) } # [doc = "Bit 13 - Receive own disable"] # [inline (always)] pub fn rod (& mut self) -> RodW < MaccrSpec > { RodW :: new (self , 13) } # [doc = "Bit 14 - Fast Ethernet speed"] # [inline (always)] pub fn fes (& mut self) -> FesW < MaccrSpec > { FesW :: new (self , 14) } # [doc = "Bit 16 - Carrier sense disable"] # [inline (always)] pub fn csd (& mut self) -> CsdW < MaccrSpec > { CsdW :: new (self , 16) } # [doc = "Bits 17:19 - Interframe gap"] # [inline (always)] pub fn ifg (& mut self) -> IfgW < MaccrSpec > { IfgW :: new (self , 17) } # [doc = "Bit 22 - Jabber disable"] # [inline (always)] pub fn jd (& mut self) -> JdW < MaccrSpec > { JdW :: new (self , 22) } # [doc = "Bit 23 - Watchdog disable"] # [inline (always)] pub fn wd (& mut self) -> WdW < MaccrSpec > { WdW :: new (self , 23) } # [doc = "Bit 25 - CRC stripping for type frames"] # [inline (always)] pub fn cstf (& mut self) -> CstfW < MaccrSpec > { CstfW :: new (self , 25) } } # [doc = "Ethernet MAC configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`maccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`maccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MaccrSpec ; impl crate :: RegisterSpec for MaccrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`maccr::R`](R) reader structure"] impl crate :: Readable for MaccrSpec { } # [doc = "`write(|w| ..)` method takes [`maccr::W`](W) writer structure"] impl crate :: Writable for MaccrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets MACCR to value 0x8000"] impl crate :: Resettable for MaccrSpec { const RESET_VALUE : u32 = 0x8000 ; }
# [doc = "Register `MACFFR` reader"] pub type R = crate :: R < MacffrSpec > ; # [doc = "Register `MACFFR` writer"] pub type W = crate :: W < MacffrSpec > ; # [doc = "Promiscuous mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pm { # [doc = "0: Normal address filtering"] Disabled = 0 , # [doc = "1: Address filters pass all incoming frames regardless of their destination or source address"] Enabled = 1 , } impl From < Pm > for bool { # [inline (always)] fn from (variant : Pm) -> Self { variant as u8 != 0 } } # [doc = "Field `PM` reader - Promiscuous mode"] pub type PmR = crate :: BitReader < Pm > ; impl PmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pm { match self . bits { false => Pm :: Disabled , true => Pm :: Enabled , } } # [doc = "Normal address filtering"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pm :: Disabled } # [doc = "Address filters pass all incoming frames regardless of their destination or source address"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pm :: Enabled } } # [doc = "Field `PM` writer - Promiscuous mode"] pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG , Pm > ; impl < 'a , REG > PmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal address filtering"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Disabled) } # [doc = "Address filters pass all incoming frames regardless of their destination or source address"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Enabled) } } # [doc = "Hash unicast\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hu { # [doc = "0: MAC performs a perfect destination address filtering for unicast frames"] Perfect = 0 , # [doc = "1: MAC performs destination address filtering of received unicast frames according to the hash table"] Hash = 1 , } impl From < Hu > for bool { # [inline (always)] fn from (variant : Hu) -> Self { variant as u8 != 0 } } # [doc = "Field `HU` reader - Hash unicast"] pub type HuR = crate :: BitReader < Hu > ; impl HuR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hu { match self . bits { false => Hu :: Perfect , true => Hu :: Hash , } } # [doc = "MAC performs a perfect destination address filtering for unicast frames"] # [inline (always)] pub fn is_perfect (& self) -> bool { * self == Hu :: Perfect } # [doc = "MAC performs destination address filtering of received unicast frames according to the hash table"] # [inline (always)] pub fn is_hash (& self) -> bool { * self == Hu :: Hash } } # [doc = "Field `HU` writer - Hash unicast"] pub type HuW < 'a , REG > = crate :: BitWriter < 'a , REG , Hu > ; impl < 'a , REG > HuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC performs a perfect destination address filtering for unicast frames"] # [inline (always)] pub fn perfect (self) -> & 'a mut crate :: W < REG > { self . variant (Hu :: Perfect) } # [doc = "MAC performs destination address filtering of received unicast frames according to the hash table"] # [inline (always)] pub fn hash (self) -> & 'a mut crate :: W < REG > { self . variant (Hu :: Hash) } } # [doc = "Hash multicast\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hm { # [doc = "0: MAC performs a perfect destination address filtering for multicast frames"] Perfect = 0 , # [doc = "1: MAC performs destination address filtering of received multicast frames according to the hash table"] Hash = 1 , } impl From < Hm > for bool { # [inline (always)] fn from (variant : Hm) -> Self { variant as u8 != 0 } } # [doc = "Field `HM` reader - Hash multicast"] pub type HmR = crate :: BitReader < Hm > ; impl HmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hm { match self . bits { false => Hm :: Perfect , true => Hm :: Hash , } } # [doc = "MAC performs a perfect destination address filtering for multicast frames"] # [inline (always)] pub fn is_perfect (& self) -> bool { * self == Hm :: Perfect } # [doc = "MAC performs destination address filtering of received multicast frames according to the hash table"] # [inline (always)] pub fn is_hash (& self) -> bool { * self == Hm :: Hash } } # [doc = "Field `HM` writer - Hash multicast"] pub type HmW < 'a , REG > = crate :: BitWriter < 'a , REG , Hm > ; impl < 'a , REG > HmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC performs a perfect destination address filtering for multicast frames"] # [inline (always)] pub fn perfect (self) -> & 'a mut crate :: W < REG > { self . variant (Hm :: Perfect) } # [doc = "MAC performs destination address filtering of received multicast frames according to the hash table"] # [inline (always)] pub fn hash (self) -> & 'a mut crate :: W < REG > { self . variant (Hm :: Hash) } } # [doc = "Destination address unique filtering\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Daif { # [doc = "0: Normal filtering of frames"] Normal = 0 , # [doc = "1: Address check block operates in inverse filtering mode for the DA address comparison"] Invert = 1 , } impl From < Daif > for bool { # [inline (always)] fn from (variant : Daif) -> Self { variant as u8 != 0 } } # [doc = "Field `DAIF` reader - Destination address unique filtering"] pub type DaifR = crate :: BitReader < Daif > ; impl DaifR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Daif { match self . bits { false => Daif :: Normal , true => Daif :: Invert , } } # [doc = "Normal filtering of frames"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Daif :: Normal } # [doc = "Address check block operates in inverse filtering mode for the DA address comparison"] # [inline (always)] pub fn is_invert (& self) -> bool { * self == Daif :: Invert } } # [doc = "Field `DAIF` writer - Destination address unique filtering"] pub type DaifW < 'a , REG > = crate :: BitWriter < 'a , REG , Daif > ; impl < 'a , REG > DaifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Normal filtering of frames"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Daif :: Normal) } # [doc = "Address check block operates in inverse filtering mode for the DA address comparison"] # [inline (always)] pub fn invert (self) -> & 'a mut crate :: W < REG > { self . variant (Daif :: Invert) } } # [doc = "Pass all multicast\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Pam { # [doc = "0: Filtering of multicast frames depends on HM"] Disabled = 0 , # [doc = "1: All received frames with a multicast destination address are passed"] Enabled = 1 , } impl From < Pam > for bool { # [inline (always)] fn from (variant : Pam) -> Self { variant as u8 != 0 } } # [doc = "Field `PAM` reader - Pass all multicast"] pub type PamR = crate :: BitReader < Pam > ; impl PamR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pam { match self . bits { false => Pam :: Disabled , true => Pam :: Enabled , } } # [doc = "Filtering of multicast frames depends on HM"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Pam :: Disabled } # [doc = "All received frames with a multicast destination address are passed"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Pam :: Enabled } } # [doc = "Field `PAM` writer - Pass all multicast"] pub type PamW < 'a , REG > = crate :: BitWriter < 'a , REG , Pam > ; impl < 'a , REG > PamW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Filtering of multicast frames depends on HM"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pam :: Disabled) } # [doc = "All received frames with a multicast destination address are passed"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Pam :: Enabled) } } # [doc = "Broadcast frames disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bfd { # [doc = "0: Address filters pass all received broadcast frames"] Enabled = 0 , # [doc = "1: Address filters filter all incoming broadcast frames"] Disabled = 1 , } impl From < Bfd > for bool { # [inline (always)] fn from (variant : Bfd) -> Self { variant as u8 != 0 } } # [doc = "Field `BFD` reader - Broadcast frames disable"] pub type BfdR = crate :: BitReader < Bfd > ; impl BfdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bfd { match self . bits { false => Bfd :: Enabled , true => Bfd :: Disabled , } } # [doc = "Address filters pass all received broadcast frames"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Bfd :: Enabled } # [doc = "Address filters filter all incoming broadcast frames"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Bfd :: Disabled } } # [doc = "Field `BFD` writer - Broadcast frames disable"] pub type BfdW < 'a , REG > = crate :: BitWriter < 'a , REG , Bfd > ; impl < 'a , REG > BfdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Address filters pass all received broadcast frames"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bfd :: Enabled) } # [doc = "Address filters filter all incoming broadcast frames"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bfd :: Disabled) } } # [doc = "Pass control frames\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Pcf { # [doc = "0: MAC prevents all control frames from reaching the application"] PreventAll = 0 , # [doc = "1: MAC forwards all control frames to application except Pause"] ForwardAllExceptPause = 1 , # [doc = "2: MAC forwards all control frames to application even if they fail the address filter"] ForwardAll = 2 , # [doc = "3: MAC forwards control frames that pass the address filter"] ForwardAllFiltered = 3 , } impl From < Pcf > for u8 { # [inline (always)] fn from (variant : Pcf) -> Self { variant as _ } } impl crate :: FieldSpec for Pcf { type Ux = u8 ; } impl crate :: IsEnum for Pcf { } # [doc = "Field `PCF` reader - Pass control frames"] pub type PcfR = crate :: FieldReader < Pcf > ; impl PcfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Pcf { match self . bits { 0 => Pcf :: PreventAll , 1 => Pcf :: ForwardAllExceptPause , 2 => Pcf :: ForwardAll , 3 => Pcf :: ForwardAllFiltered , _ => unreachable ! () , } } # [doc = "MAC prevents all control frames from reaching the application"] # [inline (always)] pub fn is_prevent_all (& self) -> bool { * self == Pcf :: PreventAll } # [doc = "MAC forwards all control frames to application except Pause"] # [inline (always)] pub fn is_forward_all_except_pause (& self) -> bool { * self == Pcf :: ForwardAllExceptPause } # [doc = "MAC forwards all control frames to application even if they fail the address filter"] # [inline (always)] pub fn is_forward_all (& self) -> bool { * self == Pcf :: ForwardAll } # [doc = "MAC forwards control frames that pass the address filter"] # [inline (always)] pub fn is_forward_all_filtered (& self) -> bool { * self == Pcf :: ForwardAllFiltered } } # [doc = "Field `PCF` writer - Pass control frames"] pub type PcfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Pcf , crate :: Safe > ; impl < 'a , REG > PcfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "MAC prevents all control frames from reaching the application"] # [inline (always)] pub fn prevent_all (self) -> & 'a mut crate :: W < REG > { self . variant (Pcf :: PreventAll) } # [doc = "MAC forwards all control frames to application except Pause"] # [inline (always)] pub fn forward_all_except_pause (self) -> & 'a mut crate :: W < REG > { self . variant (Pcf :: ForwardAllExceptPause) } # [doc = "MAC forwards all control frames to application even if they fail the address filter"] # [inline (always)] pub fn forward_all (self) -> & 'a mut crate :: W < REG > { self . variant (Pcf :: ForwardAll) } # [doc = "MAC forwards control frames that pass the address filter"] # [inline (always)] pub fn forward_all_filtered (self) -> & 'a mut crate :: W < REG > { self . variant (Pcf :: ForwardAllFiltered) } } # [doc = "Source address inverse filtering\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Saif { # [doc = "0: Source address filter operates normally"] Normal = 0 , # [doc = "1: Source address filter operation inverted"] Invert = 1 , } impl From < Saif > for bool { # [inline (always)] fn from (variant : Saif) -> Self { variant as u8 != 0 } } # [doc = "Field `SAIF` reader - Source address inverse filtering"] pub type SaifR = crate :: BitReader < Saif > ; impl SaifR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Saif { match self . bits { false => Saif :: Normal , true => Saif :: Invert , } } # [doc = "Source address filter operates normally"] # [inline (always)] pub fn is_normal (& self) -> bool { * self == Saif :: Normal } # [doc = "Source address filter operation inverted"] # [inline (always)] pub fn is_invert (& self) -> bool { * self == Saif :: Invert } } # [doc = "Field `SAIF` writer - Source address inverse filtering"] pub type SaifW < 'a , REG > = crate :: BitWriter < 'a , REG , Saif > ; impl < 'a , REG > SaifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Source address filter operates normally"] # [inline (always)] pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Saif :: Normal) } # [doc = "Source address filter operation inverted"] # [inline (always)] pub fn invert (self) -> & 'a mut crate :: W < REG > { self . variant (Saif :: Invert) } } # [doc = "Source address filter\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Saf { # [doc = "0: Source address ignored"] Disabled = 0 , # [doc = "1: MAC drops frames that fail the source address filter"] Enabled = 1 , } impl From < Saf > for bool { # [inline (always)] fn from (variant : Saf) -> Self { variant as u8 != 0 } } # [doc = "Field `SAF` reader - Source address filter"] pub type SafR = crate :: BitReader < Saf > ; impl SafR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Saf { match self . bits { false => Saf :: Disabled , true => Saf :: Enabled , } } # [doc = "Source address ignored"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Saf :: Disabled } # [doc = "MAC drops frames that fail the source address filter"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Saf :: Enabled } } # [doc = "Field `SAF` writer - Source address filter"] pub type SafW < 'a , REG > = crate :: BitWriter < 'a , REG , Saf > ; impl < 'a , REG > SafW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Source address ignored"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Saf :: Disabled) } # [doc = "MAC drops frames that fail the source address filter"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Saf :: Enabled) } } # [doc = "Hash or perfect filter\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Hpf { # [doc = "0: If HM or HU is set, only frames that match the Hash filter are passed"] HashOnly = 0 , # [doc = "1: If HM or HU is set, frames that match either the perfect filter or the hash filter are passed"] HashOrPerfect = 1 , } impl From < Hpf > for bool { # [inline (always)] fn from (variant : Hpf) -> Self { variant as u8 != 0 } } # [doc = "Field `HPF` reader - Hash or perfect filter"] pub type HpfR = crate :: BitReader < Hpf > ; impl HpfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Hpf { match self . bits { false => Hpf :: HashOnly , true => Hpf :: HashOrPerfect , } } # [doc = "If HM or HU is set, only frames that match the Hash filter are passed"] # [inline (always)] pub fn is_hash_only (& self) -> bool { * self == Hpf :: HashOnly } # [doc = "If HM or HU is set, frames that match either the perfect filter or the hash filter are passed"] # [inline (always)] pub fn is_hash_or_perfect (& self) -> bool { * self == Hpf :: HashOrPerfect } } # [doc = "Field `HPF` writer - Hash or perfect filter"] pub type HpfW < 'a , REG > = crate :: BitWriter < 'a , REG , Hpf > ; impl < 'a , REG > HpfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "If HM or HU is set, only frames that match the Hash filter are passed"] # [inline (always)] pub fn hash_only (self) -> & 'a mut crate :: W < REG > { self . variant (Hpf :: HashOnly) } # [doc = "If HM or HU is set, frames that match either the perfect filter or the hash filter are passed"] # [inline (always)] pub fn hash_or_perfect (self) -> & 'a mut crate :: W < REG > { self . variant (Hpf :: HashOrPerfect) } } # [doc = "Receive all\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ra { # [doc = "0: MAC receiver passes on to the application only those frames that have passed the SA/DA address file"] Disabled = 0 , # [doc = "1: MAC receiver passes oll received frames on to the application"] Enabled = 1 , } impl From < Ra > for bool { # [inline (always)] fn from (variant : Ra) -> Self { variant as u8 != 0 } } # [doc = "Field `RA` reader - Receive all"] pub type RaR = crate :: BitReader < Ra > ; impl RaR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ra { match self . bits { false => Ra :: Disabled , true => Ra :: Enabled , } } # [doc = "MAC receiver passes on to the application only those frames that have passed the SA/DA address file"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ra :: Disabled } # [doc = "MAC receiver passes oll received frames on to the application"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ra :: Enabled } } # [doc = "Field `RA` writer - Receive all"] pub type RaW < 'a , REG > = crate :: BitWriter < 'a , REG , Ra > ; impl < 'a , REG > RaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MAC receiver passes on to the application only those frames that have passed the SA/DA address file"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ra :: Disabled) } # [doc = "MAC receiver passes oll received frames on to the application"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ra :: Enabled) } } impl R { # [doc = "Bit 0 - Promiscuous mode"] # [inline (always)] pub fn pm (& self) -> PmR { PmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Hash unicast"] # [inline (always)] pub fn hu (& self) -> HuR { HuR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Hash multicast"] # [inline (always)] pub fn hm (& self) -> HmR { HmR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Destination address unique filtering"] # [inline (always)] pub fn daif (& self) -> DaifR { DaifR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pass all multicast"] # [inline (always)] pub fn pam (& self) -> PamR { PamR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Broadcast frames disable"] # [inline (always)] pub fn bfd (& self) -> BfdR { BfdR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Pass control frames"] # [inline (always)] pub fn pcf (& self) -> PcfR { PcfR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 8 - Source address inverse filtering"] # [inline (always)] pub fn saif (& self) -> SaifR { SaifR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Source address filter"] # [inline (always)] pub fn saf (& self) -> SafR { SafR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Hash or perfect filter"] # [inline (always)] pub fn hpf (& self) -> HpfR { HpfR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 31 - Receive all"] # [inline (always)] pub fn ra (& self) -> RaR { RaR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 0 - Promiscuous mode"] # [inline (always)] pub fn pm (& mut self) -> PmW < MacffrSpec > { PmW :: new (self , 0) } # [doc = "Bit 1 - Hash unicast"] # [inline (always)] pub fn hu (& mut self) -> HuW < MacffrSpec > { HuW :: new (self , 1) } # [doc = "Bit 2 - Hash multicast"] # [inline (always)] pub fn hm (& mut self) -> HmW < MacffrSpec > { HmW :: new (self , 2) } # [doc = "Bit 3 - Destination address unique filtering"] # [inline (always)] pub fn daif (& mut self) -> DaifW < MacffrSpec > { DaifW :: new (self , 3) } # [doc = "Bit 4 - Pass all multicast"] # [inline (always)] pub fn pam (& mut self) -> PamW < MacffrSpec > { PamW :: new (self , 4) } # [doc = "Bit 5 - Broadcast frames disable"] # [inline (always)] pub fn bfd (& mut self) -> BfdW < MacffrSpec > { BfdW :: new (self , 5) } # [doc = "Bits 6:7 - Pass control frames"] # [inline (always)] pub fn pcf (& mut self) -> PcfW < MacffrSpec > { PcfW :: new (self , 6) } # [doc = "Bit 8 - Source address inverse filtering"] # [inline (always)] pub fn saif (& mut self) -> SaifW < MacffrSpec > { SaifW :: new (self , 8) } # [doc = "Bit 9 - Source address filter"] # [inline (always)] pub fn saf (& mut self) -> SafW < MacffrSpec > { SafW :: new (self , 9) } # [doc = "Bit 10 - Hash or perfect filter"] # [inline (always)] pub fn hpf (& mut self) -> HpfW < MacffrSpec > { HpfW :: new (self , 10) } # [doc = "Bit 31 - Receive all"] # [inline (always)] pub fn ra (& mut self) -> RaW < MacffrSpec > { RaW :: new (self , 31) } } # [doc = "Ethernet MAC frame filter register\n\nYou can [`read`](crate::Reg::read) this register and get [`macffr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`macffr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MacffrSpec ; impl crate :: RegisterSpec for MacffrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`macffr::R`](R) reader structure"] impl crate :: Readable for MacffrSpec { } # [doc = "`write(|w| ..)` method takes [`macffr::W`](W) writer structure"] impl crate :: Writable for MacffrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets MACFFR to value 0"] impl crate :: Resettable for MacffrSpec { }
# [doc = "Register `STA` reader"] pub type R = crate :: R < StaSpec > ; # [doc = "Command response received (CRC check failed)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ccrcfail { # [doc = "0: Command response received, crc check passed"] NotFailed = 0 , # [doc = "1: Command response received, crc check failed"] Failed = 1 , } impl From < Ccrcfail > for bool { # [inline (always)] fn from (variant : Ccrcfail) -> Self { variant as u8 != 0 } } # [doc = "Field `CCRCFAIL` reader - Command response received (CRC check failed)"] pub type CcrcfailR = crate :: BitReader < Ccrcfail > ; impl CcrcfailR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ccrcfail { match self . bits { false => Ccrcfail :: NotFailed , true => Ccrcfail :: Failed , } } # [doc = "Command response received, crc check passed"] # [inline (always)] pub fn is_not_failed (& self) -> bool { * self == Ccrcfail :: NotFailed } # [doc = "Command response received, crc check failed"] # [inline (always)] pub fn is_failed (& self) -> bool { * self == Ccrcfail :: Failed } } # [doc = "Data block sent/received (CRC check failed)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dcrcfail { # [doc = "0: No Data block sent/received crc check fail"] NotFailed = 0 , # [doc = "1: Data block sent/received crc failed"] Failed = 1 , } impl From < Dcrcfail > for bool { # [inline (always)] fn from (variant : Dcrcfail) -> Self { variant as u8 != 0 } } # [doc = "Field `DCRCFAIL` reader - Data block sent/received (CRC check failed)"] pub type DcrcfailR = crate :: BitReader < Dcrcfail > ; impl DcrcfailR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dcrcfail { match self . bits { false => Dcrcfail :: NotFailed , true => Dcrcfail :: Failed , } } # [doc = "No Data block sent/received crc check fail"] # [inline (always)] pub fn is_not_failed (& self) -> bool { * self == Dcrcfail :: NotFailed } # [doc = "Data block sent/received crc failed"] # [inline (always)] pub fn is_failed (& self) -> bool { * self == Dcrcfail :: Failed } } # [doc = "Command response timeout\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ctimeout { # [doc = "0: No Command timeout"] NoTimeout = 0 , # [doc = "1: Command timeout"] Timeout = 1 , } impl From < Ctimeout > for bool { # [inline (always)] fn from (variant : Ctimeout) -> Self { variant as u8 != 0 } } # [doc = "Field `CTIMEOUT` reader - Command response timeout"] pub type CtimeoutR = crate :: BitReader < Ctimeout > ; impl CtimeoutR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ctimeout { match self . bits { false => Ctimeout :: NoTimeout , true => Ctimeout :: Timeout , } } # [doc = "No Command timeout"] # [inline (always)] pub fn is_no_timeout (& self) -> bool { * self == Ctimeout :: NoTimeout } # [doc = "Command timeout"] # [inline (always)] pub fn is_timeout (& self) -> bool { * self == Ctimeout :: Timeout } } # [doc = "Data timeout\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dtimeout { # [doc = "0: No data timeout"] NoTimeout = 0 , # [doc = "1: Data timeout"] Timeout = 1 , } impl From < Dtimeout > for bool { # [inline (always)] fn from (variant : Dtimeout) -> Self { variant as u8 != 0 } } # [doc = "Field `DTIMEOUT` reader - Data timeout"] pub type DtimeoutR = crate :: BitReader < Dtimeout > ; impl DtimeoutR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dtimeout { match self . bits { false => Dtimeout :: NoTimeout , true => Dtimeout :: Timeout , } } # [doc = "No data timeout"] # [inline (always)] pub fn is_no_timeout (& self) -> bool { * self == Dtimeout :: NoTimeout } # [doc = "Data timeout"] # [inline (always)] pub fn is_timeout (& self) -> bool { * self == Dtimeout :: Timeout } } # [doc = "Transmit FIFO underrun error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txunderr { # [doc = "0: No transmit FIFO underrun error"] NoUnderrun = 0 , # [doc = "1: Transmit FIFO underrun error"] Underrun = 1 , } impl From < Txunderr > for bool { # [inline (always)] fn from (variant : Txunderr) -> Self { variant as u8 != 0 } } # [doc = "Field `TXUNDERR` reader - Transmit FIFO underrun error"] pub type TxunderrR = crate :: BitReader < Txunderr > ; impl TxunderrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txunderr { match self . bits { false => Txunderr :: NoUnderrun , true => Txunderr :: Underrun , } } # [doc = "No transmit FIFO underrun error"] # [inline (always)] pub fn is_no_underrun (& self) -> bool { * self == Txunderr :: NoUnderrun } # [doc = "Transmit FIFO underrun error"] # [inline (always)] pub fn is_underrun (& self) -> bool { * self == Txunderr :: Underrun } } # [doc = "Received FIFO overrun error\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxoverr { # [doc = "0: No FIFO overrun error"] NoOverrun = 0 , # [doc = "1: Receive FIFO overrun error"] Overrun = 1 , } impl From < Rxoverr > for bool { # [inline (always)] fn from (variant : Rxoverr) -> Self { variant as u8 != 0 } } # [doc = "Field `RXOVERR` reader - Received FIFO overrun error"] pub type RxoverrR = crate :: BitReader < Rxoverr > ; impl RxoverrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxoverr { match self . bits { false => Rxoverr :: NoOverrun , true => Rxoverr :: Overrun , } } # [doc = "No FIFO overrun error"] # [inline (always)] pub fn is_no_overrun (& self) -> bool { * self == Rxoverr :: NoOverrun } # [doc = "Receive FIFO overrun error"] # [inline (always)] pub fn is_overrun (& self) -> bool { * self == Rxoverr :: Overrun } } # [doc = "Command response received (CRC check passed)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cmdrend { # [doc = "0: Command not done"] NotDone = 0 , # [doc = "1: Command response received (CRC check passed)"] Done = 1 , } impl From < Cmdrend > for bool { # [inline (always)] fn from (variant : Cmdrend) -> Self { variant as u8 != 0 } } # [doc = "Field `CMDREND` reader - Command response received (CRC check passed)"] pub type CmdrendR = crate :: BitReader < Cmdrend > ; impl CmdrendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cmdrend { match self . bits { false => Cmdrend :: NotDone , true => Cmdrend :: Done , } } # [doc = "Command not done"] # [inline (always)] pub fn is_not_done (& self) -> bool { * self == Cmdrend :: NotDone } # [doc = "Command response received (CRC check passed)"] # [inline (always)] pub fn is_done (& self) -> bool { * self == Cmdrend :: Done } } # [doc = "Command sent (no response required)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cmdsent { # [doc = "0: Command not sent"] NotSent = 0 , # [doc = "1: Command sent (no response required)"] Sent = 1 , } impl From < Cmdsent > for bool { # [inline (always)] fn from (variant : Cmdsent) -> Self { variant as u8 != 0 } } # [doc = "Field `CMDSENT` reader - Command sent (no response required)"] pub type CmdsentR = crate :: BitReader < Cmdsent > ; impl CmdsentR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cmdsent { match self . bits { false => Cmdsent :: NotSent , true => Cmdsent :: Sent , } } # [doc = "Command not sent"] # [inline (always)] pub fn is_not_sent (& self) -> bool { * self == Cmdsent :: NotSent } # [doc = "Command sent (no response required)"] # [inline (always)] pub fn is_sent (& self) -> bool { * self == Cmdsent :: Sent } } # [doc = "Data end (data counter, SDIDCOUNT, is zero)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dataend { # [doc = "0: Not done"] NotDone = 0 , # [doc = "1: Data end (DCOUNT, is zero)"] Done = 1 , } impl From < Dataend > for bool { # [inline (always)] fn from (variant : Dataend) -> Self { variant as u8 != 0 } } # [doc = "Field `DATAEND` reader - Data end (data counter, SDIDCOUNT, is zero)"] pub type DataendR = crate :: BitReader < Dataend > ; impl DataendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dataend { match self . bits { false => Dataend :: NotDone , true => Dataend :: Done , } } # [doc = "Not done"] # [inline (always)] pub fn is_not_done (& self) -> bool { * self == Dataend :: NotDone } # [doc = "Data end (DCOUNT, is zero)"] # [inline (always)] pub fn is_done (& self) -> bool { * self == Dataend :: Done } } # [doc = "Start bit not detected on all data signals in wide bus mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Stbiterr { # [doc = "0: No start bit detected error"] Detected = 0 , # [doc = "1: Start bit not detected error"] NotDetected = 1 , } impl From < Stbiterr > for bool { # [inline (always)] fn from (variant : Stbiterr) -> Self { variant as u8 != 0 } } # [doc = "Field `STBITERR` reader - Start bit not detected on all data signals in wide bus mode"] pub type StbiterrR = crate :: BitReader < Stbiterr > ; impl StbiterrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Stbiterr { match self . bits { false => Stbiterr :: Detected , true => Stbiterr :: NotDetected , } } # [doc = "No start bit detected error"] # [inline (always)] pub fn is_detected (& self) -> bool { * self == Stbiterr :: Detected } # [doc = "Start bit not detected error"] # [inline (always)] pub fn is_not_detected (& self) -> bool { * self == Stbiterr :: NotDetected } } # [doc = "Data block sent/received (CRC check passed)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dbckend { # [doc = "0: Data block not sent/received (CRC check failed)"] NotTransferred = 0 , # [doc = "1: Data block sent/received (CRC check passed)"] Transferred = 1 , } impl From < Dbckend > for bool { # [inline (always)] fn from (variant : Dbckend) -> Self { variant as u8 != 0 } } # [doc = "Field `DBCKEND` reader - Data block sent/received (CRC check passed)"] pub type DbckendR = crate :: BitReader < Dbckend > ; impl DbckendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dbckend { match self . bits { false => Dbckend :: NotTransferred , true => Dbckend :: Transferred , } } # [doc = "Data block not sent/received (CRC check failed)"] # [inline (always)] pub fn is_not_transferred (& self) -> bool { * self == Dbckend :: NotTransferred } # [doc = "Data block sent/received (CRC check passed)"] # [inline (always)] pub fn is_transferred (& self) -> bool { * self == Dbckend :: Transferred } } # [doc = "Command transfer in progress\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cmdact { # [doc = "0: Command transfer not in progress"] NotInProgress = 0 , # [doc = "1: Command tranfer in progress"] InProgress = 1 , } impl From < Cmdact > for bool { # [inline (always)] fn from (variant : Cmdact) -> Self { variant as u8 != 0 } } # [doc = "Field `CMDACT` reader - Command transfer in progress"] pub type CmdactR = crate :: BitReader < Cmdact > ; impl CmdactR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cmdact { match self . bits { false => Cmdact :: NotInProgress , true => Cmdact :: InProgress , } } # [doc = "Command transfer not in progress"] # [inline (always)] pub fn is_not_in_progress (& self) -> bool { * self == Cmdact :: NotInProgress } # [doc = "Command tranfer in progress"] # [inline (always)] pub fn is_in_progress (& self) -> bool { * self == Cmdact :: InProgress } } # [doc = "Data transmit in progress\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txact { # [doc = "0: Data transmit is not in progress"] NotInProgress = 0 , # [doc = "1: Data transmit in progress"] InProgress = 1 , } impl From < Txact > for bool { # [inline (always)] fn from (variant : Txact) -> Self { variant as u8 != 0 } } # [doc = "Field `TXACT` reader - Data transmit in progress"] pub type TxactR = crate :: BitReader < Txact > ; impl TxactR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txact { match self . bits { false => Txact :: NotInProgress , true => Txact :: InProgress , } } # [doc = "Data transmit is not in progress"] # [inline (always)] pub fn is_not_in_progress (& self) -> bool { * self == Txact :: NotInProgress } # [doc = "Data transmit in progress"] # [inline (always)] pub fn is_in_progress (& self) -> bool { * self == Txact :: InProgress } } # [doc = "Data receive in progress\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxact { # [doc = "0: Data receive not in progress"] NotInProgress = 0 , # [doc = "1: Data receive in progress"] InProgress = 1 , } impl From < Rxact > for bool { # [inline (always)] fn from (variant : Rxact) -> Self { variant as u8 != 0 } } # [doc = "Field `RXACT` reader - Data receive in progress"] pub type RxactR = crate :: BitReader < Rxact > ; impl RxactR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxact { match self . bits { false => Rxact :: NotInProgress , true => Rxact :: InProgress , } } # [doc = "Data receive not in progress"] # [inline (always)] pub fn is_not_in_progress (& self) -> bool { * self == Rxact :: NotInProgress } # [doc = "Data receive in progress"] # [inline (always)] pub fn is_in_progress (& self) -> bool { * self == Rxact :: InProgress } } # [doc = "Transmit FIFO half empty: at least 8 words can be written into the FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txfifohe { # [doc = "0: Transmit FIFO not half empty"] NotHalfEmpty = 0 , # [doc = "1: Transmit FIFO half empty. At least 8 words can be written into the FIFO"] HalfEmpty = 1 , } impl From < Txfifohe > for bool { # [inline (always)] fn from (variant : Txfifohe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXFIFOHE` reader - Transmit FIFO half empty: at least 8 words can be written into the FIFO"] pub type TxfifoheR = crate :: BitReader < Txfifohe > ; impl TxfifoheR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txfifohe { match self . bits { false => Txfifohe :: NotHalfEmpty , true => Txfifohe :: HalfEmpty , } } # [doc = "Transmit FIFO not half empty"] # [inline (always)] pub fn is_not_half_empty (& self) -> bool { * self == Txfifohe :: NotHalfEmpty } # [doc = "Transmit FIFO half empty. At least 8 words can be written into the FIFO"] # [inline (always)] pub fn is_half_empty (& self) -> bool { * self == Txfifohe :: HalfEmpty } } # [doc = "Receive FIFO half full: there are at least 8 words in the FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxfifohf { # [doc = "0: Receive FIFO not half full"] NotHalfFull = 0 , # [doc = "1: Receive FIFO half full. At least 8 words in the FIFO"] HalfFull = 1 , } impl From < Rxfifohf > for bool { # [inline (always)] fn from (variant : Rxfifohf) -> Self { variant as u8 != 0 } } # [doc = "Field `RXFIFOHF` reader - Receive FIFO half full: there are at least 8 words in the FIFO"] pub type RxfifohfR = crate :: BitReader < Rxfifohf > ; impl RxfifohfR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxfifohf { match self . bits { false => Rxfifohf :: NotHalfFull , true => Rxfifohf :: HalfFull , } } # [doc = "Receive FIFO not half full"] # [inline (always)] pub fn is_not_half_full (& self) -> bool { * self == Rxfifohf :: NotHalfFull } # [doc = "Receive FIFO half full. At least 8 words in the FIFO"] # [inline (always)] pub fn is_half_full (& self) -> bool { * self == Rxfifohf :: HalfFull } } # [doc = "Transmit FIFO full\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txfifof { # [doc = "0: Transmit FIFO not full"] NotFull = 0 , # [doc = "1: Transmit FIFO full"] Full = 1 , } impl From < Txfifof > for bool { # [inline (always)] fn from (variant : Txfifof) -> Self { variant as u8 != 0 } } # [doc = "Field `TXFIFOF` reader - Transmit FIFO full"] pub type TxfifofR = crate :: BitReader < Txfifof > ; impl TxfifofR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txfifof { match self . bits { false => Txfifof :: NotFull , true => Txfifof :: Full , } } # [doc = "Transmit FIFO not full"] # [inline (always)] pub fn is_not_full (& self) -> bool { * self == Txfifof :: NotFull } # [doc = "Transmit FIFO full"] # [inline (always)] pub fn is_full (& self) -> bool { * self == Txfifof :: Full } } # [doc = "Receive FIFO full\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxfifof { # [doc = "0: Transmit FIFO not full"] NotFull = 0 , # [doc = "1: Receive FIFO full. When HW Flow Control is enabled, RXFIFOF signals becomes activated 2 words before the FIFO is full."] Full = 1 , } impl From < Rxfifof > for bool { # [inline (always)] fn from (variant : Rxfifof) -> Self { variant as u8 != 0 } } # [doc = "Field `RXFIFOF` reader - Receive FIFO full"] pub type RxfifofR = crate :: BitReader < Rxfifof > ; impl RxfifofR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxfifof { match self . bits { false => Rxfifof :: NotFull , true => Rxfifof :: Full , } } # [doc = "Transmit FIFO not full"] # [inline (always)] pub fn is_not_full (& self) -> bool { * self == Rxfifof :: NotFull } # [doc = "Receive FIFO full. When HW Flow Control is enabled, RXFIFOF signals becomes activated 2 words before the FIFO is full."] # [inline (always)] pub fn is_full (& self) -> bool { * self == Rxfifof :: Full } } # [doc = "Transmit FIFO empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txfifoe { # [doc = "0: Transmit FIFO not empty"] NotEmpty = 0 , # [doc = "1: Transmit FIFO empty. When HW Flow Control is enabled, TXFIFOE signals becomes activated when the FIFO contains 2 words."] Empty = 1 , } impl From < Txfifoe > for bool { # [inline (always)] fn from (variant : Txfifoe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXFIFOE` reader - Transmit FIFO empty"] pub type TxfifoeR = crate :: BitReader < Txfifoe > ; impl TxfifoeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txfifoe { match self . bits { false => Txfifoe :: NotEmpty , true => Txfifoe :: Empty , } } # [doc = "Transmit FIFO not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == Txfifoe :: NotEmpty } # [doc = "Transmit FIFO empty. When HW Flow Control is enabled, TXFIFOE signals becomes activated when the FIFO contains 2 words."] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Txfifoe :: Empty } } # [doc = "Receive FIFO empty\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxfifoe { # [doc = "0: Receive FIFO not empty"] NotEmpty = 0 , # [doc = "1: Receive FIFO empty"] Empty = 1 , } impl From < Rxfifoe > for bool { # [inline (always)] fn from (variant : Rxfifoe) -> Self { variant as u8 != 0 } } # [doc = "Field `RXFIFOE` reader - Receive FIFO empty"] pub type RxfifoeR = crate :: BitReader < Rxfifoe > ; impl RxfifoeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxfifoe { match self . bits { false => Rxfifoe :: NotEmpty , true => Rxfifoe :: Empty , } } # [doc = "Receive FIFO not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == Rxfifoe :: NotEmpty } # [doc = "Receive FIFO empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Rxfifoe :: Empty } } # [doc = "Data available in transmit FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Txdavl { # [doc = "0: Data not available in transmit FIFO"] NotAvailable = 0 , # [doc = "1: Data available in transmit FIFO"] Available = 1 , } impl From < Txdavl > for bool { # [inline (always)] fn from (variant : Txdavl) -> Self { variant as u8 != 0 } } # [doc = "Field `TXDAVL` reader - Data available in transmit FIFO"] pub type TxdavlR = crate :: BitReader < Txdavl > ; impl TxdavlR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Txdavl { match self . bits { false => Txdavl :: NotAvailable , true => Txdavl :: Available , } } # [doc = "Data not available in transmit FIFO"] # [inline (always)] pub fn is_not_available (& self) -> bool { * self == Txdavl :: NotAvailable } # [doc = "Data available in transmit FIFO"] # [inline (always)] pub fn is_available (& self) -> bool { * self == Txdavl :: Available } } # [doc = "Data available in receive FIFO\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rxdavl { # [doc = "0: Data not available in receive FIFO"] NotAvailable = 0 , # [doc = "1: Data available in receive FIFO"] Available = 1 , } impl From < Rxdavl > for bool { # [inline (always)] fn from (variant : Rxdavl) -> Self { variant as u8 != 0 } } # [doc = "Field `RXDAVL` reader - Data available in receive FIFO"] pub type RxdavlR = crate :: BitReader < Rxdavl > ; impl RxdavlR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rxdavl { match self . bits { false => Rxdavl :: NotAvailable , true => Rxdavl :: Available , } } # [doc = "Data not available in receive FIFO"] # [inline (always)] pub fn is_not_available (& self) -> bool { * self == Rxdavl :: NotAvailable } # [doc = "Data available in receive FIFO"] # [inline (always)] pub fn is_available (& self) -> bool { * self == Rxdavl :: Available } } # [doc = "SDIO interrupt received\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sdioit { # [doc = "0: SDIO interrupt not receieved"] NotReceived = 0 , # [doc = "1: SDIO interrupt received"] Received = 1 , } impl From < Sdioit > for bool { # [inline (always)] fn from (variant : Sdioit) -> Self { variant as u8 != 0 } } # [doc = "Field `SDIOIT` reader - SDIO interrupt received"] pub type SdioitR = crate :: BitReader < Sdioit > ; impl SdioitR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sdioit { match self . bits { false => Sdioit :: NotReceived , true => Sdioit :: Received , } } # [doc = "SDIO interrupt not receieved"] # [inline (always)] pub fn is_not_received (& self) -> bool { * self == Sdioit :: NotReceived } # [doc = "SDIO interrupt received"] # [inline (always)] pub fn is_received (& self) -> bool { * self == Sdioit :: Received } } # [doc = "CE-ATA command completion signal received for CMD61\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ceataend { # [doc = "0: Completion signal not received"] NotReceived = 0 , # [doc = "1: CE-ATA command completion signal received for CMD61"] Received = 1 , } impl From < Ceataend > for bool { # [inline (always)] fn from (variant : Ceataend) -> Self { variant as u8 != 0 } } # [doc = "Field `CEATAEND` reader - CE-ATA command completion signal received for CMD61"] pub type CeataendR = crate :: BitReader < Ceataend > ; impl CeataendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ceataend { match self . bits { false => Ceataend :: NotReceived , true => Ceataend :: Received , } } # [doc = "Completion signal not received"] # [inline (always)] pub fn is_not_received (& self) -> bool { * self == Ceataend :: NotReceived } # [doc = "CE-ATA command completion signal received for CMD61"] # [inline (always)] pub fn is_received (& self) -> bool { * self == Ceataend :: Received } } impl R { # [doc = "Bit 0 - Command response received (CRC check failed)"] # [inline (always)] pub fn ccrcfail (& self) -> CcrcfailR { CcrcfailR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data block sent/received (CRC check failed)"] # [inline (always)] pub fn dcrcfail (& self) -> DcrcfailR { DcrcfailR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Command response timeout"] # [inline (always)] pub fn ctimeout (& self) -> CtimeoutR { CtimeoutR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Data timeout"] # [inline (always)] pub fn dtimeout (& self) -> DtimeoutR { DtimeoutR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transmit FIFO underrun error"] # [inline (always)] pub fn txunderr (& self) -> TxunderrR { TxunderrR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Received FIFO overrun error"] # [inline (always)] pub fn rxoverr (& self) -> RxoverrR { RxoverrR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Command response received (CRC check passed)"] # [inline (always)] pub fn cmdrend (& self) -> CmdrendR { CmdrendR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Command sent (no response required)"] # [inline (always)] pub fn cmdsent (& self) -> CmdsentR { CmdsentR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Data end (data counter, SDIDCOUNT, is zero)"] # [inline (always)] pub fn dataend (& self) -> DataendR { DataendR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Start bit not detected on all data signals in wide bus mode"] # [inline (always)] pub fn stbiterr (& self) -> StbiterrR { StbiterrR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Data block sent/received (CRC check passed)"] # [inline (always)] pub fn dbckend (& self) -> DbckendR { DbckendR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Command transfer in progress"] # [inline (always)] pub fn cmdact (& self) -> CmdactR { CmdactR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Data transmit in progress"] # [inline (always)] pub fn txact (& self) -> TxactR { TxactR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Data receive in progress"] # [inline (always)] pub fn rxact (& self) -> RxactR { RxactR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Transmit FIFO half empty: at least 8 words can be written into the FIFO"] # [inline (always)] pub fn txfifohe (& self) -> TxfifoheR { TxfifoheR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Receive FIFO half full: there are at least 8 words in the FIFO"] # [inline (always)] pub fn rxfifohf (& self) -> RxfifohfR { RxfifohfR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Transmit FIFO full"] # [inline (always)] pub fn txfifof (& self) -> TxfifofR { TxfifofR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Receive FIFO full"] # [inline (always)] pub fn rxfifof (& self) -> RxfifofR { RxfifofR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Transmit FIFO empty"] # [inline (always)] pub fn txfifoe (& self) -> TxfifoeR { TxfifoeR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Receive FIFO empty"] # [inline (always)] pub fn rxfifoe (& self) -> RxfifoeR { RxfifoeR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Data available in transmit FIFO"] # [inline (always)] pub fn txdavl (& self) -> TxdavlR { TxdavlR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Data available in receive FIFO"] # [inline (always)] pub fn rxdavl (& self) -> RxdavlR { RxdavlR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - SDIO interrupt received"] # [inline (always)] pub fn sdioit (& self) -> SdioitR { SdioitR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - CE-ATA command completion signal received for CMD61"] # [inline (always)] pub fn ceataend (& self) -> CeataendR { CeataendR :: new (((self . bits >> 23) & 1) != 0) } } # [doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StaSpec ; impl crate :: RegisterSpec for StaSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sta::R`](R) reader structure"] impl crate :: Readable for StaSpec { } # [doc = "`reset()` method sets STA to value 0"] impl crate :: Resettable for StaSpec { }
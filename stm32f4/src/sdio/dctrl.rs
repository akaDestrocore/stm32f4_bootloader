# [doc = "Register `DCTRL` reader"] pub type R = crate :: R < DctrlSpec > ; # [doc = "Register `DCTRL` writer"] pub type W = crate :: W < DctrlSpec > ; # [doc = "DTEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dten { # [doc = "0: Disabled"] Disabled = 0 , # [doc = "1: Start transfer"] Enabled = 1 , } impl From < Dten > for bool { # [inline (always)] fn from (variant : Dten) -> Self { variant as u8 != 0 } } # [doc = "Field `DTEN` reader - DTEN"] pub type DtenR = crate :: BitReader < Dten > ; impl DtenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dten { match self . bits { false => Dten :: Disabled , true => Dten :: Enabled , } } # [doc = "Disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dten :: Disabled } # [doc = "Start transfer"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dten :: Enabled } } # [doc = "Field `DTEN` writer - DTEN"] pub type DtenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dten > ; impl < 'a , REG > DtenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dten :: Disabled) } # [doc = "Start transfer"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dten :: Enabled) } } # [doc = "Data transfer direction selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dtdir { # [doc = "0: From controller to card"] ControllerToCard = 0 , # [doc = "1: From card to controller"] CardToController = 1 , } impl From < Dtdir > for bool { # [inline (always)] fn from (variant : Dtdir) -> Self { variant as u8 != 0 } } # [doc = "Field `DTDIR` reader - Data transfer direction selection"] pub type DtdirR = crate :: BitReader < Dtdir > ; impl DtdirR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dtdir { match self . bits { false => Dtdir :: ControllerToCard , true => Dtdir :: CardToController , } } # [doc = "From controller to card"] # [inline (always)] pub fn is_controller_to_card (& self) -> bool { * self == Dtdir :: ControllerToCard } # [doc = "From card to controller"] # [inline (always)] pub fn is_card_to_controller (& self) -> bool { * self == Dtdir :: CardToController } } # [doc = "Field `DTDIR` writer - Data transfer direction selection"] pub type DtdirW < 'a , REG > = crate :: BitWriter < 'a , REG , Dtdir > ; impl < 'a , REG > DtdirW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "From controller to card"] # [inline (always)] pub fn controller_to_card (self) -> & 'a mut crate :: W < REG > { self . variant (Dtdir :: ControllerToCard) } # [doc = "From card to controller"] # [inline (always)] pub fn card_to_controller (self) -> & 'a mut crate :: W < REG > { self . variant (Dtdir :: CardToController) } } # [doc = "Data transfer mode selection 1: Stream or SDIO multibyte data transfer.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dtmode { # [doc = "0: Bloack data transfer"] BlockMode = 0 , # [doc = "1: Stream or SDIO multibyte data transfer"] StreamMode = 1 , } impl From < Dtmode > for bool { # [inline (always)] fn from (variant : Dtmode) -> Self { variant as u8 != 0 } } # [doc = "Field `DTMODE` reader - Data transfer mode selection 1: Stream or SDIO multibyte data transfer."] pub type DtmodeR = crate :: BitReader < Dtmode > ; impl DtmodeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dtmode { match self . bits { false => Dtmode :: BlockMode , true => Dtmode :: StreamMode , } } # [doc = "Bloack data transfer"] # [inline (always)] pub fn is_block_mode (& self) -> bool { * self == Dtmode :: BlockMode } # [doc = "Stream or SDIO multibyte data transfer"] # [inline (always)] pub fn is_stream_mode (& self) -> bool { * self == Dtmode :: StreamMode } } # [doc = "Field `DTMODE` writer - Data transfer mode selection 1: Stream or SDIO multibyte data transfer."] pub type DtmodeW < 'a , REG > = crate :: BitWriter < 'a , REG , Dtmode > ; impl < 'a , REG > DtmodeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Bloack data transfer"] # [inline (always)] pub fn block_mode (self) -> & 'a mut crate :: W < REG > { self . variant (Dtmode :: BlockMode) } # [doc = "Stream or SDIO multibyte data transfer"] # [inline (always)] pub fn stream_mode (self) -> & 'a mut crate :: W < REG > { self . variant (Dtmode :: StreamMode) } } # [doc = "DMA enable bit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dmaen { # [doc = "0: Dma disabled"] Disabled = 0 , # [doc = "1: Dma enabled"] Enabled = 1 , } impl From < Dmaen > for bool { # [inline (always)] fn from (variant : Dmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN` reader - DMA enable bit"] pub type DmaenR = crate :: BitReader < Dmaen > ; impl DmaenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dmaen { match self . bits { false => Dmaen :: Disabled , true => Dmaen :: Enabled , } } # [doc = "Dma disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Dmaen :: Disabled } # [doc = "Dma enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Dmaen :: Enabled } } # [doc = "Field `DMAEN` writer - DMA enable bit"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen > ; impl < 'a , REG > DmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Dma disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Disabled) } # [doc = "Dma enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Enabled) } } # [doc = "Field `DBLOCKSIZE` reader - Data block size"] pub type DblocksizeR = crate :: FieldReader ; # [doc = "Field `DBLOCKSIZE` writer - Data block size"] pub type DblocksizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Read wait start\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rwstart { # [doc = "0: Don't start read wait operation"] Disabled = 0 , # [doc = "1: Read wait operation starts"] Enabled = 1 , } impl From < Rwstart > for bool { # [inline (always)] fn from (variant : Rwstart) -> Self { variant as u8 != 0 } } # [doc = "Field `RWSTART` reader - Read wait start"] pub type RwstartR = crate :: BitReader < Rwstart > ; impl RwstartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rwstart { match self . bits { false => Rwstart :: Disabled , true => Rwstart :: Enabled , } } # [doc = "Don't start read wait operation"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rwstart :: Disabled } # [doc = "Read wait operation starts"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rwstart :: Enabled } } # [doc = "Field `RWSTART` writer - Read wait start"] pub type RwstartW < 'a , REG > = crate :: BitWriter < 'a , REG , Rwstart > ; impl < 'a , REG > RwstartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Don't start read wait operation"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rwstart :: Disabled) } # [doc = "Read wait operation starts"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rwstart :: Enabled) } } # [doc = "Read wait stop\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rwstop { # [doc = "0: Read wait in progress if RWSTART is enabled"] Disabled = 0 , # [doc = "1: Enable for read wait stop if RWSTART is enabled"] Enabled = 1 , } impl From < Rwstop > for bool { # [inline (always)] fn from (variant : Rwstop) -> Self { variant as u8 != 0 } } # [doc = "Field `RWSTOP` reader - Read wait stop"] pub type RwstopR = crate :: BitReader < Rwstop > ; impl RwstopR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rwstop { match self . bits { false => Rwstop :: Disabled , true => Rwstop :: Enabled , } } # [doc = "Read wait in progress if RWSTART is enabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Rwstop :: Disabled } # [doc = "Enable for read wait stop if RWSTART is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Rwstop :: Enabled } } # [doc = "Field `RWSTOP` writer - Read wait stop"] pub type RwstopW < 'a , REG > = crate :: BitWriter < 'a , REG , Rwstop > ; impl < 'a , REG > RwstopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Read wait in progress if RWSTART is enabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rwstop :: Disabled) } # [doc = "Enable for read wait stop if RWSTART is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Rwstop :: Enabled) } } # [doc = "Read wait mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Rwmod { # [doc = "0: Read wait control stopping using SDIO_D2"] D2 = 0 , # [doc = "1: Read wait control using SDIO_CK"] Ck = 1 , } impl From < Rwmod > for bool { # [inline (always)] fn from (variant : Rwmod) -> Self { variant as u8 != 0 } } # [doc = "Field `RWMOD` reader - Read wait mode"] pub type RwmodR = crate :: BitReader < Rwmod > ; impl RwmodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Rwmod { match self . bits { false => Rwmod :: D2 , true => Rwmod :: Ck , } } # [doc = "Read wait control stopping using SDIO_D2"] # [inline (always)] pub fn is_d2 (& self) -> bool { * self == Rwmod :: D2 } # [doc = "Read wait control using SDIO_CK"] # [inline (always)] pub fn is_ck (& self) -> bool { * self == Rwmod :: Ck } } # [doc = "Field `RWMOD` writer - Read wait mode"] pub type RwmodW < 'a , REG > = crate :: BitWriter < 'a , REG , Rwmod > ; impl < 'a , REG > RwmodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Read wait control stopping using SDIO_D2"] # [inline (always)] pub fn d2 (self) -> & 'a mut crate :: W < REG > { self . variant (Rwmod :: D2) } # [doc = "Read wait control using SDIO_CK"] # [inline (always)] pub fn ck (self) -> & 'a mut crate :: W < REG > { self . variant (Rwmod :: Ck) } } # [doc = "SD I/O enable functions\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sdioen { # [doc = "0: SDIO operations disabled"] Disabled = 0 , # [doc = "1: SDIO operations enabled"] Enabled = 1 , } impl From < Sdioen > for bool { # [inline (always)] fn from (variant : Sdioen) -> Self { variant as u8 != 0 } } # [doc = "Field `SDIOEN` reader - SD I/O enable functions"] pub type SdioenR = crate :: BitReader < Sdioen > ; impl SdioenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sdioen { match self . bits { false => Sdioen :: Disabled , true => Sdioen :: Enabled , } } # [doc = "SDIO operations disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Sdioen :: Disabled } # [doc = "SDIO operations enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Sdioen :: Enabled } } # [doc = "Field `SDIOEN` writer - SD I/O enable functions"] pub type SdioenW < 'a , REG > = crate :: BitWriter < 'a , REG , Sdioen > ; impl < 'a , REG > SdioenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SDIO operations disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Sdioen :: Disabled) } # [doc = "SDIO operations enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Sdioen :: Enabled) } } impl R { # [doc = "Bit 0 - DTEN"] # [inline (always)] pub fn dten (& self) -> DtenR { DtenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data transfer direction selection"] # [inline (always)] pub fn dtdir (& self) -> DtdirR { DtdirR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data transfer mode selection 1: Stream or SDIO multibyte data transfer."] # [inline (always)] pub fn dtmode (& self) -> DtmodeR { DtmodeR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DMA enable bit"] # [inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:7 - Data block size"] # [inline (always)] pub fn dblocksize (& self) -> DblocksizeR { DblocksizeR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bit 8 - Read wait start"] # [inline (always)] pub fn rwstart (& self) -> RwstartR { RwstartR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Read wait stop"] # [inline (always)] pub fn rwstop (& self) -> RwstopR { RwstopR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Read wait mode"] # [inline (always)] pub fn rwmod (& self) -> RwmodR { RwmodR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - SD I/O enable functions"] # [inline (always)] pub fn sdioen (& self) -> SdioenR { SdioenR :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - DTEN"] # [inline (always)] pub fn dten (& mut self) -> DtenW < DctrlSpec > { DtenW :: new (self , 0) } # [doc = "Bit 1 - Data transfer direction selection"] # [inline (always)] pub fn dtdir (& mut self) -> DtdirW < DctrlSpec > { DtdirW :: new (self , 1) } # [doc = "Bit 2 - Data transfer mode selection 1: Stream or SDIO multibyte data transfer."] # [inline (always)] pub fn dtmode (& mut self) -> DtmodeW < DctrlSpec > { DtmodeW :: new (self , 2) } # [doc = "Bit 3 - DMA enable bit"] # [inline (always)] pub fn dmaen (& mut self) -> DmaenW < DctrlSpec > { DmaenW :: new (self , 3) } # [doc = "Bits 4:7 - Data block size"] # [inline (always)] pub fn dblocksize (& mut self) -> DblocksizeW < DctrlSpec > { DblocksizeW :: new (self , 4) } # [doc = "Bit 8 - Read wait start"] # [inline (always)] pub fn rwstart (& mut self) -> RwstartW < DctrlSpec > { RwstartW :: new (self , 8) } # [doc = "Bit 9 - Read wait stop"] # [inline (always)] pub fn rwstop (& mut self) -> RwstopW < DctrlSpec > { RwstopW :: new (self , 9) } # [doc = "Bit 10 - Read wait mode"] # [inline (always)] pub fn rwmod (& mut self) -> RwmodW < DctrlSpec > { RwmodW :: new (self , 10) } # [doc = "Bit 11 - SD I/O enable functions"] # [inline (always)] pub fn sdioen (& mut self) -> SdioenW < DctrlSpec > { SdioenW :: new (self , 11) } } # [doc = "data control register\n\nYou can [`read`](crate::Reg::read) this register and get [`dctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DctrlSpec ; impl crate :: RegisterSpec for DctrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dctrl::R`](R) reader structure"] impl crate :: Readable for DctrlSpec { } # [doc = "`write(|w| ..)` method takes [`dctrl::W`](W) writer structure"] impl crate :: Writable for DctrlSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets DCTRL to value 0"] impl crate :: Resettable for DctrlSpec { }
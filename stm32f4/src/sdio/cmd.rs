# [doc = "Register `CMD` reader"] pub type R = crate :: R < CmdSpec > ; # [doc = "Register `CMD` writer"] pub type W = crate :: W < CmdSpec > ; # [doc = "Field `CMDINDEX` reader - Command index"] pub type CmdindexR = crate :: FieldReader ; # [doc = "Field `CMDINDEX` writer - Command index"] pub type CmdindexW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 , u8 , crate :: Safe > ; # [doc = "Wait for response bits\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Waitresp { # [doc = "0: No response"] NoResponse = 0 , # [doc = "1: Short response"] ShortResponse = 1 , # [doc = "2: No reponse"] NoResponse2 = 2 , # [doc = "3: Long reponse"] LongResponse = 3 , } impl From < Waitresp > for u8 { # [inline (always)] fn from (variant : Waitresp) -> Self { variant as _ } } impl crate :: FieldSpec for Waitresp { type Ux = u8 ; } impl crate :: IsEnum for Waitresp { } # [doc = "Field `WAITRESP` reader - Wait for response bits"] pub type WaitrespR = crate :: FieldReader < Waitresp > ; impl WaitrespR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waitresp { match self . bits { 0 => Waitresp :: NoResponse , 1 => Waitresp :: ShortResponse , 2 => Waitresp :: NoResponse2 , 3 => Waitresp :: LongResponse , _ => unreachable ! () , } } # [doc = "No response"] # [inline (always)] pub fn is_no_response (& self) -> bool { * self == Waitresp :: NoResponse } # [doc = "Short response"] # [inline (always)] pub fn is_short_response (& self) -> bool { * self == Waitresp :: ShortResponse } # [doc = "No reponse"] # [inline (always)] pub fn is_no_response2 (& self) -> bool { * self == Waitresp :: NoResponse2 } # [doc = "Long reponse"] # [inline (always)] pub fn is_long_response (& self) -> bool { * self == Waitresp :: LongResponse } } # [doc = "Field `WAITRESP` writer - Wait for response bits"] pub type WaitrespW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Waitresp , crate :: Safe > ; impl < 'a , REG > WaitrespW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No response"] # [inline (always)] pub fn no_response (self) -> & 'a mut crate :: W < REG > { self . variant (Waitresp :: NoResponse) } # [doc = "Short response"] # [inline (always)] pub fn short_response (self) -> & 'a mut crate :: W < REG > { self . variant (Waitresp :: ShortResponse) } # [doc = "No reponse"] # [inline (always)] pub fn no_response2 (self) -> & 'a mut crate :: W < REG > { self . variant (Waitresp :: NoResponse2) } # [doc = "Long reponse"] # [inline (always)] pub fn long_response (self) -> & 'a mut crate :: W < REG > { self . variant (Waitresp :: LongResponse) } } # [doc = "CPSM waits for interrupt request\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waitint { # [doc = "0: Don't wait for interrupt request"] Disabled = 0 , # [doc = "1: Wait for interrupt request"] Enabled = 1 , } impl From < Waitint > for bool { # [inline (always)] fn from (variant : Waitint) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITINT` reader - CPSM waits for interrupt request"] pub type WaitintR = crate :: BitReader < Waitint > ; impl WaitintR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waitint { match self . bits { false => Waitint :: Disabled , true => Waitint :: Enabled , } } # [doc = "Don't wait for interrupt request"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Waitint :: Disabled } # [doc = "Wait for interrupt request"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Waitint :: Enabled } } # [doc = "Field `WAITINT` writer - CPSM waits for interrupt request"] pub type WaitintW < 'a , REG > = crate :: BitWriter < 'a , REG , Waitint > ; impl < 'a , REG > WaitintW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Don't wait for interrupt request"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waitint :: Disabled) } # [doc = "Wait for interrupt request"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waitint :: Enabled) } } # [doc = "CPSM Waits for ends of data transfer (CmdPend internal signal).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waitpend { # [doc = "0: Don't wait for data end"] Disabled = 0 , # [doc = "1: Wait for end of data transfer signal before sending command"] Enabled = 1 , } impl From < Waitpend > for bool { # [inline (always)] fn from (variant : Waitpend) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITPEND` reader - CPSM Waits for ends of data transfer (CmdPend internal signal)."] pub type WaitpendR = crate :: BitReader < Waitpend > ; impl WaitpendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waitpend { match self . bits { false => Waitpend :: Disabled , true => Waitpend :: Enabled , } } # [doc = "Don't wait for data end"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Waitpend :: Disabled } # [doc = "Wait for end of data transfer signal before sending command"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Waitpend :: Enabled } } # [doc = "Field `WAITPEND` writer - CPSM Waits for ends of data transfer (CmdPend internal signal)."] pub type WaitpendW < 'a , REG > = crate :: BitWriter < 'a , REG , Waitpend > ; impl < 'a , REG > WaitpendW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Don't wait for data end"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waitpend :: Disabled) } # [doc = "Wait for end of data transfer signal before sending command"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waitpend :: Enabled) } } # [doc = "Command path state machine (CPSM) Enable bit\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cpsmen { # [doc = "0: Command path state machine disabled"] Disabled = 0 , # [doc = "1: Command path state machine enabled"] Enabled = 1 , } impl From < Cpsmen > for bool { # [inline (always)] fn from (variant : Cpsmen) -> Self { variant as u8 != 0 } } # [doc = "Field `CPSMEN` reader - Command path state machine (CPSM) Enable bit"] pub type CpsmenR = crate :: BitReader < Cpsmen > ; impl CpsmenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cpsmen { match self . bits { false => Cpsmen :: Disabled , true => Cpsmen :: Enabled , } } # [doc = "Command path state machine disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Cpsmen :: Disabled } # [doc = "Command path state machine enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Cpsmen :: Enabled } } # [doc = "Field `CPSMEN` writer - Command path state machine (CPSM) Enable bit"] pub type CpsmenW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpsmen > ; impl < 'a , REG > CpsmenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Command path state machine disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsmen :: Disabled) } # [doc = "Command path state machine enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsmen :: Enabled) } } # [doc = "SD I/O suspend command\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Sdiosuspend { # [doc = "0: Next command is not a SDIO suspend command"] Disabled = 0 , # [doc = "1: Next command send is a SDIO suspend command"] Enabled = 1 , } impl From < Sdiosuspend > for bool { # [inline (always)] fn from (variant : Sdiosuspend) -> Self { variant as u8 != 0 } } # [doc = "Field `SDIOSuspend` reader - SD I/O suspend command"] pub type SdiosuspendR = crate :: BitReader < Sdiosuspend > ; impl SdiosuspendR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Sdiosuspend { match self . bits { false => Sdiosuspend :: Disabled , true => Sdiosuspend :: Enabled , } } # [doc = "Next command is not a SDIO suspend command"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Sdiosuspend :: Disabled } # [doc = "Next command send is a SDIO suspend command"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Sdiosuspend :: Enabled } } # [doc = "Field `SDIOSuspend` writer - SD I/O suspend command"] pub type SdiosuspendW < 'a , REG > = crate :: BitWriter < 'a , REG , Sdiosuspend > ; impl < 'a , REG > SdiosuspendW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Next command is not a SDIO suspend command"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Sdiosuspend :: Disabled) } # [doc = "Next command send is a SDIO suspend command"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Sdiosuspend :: Enabled) } } # [doc = "Enable CMD completion\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Encmdcompl { # [doc = "0: Command complete signal disabled"] Disabled = 0 , # [doc = "1: Command complete signal enabled"] Enabled = 1 , } impl From < Encmdcompl > for bool { # [inline (always)] fn from (variant : Encmdcompl) -> Self { variant as u8 != 0 } } # [doc = "Field `ENCMDcompl` reader - Enable CMD completion"] pub type EncmdcomplR = crate :: BitReader < Encmdcompl > ; impl EncmdcomplR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Encmdcompl { match self . bits { false => Encmdcompl :: Disabled , true => Encmdcompl :: Enabled , } } # [doc = "Command complete signal disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Encmdcompl :: Disabled } # [doc = "Command complete signal enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Encmdcompl :: Enabled } } # [doc = "Field `ENCMDcompl` writer - Enable CMD completion"] pub type EncmdcomplW < 'a , REG > = crate :: BitWriter < 'a , REG , Encmdcompl > ; impl < 'a , REG > EncmdcomplW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Command complete signal disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Encmdcompl :: Disabled) } # [doc = "Command complete signal enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Encmdcompl :: Enabled) } } # [doc = "not Interrupt Enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum NIen { # [doc = "0: Interrupts to the CE-ATA not disabled"] Disabled = 0 , # [doc = "1: Interrupt to the CE-ATA are disabled"] Enabled = 1 , } impl From < NIen > for bool { # [inline (always)] fn from (variant : NIen) -> Self { variant as u8 != 0 } } # [doc = "Field `nIEN` reader - not Interrupt Enable"] pub type NIenR = crate :: BitReader < NIen > ; impl NIenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> NIen { match self . bits { false => NIen :: Disabled , true => NIen :: Enabled , } } # [doc = "Interrupts to the CE-ATA not disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == NIen :: Disabled } # [doc = "Interrupt to the CE-ATA are disabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == NIen :: Enabled } } # [doc = "Field `nIEN` writer - not Interrupt Enable"] pub type NIenW < 'a , REG > = crate :: BitWriter < 'a , REG , NIen > ; impl < 'a , REG > NIenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupts to the CE-ATA not disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (NIen :: Disabled) } # [doc = "Interrupt to the CE-ATA are disabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (NIen :: Enabled) } } # [doc = "CE-ATA command\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum CeAtacmd { # [doc = "0: CE-ATA command disabled"] Disabled = 0 , # [doc = "1: CE-ATA command enabled"] Enabled = 1 , } impl From < CeAtacmd > for bool { # [inline (always)] fn from (variant : CeAtacmd) -> Self { variant as u8 != 0 } } # [doc = "Field `CE_ATACMD` reader - CE-ATA command"] pub type CeAtacmdR = crate :: BitReader < CeAtacmd > ; impl CeAtacmdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> CeAtacmd { match self . bits { false => CeAtacmd :: Disabled , true => CeAtacmd :: Enabled , } } # [doc = "CE-ATA command disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == CeAtacmd :: Disabled } # [doc = "CE-ATA command enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == CeAtacmd :: Enabled } } # [doc = "Field `CE_ATACMD` writer - CE-ATA command"] pub type CeAtacmdW < 'a , REG > = crate :: BitWriter < 'a , REG , CeAtacmd > ; impl < 'a , REG > CeAtacmdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CE-ATA command disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (CeAtacmd :: Disabled) } # [doc = "CE-ATA command enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (CeAtacmd :: Enabled) } } impl R { # [doc = "Bits 0:5 - Command index"] # [inline (always)] pub fn cmdindex (& self) -> CmdindexR { CmdindexR :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:7 - Wait for response bits"] # [inline (always)] pub fn waitresp (& self) -> WaitrespR { WaitrespR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 8 - CPSM waits for interrupt request"] # [inline (always)] pub fn waitint (& self) -> WaitintR { WaitintR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - CPSM Waits for ends of data transfer (CmdPend internal signal)."] # [inline (always)] pub fn waitpend (& self) -> WaitpendR { WaitpendR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Command path state machine (CPSM) Enable bit"] # [inline (always)] pub fn cpsmen (& self) -> CpsmenR { CpsmenR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - SD I/O suspend command"] # [inline (always)] pub fn sdiosuspend (& self) -> SdiosuspendR { SdiosuspendR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Enable CMD completion"] # [inline (always)] pub fn encmdcompl (& self) -> EncmdcomplR { EncmdcomplR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - not Interrupt Enable"] # [inline (always)] pub fn n_ien (& self) -> NIenR { NIenR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - CE-ATA command"] # [inline (always)] pub fn ce_atacmd (& self) -> CeAtacmdR { CeAtacmdR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Command index"] # [inline (always)] pub fn cmdindex (& mut self) -> CmdindexW < CmdSpec > { CmdindexW :: new (self , 0) } # [doc = "Bits 6:7 - Wait for response bits"] # [inline (always)] pub fn waitresp (& mut self) -> WaitrespW < CmdSpec > { WaitrespW :: new (self , 6) } # [doc = "Bit 8 - CPSM waits for interrupt request"] # [inline (always)] pub fn waitint (& mut self) -> WaitintW < CmdSpec > { WaitintW :: new (self , 8) } # [doc = "Bit 9 - CPSM Waits for ends of data transfer (CmdPend internal signal)."] # [inline (always)] pub fn waitpend (& mut self) -> WaitpendW < CmdSpec > { WaitpendW :: new (self , 9) } # [doc = "Bit 10 - Command path state machine (CPSM) Enable bit"] # [inline (always)] pub fn cpsmen (& mut self) -> CpsmenW < CmdSpec > { CpsmenW :: new (self , 10) } # [doc = "Bit 11 - SD I/O suspend command"] # [inline (always)] pub fn sdiosuspend (& mut self) -> SdiosuspendW < CmdSpec > { SdiosuspendW :: new (self , 11) } # [doc = "Bit 12 - Enable CMD completion"] # [inline (always)] pub fn encmdcompl (& mut self) -> EncmdcomplW < CmdSpec > { EncmdcomplW :: new (self , 12) } # [doc = "Bit 13 - not Interrupt Enable"] # [inline (always)] pub fn n_ien (& mut self) -> NIenW < CmdSpec > { NIenW :: new (self , 13) } # [doc = "Bit 14 - CE-ATA command"] # [inline (always)] pub fn ce_atacmd (& mut self) -> CeAtacmdW < CmdSpec > { CeAtacmdW :: new (self , 14) } } # [doc = "command register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CmdSpec ; impl crate :: RegisterSpec for CmdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cmd::R`](R) reader structure"] impl crate :: Readable for CmdSpec { } # [doc = "`write(|w| ..)` method takes [`cmd::W`](W) writer structure"] impl crate :: Writable for CmdSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CMD to value 0"] impl crate :: Resettable for CmdSpec { }
# [doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "Data ready\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Drdy { # [doc = "0: The RNG_DR register is not yet valid, no random data is available"] NotValid = 0 , # [doc = "1: The RNG_DR register contains valid random data. Once the RNG_DR register has been read, this bit returns to 0 until a new random value is generated."] Valid = 1 , } impl From < Drdy > for bool { # [inline (always)] fn from (variant : Drdy) -> Self { variant as u8 != 0 } } # [doc = "Field `DRDY` reader - Data ready"] pub type DrdyR = crate :: BitReader < Drdy > ; impl DrdyR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Drdy { match self . bits { false => Drdy :: NotValid , true => Drdy :: Valid , } } # [doc = "The RNG_DR register is not yet valid, no random data is available"] # [inline (always)] pub fn is_not_valid (& self) -> bool { * self == Drdy :: NotValid } # [doc = "The RNG_DR register contains valid random data. Once the RNG_DR register has been read, this bit returns to 0 until a new random value is generated."] # [inline (always)] pub fn is_valid (& self) -> bool { * self == Drdy :: Valid } } # [doc = "Clock error current status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cecs { # [doc = "0: The RNG clock is correct (fRNGCLK> fHCLK/16). If the CEIS bit is set, this means that a slow clock was detected and the situation has been recovered."] Correct = 0 , # [doc = "1: The RNG clock is too slow (fRNGCLK< fHCLK/16)"] TooSlow = 1 , } impl From < Cecs > for bool { # [inline (always)] fn from (variant : Cecs) -> Self { variant as u8 != 0 } } # [doc = "Field `CECS` reader - Clock error current status"] pub type CecsR = crate :: BitReader < Cecs > ; impl CecsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cecs { match self . bits { false => Cecs :: Correct , true => Cecs :: TooSlow , } } # [doc = "The RNG clock is correct (fRNGCLK> fHCLK/16). If the CEIS bit is set, this means that a slow clock was detected and the situation has been recovered."] # [inline (always)] pub fn is_correct (& self) -> bool { * self == Cecs :: Correct } # [doc = "The RNG clock is too slow (fRNGCLK< fHCLK/16)"] # [inline (always)] pub fn is_too_slow (& self) -> bool { * self == Cecs :: TooSlow } } # [doc = "Seed error current status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Secs { # [doc = "0: No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered."] NoFaulty = 0 , # [doc = "1: One of the noise source has provided more than 64 consecutive bits at a constant value (“0” or “1”), or more than 32 consecutive occurrence of two bits patterns (“01” or “10”)"] Faulty = 1 , } impl From < Secs > for bool { # [inline (always)] fn from (variant : Secs) -> Self { variant as u8 != 0 } } # [doc = "Field `SECS` reader - Seed error current status"] pub type SecsR = crate :: BitReader < Secs > ; impl SecsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Secs { match self . bits { false => Secs :: NoFaulty , true => Secs :: Faulty , } } # [doc = "No faulty sequence has currently been detected. If the SEIS bit is set, this means that a faulty sequence was detected and the situation has been recovered."] # [inline (always)] pub fn is_no_faulty (& self) -> bool { * self == Secs :: NoFaulty } # [doc = "One of the noise source has provided more than 64 consecutive bits at a constant value (“0” or “1”), or more than 32 consecutive occurrence of two bits patterns (“01” or “10”)"] # [inline (always)] pub fn is_faulty (& self) -> bool { * self == Secs :: Faulty } } # [doc = "Clock error interrupt status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ceis { # [doc = "0: The RNG clock is correct (fRNGCLK > fHCLK/16)"] Correct = 0 , # [doc = "1: The RNG has been detected too slow (fRNGCLK < fHCLK/16) An interrupt is pending if IE = 1 in the RNG_CR register"] TooSlow = 1 , } impl From < Ceis > for bool { # [inline (always)] fn from (variant : Ceis) -> Self { variant as u8 != 0 } } # [doc = "Field `CEIS` reader - Clock error interrupt status"] pub type CeisR = crate :: BitReader < Ceis > ; impl CeisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ceis { match self . bits { false => Ceis :: Correct , true => Ceis :: TooSlow , } } # [doc = "The RNG clock is correct (fRNGCLK > fHCLK/16)"] # [inline (always)] pub fn is_correct (& self) -> bool { * self == Ceis :: Correct } # [doc = "The RNG has been detected too slow (fRNGCLK < fHCLK/16) An interrupt is pending if IE = 1 in the RNG_CR register"] # [inline (always)] pub fn is_too_slow (& self) -> bool { * self == Ceis :: TooSlow } } # [doc = "Field `CEIS` writer - Clock error interrupt status"] pub type CeisW < 'a , REG > = crate :: BitWriter < 'a , REG , Ceis > ; impl < 'a , REG > CeisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The RNG clock is correct (fRNGCLK > fHCLK/16)"] # [inline (always)] pub fn correct (self) -> & 'a mut crate :: W < REG > { self . variant (Ceis :: Correct) } # [doc = "The RNG has been detected too slow (fRNGCLK < fHCLK/16) An interrupt is pending if IE = 1 in the RNG_CR register"] # [inline (always)] pub fn too_slow (self) -> & 'a mut crate :: W < REG > { self . variant (Ceis :: TooSlow) } } # [doc = "Seed error interrupt status\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Seis { # [doc = "0: No faulty sequence detected"] NoFaulty = 0 , # [doc = "1: At least one faulty sequence has been detected. See **SECS** bit description for details. An interrupt is pending if IE = 1 in the RNG_CR register."] Faulty = 1 , } impl From < Seis > for bool { # [inline (always)] fn from (variant : Seis) -> Self { variant as u8 != 0 } } # [doc = "Field `SEIS` reader - Seed error interrupt status"] pub type SeisR = crate :: BitReader < Seis > ; impl SeisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Seis { match self . bits { false => Seis :: NoFaulty , true => Seis :: Faulty , } } # [doc = "No faulty sequence detected"] # [inline (always)] pub fn is_no_faulty (& self) -> bool { * self == Seis :: NoFaulty } # [doc = "At least one faulty sequence has been detected. See **SECS** bit description for details. An interrupt is pending if IE = 1 in the RNG_CR register."] # [inline (always)] pub fn is_faulty (& self) -> bool { * self == Seis :: Faulty } } # [doc = "Field `SEIS` writer - Seed error interrupt status"] pub type SeisW < 'a , REG > = crate :: BitWriter < 'a , REG , Seis > ; impl < 'a , REG > SeisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No faulty sequence detected"] # [inline (always)] pub fn no_faulty (self) -> & 'a mut crate :: W < REG > { self . variant (Seis :: NoFaulty) } # [doc = "At least one faulty sequence has been detected. See **SECS** bit description for details. An interrupt is pending if IE = 1 in the RNG_CR register."] # [inline (always)] pub fn faulty (self) -> & 'a mut crate :: W < REG > { self . variant (Seis :: Faulty) } } impl R { # [doc = "Bit 0 - Data ready"] # [inline (always)] pub fn drdy (& self) -> DrdyR { DrdyR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Clock error current status"] # [inline (always)] pub fn cecs (& self) -> CecsR { CecsR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Seed error current status"] # [inline (always)] pub fn secs (& self) -> SecsR { SecsR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 5 - Clock error interrupt status"] # [inline (always)] pub fn ceis (& self) -> CeisR { CeisR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Seed error interrupt status"] # [inline (always)] pub fn seis (& self) -> SeisR { SeisR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 5 - Clock error interrupt status"] # [inline (always)] pub fn ceis (& mut self) -> CeisW < SrSpec > { CeisW :: new (self , 5) } # [doc = "Bit 6 - Seed error interrupt status"] # [inline (always)] pub fn seis (& mut self) -> SeisW < SrSpec > { SeisW :: new (self , 6) } } # [doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { }
# [doc = "Register `BWTR%s` reader"] pub type R = crate :: R < BwtrSpec > ; # [doc = "Register `BWTR%s` writer"] pub type W = crate :: W < BwtrSpec > ; # [doc = "Field `ADDSET` reader - ADDSET"] pub type AddsetR = crate :: FieldReader ; # [doc = "Field `ADDSET` writer - ADDSET"] pub type AddsetW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "Field `ADDHLD` reader - ADDHLD"] pub type AddhldR = crate :: FieldReader ; # [doc = "Field `ADDHLD` writer - ADDHLD"] pub type AddhldW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `DATAST` reader - DATAST"] pub type DatastR = crate :: FieldReader ; # [doc = "Field `DATAST` writer - DATAST"] pub type DatastW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `BUSTURN` reader - BUSTURN"] pub type BusturnR = crate :: FieldReader ; # [doc = "Field `BUSTURN` writer - BUSTURN"] pub type BusturnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , u8 , crate :: Safe > ; # [doc = "ACCMOD\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Accmod { # [doc = "0: Access mode A"] A = 0 , # [doc = "1: Access mode B"] B = 1 , # [doc = "2: Access mode C"] C = 2 , # [doc = "3: Access mode D"] D = 3 , } impl From < Accmod > for u8 { # [inline (always)] fn from (variant : Accmod) -> Self { variant as _ } } impl crate :: FieldSpec for Accmod { type Ux = u8 ; } impl crate :: IsEnum for Accmod { } # [doc = "Field `ACCMOD` reader - ACCMOD"] pub type AccmodR = crate :: FieldReader < Accmod > ; impl AccmodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Accmod { match self . bits { 0 => Accmod :: A , 1 => Accmod :: B , 2 => Accmod :: C , 3 => Accmod :: D , _ => unreachable ! () , } } # [doc = "Access mode A"] # [inline (always)] pub fn is_a (& self) -> bool { * self == Accmod :: A } # [doc = "Access mode B"] # [inline (always)] pub fn is_b (& self) -> bool { * self == Accmod :: B } # [doc = "Access mode C"] # [inline (always)] pub fn is_c (& self) -> bool { * self == Accmod :: C } # [doc = "Access mode D"] # [inline (always)] pub fn is_d (& self) -> bool { * self == Accmod :: D } } # [doc = "Field `ACCMOD` writer - ACCMOD"] pub type AccmodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Accmod , crate :: Safe > ; impl < 'a , REG > AccmodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Access mode A"] # [inline (always)] pub fn a (self) -> & 'a mut crate :: W < REG > { self . variant (Accmod :: A) } # [doc = "Access mode B"] # [inline (always)] pub fn b (self) -> & 'a mut crate :: W < REG > { self . variant (Accmod :: B) } # [doc = "Access mode C"] # [inline (always)] pub fn c (self) -> & 'a mut crate :: W < REG > { self . variant (Accmod :: C) } # [doc = "Access mode D"] # [inline (always)] pub fn d (self) -> & 'a mut crate :: W < REG > { self . variant (Accmod :: D) } } impl R { # [doc = "Bits 0:3 - ADDSET"] # [inline (always)] pub fn addset (& self) -> AddsetR { AddsetR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - ADDHLD"] # [inline (always)] pub fn addhld (& self) -> AddhldR { AddhldR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:15 - DATAST"] # [inline (always)] pub fn datast (& self) -> DatastR { DatastR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:19 - BUSTURN"] # [inline (always)] pub fn busturn (& self) -> BusturnR { BusturnR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 28:29 - ACCMOD"] # [inline (always)] pub fn accmod (& self) -> AccmodR { AccmodR :: new (((self . bits >> 28) & 3) as u8) } } impl W { # [doc = "Bits 0:3 - ADDSET"] # [inline (always)] pub fn addset (& mut self) -> AddsetW < BwtrSpec > { AddsetW :: new (self , 0) } # [doc = "Bits 4:7 - ADDHLD"] # [inline (always)] pub fn addhld (& mut self) -> AddhldW < BwtrSpec > { AddhldW :: new (self , 4) } # [doc = "Bits 8:15 - DATAST"] # [inline (always)] pub fn datast (& mut self) -> DatastW < BwtrSpec > { DatastW :: new (self , 8) } # [doc = "Bits 16:19 - BUSTURN"] # [inline (always)] pub fn busturn (& mut self) -> BusturnW < BwtrSpec > { BusturnW :: new (self , 16) } # [doc = "Bits 28:29 - ACCMOD"] # [inline (always)] pub fn accmod (& mut self) -> AccmodW < BwtrSpec > { AccmodW :: new (self , 28) } } # [doc = "SRAM/NOR-Flash write timing registers %s\n\nYou can [`read`](crate::Reg::read) this register and get [`bwtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bwtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BwtrSpec ; impl crate :: RegisterSpec for BwtrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`bwtr::R`](R) reader structure"] impl crate :: Readable for BwtrSpec { } # [doc = "`write(|w| ..)` method takes [`bwtr::W`](W) writer structure"] impl crate :: Writable for BwtrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets BWTR%s to value 0x0fff_ffff"] impl crate :: Resettable for BwtrSpec { const RESET_VALUE : u32 = 0x0fff_ffff ; }
# [doc = "Register `BCR%s` reader"] pub type R = crate :: R < BcrSpec > ; # [doc = "Register `BCR%s` writer"] pub type W = crate :: W < BcrSpec > ; # [doc = "MBKEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Mbken { # [doc = "0: Corresponding memory bank is disabled"] Disabled = 0 , # [doc = "1: Corresponding memory bank is enabled"] Enabled = 1 , } impl From < Mbken > for bool { # [inline (always)] fn from (variant : Mbken) -> Self { variant as u8 != 0 } } # [doc = "Field `MBKEN` reader - MBKEN"] pub type MbkenR = crate :: BitReader < Mbken > ; impl MbkenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Mbken { match self . bits { false => Mbken :: Disabled , true => Mbken :: Enabled , } } # [doc = "Corresponding memory bank is disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Mbken :: Disabled } # [doc = "Corresponding memory bank is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Mbken :: Enabled } } # [doc = "Field `MBKEN` writer - MBKEN"] pub type MbkenW < 'a , REG > = crate :: BitWriter < 'a , REG , Mbken > ; impl < 'a , REG > MbkenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Corresponding memory bank is disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Mbken :: Disabled) } # [doc = "Corresponding memory bank is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Mbken :: Enabled) } } # [doc = "MUXEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Muxen { # [doc = "0: Address/Data non-multiplexed"] Disabled = 0 , # [doc = "1: Address/Data multiplexed on databus"] Enabled = 1 , } impl From < Muxen > for bool { # [inline (always)] fn from (variant : Muxen) -> Self { variant as u8 != 0 } } # [doc = "Field `MUXEN` reader - MUXEN"] pub type MuxenR = crate :: BitReader < Muxen > ; impl MuxenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Muxen { match self . bits { false => Muxen :: Disabled , true => Muxen :: Enabled , } } # [doc = "Address/Data non-multiplexed"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Muxen :: Disabled } # [doc = "Address/Data multiplexed on databus"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Muxen :: Enabled } } # [doc = "Field `MUXEN` writer - MUXEN"] pub type MuxenW < 'a , REG > = crate :: BitWriter < 'a , REG , Muxen > ; impl < 'a , REG > MuxenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Address/Data non-multiplexed"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Muxen :: Disabled) } # [doc = "Address/Data multiplexed on databus"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Muxen :: Enabled) } } # [doc = "MTYP\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Mtyp { # [doc = "0: SRAM memory type"] Sram = 0 , # [doc = "1: PSRAM (CRAM) memory type"] Psram = 1 , # [doc = "2: NOR Flash/OneNAND Flash"] Flash = 2 , } impl From < Mtyp > for u8 { # [inline (always)] fn from (variant : Mtyp) -> Self { variant as _ } } impl crate :: FieldSpec for Mtyp { type Ux = u8 ; } impl crate :: IsEnum for Mtyp { } # [doc = "Field `MTYP` reader - MTYP"] pub type MtypR = crate :: FieldReader < Mtyp > ; impl MtypR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Mtyp > { match self . bits { 0 => Some (Mtyp :: Sram) , 1 => Some (Mtyp :: Psram) , 2 => Some (Mtyp :: Flash) , _ => None , } } # [doc = "SRAM memory type"] # [inline (always)] pub fn is_sram (& self) -> bool { * self == Mtyp :: Sram } # [doc = "PSRAM (CRAM) memory type"] # [inline (always)] pub fn is_psram (& self) -> bool { * self == Mtyp :: Psram } # [doc = "NOR Flash/OneNAND Flash"] # [inline (always)] pub fn is_flash (& self) -> bool { * self == Mtyp :: Flash } } # [doc = "Field `MTYP` writer - MTYP"] pub type MtypW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mtyp > ; impl < 'a , REG > MtypW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "SRAM memory type"] # [inline (always)] pub fn sram (self) -> & 'a mut crate :: W < REG > { self . variant (Mtyp :: Sram) } # [doc = "PSRAM (CRAM) memory type"] # [inline (always)] pub fn psram (self) -> & 'a mut crate :: W < REG > { self . variant (Mtyp :: Psram) } # [doc = "NOR Flash/OneNAND Flash"] # [inline (always)] pub fn flash (self) -> & 'a mut crate :: W < REG > { self . variant (Mtyp :: Flash) } } # [doc = "MWID\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Mwid { # [doc = "0: Memory data bus width 8 bits"] Bits8 = 0 , # [doc = "1: Memory data bus width 16 bits"] Bits16 = 1 , # [doc = "2: Memory data bus width 32 bits"] Bits32 = 2 , } impl From < Mwid > for u8 { # [inline (always)] fn from (variant : Mwid) -> Self { variant as _ } } impl crate :: FieldSpec for Mwid { type Ux = u8 ; } impl crate :: IsEnum for Mwid { } # [doc = "Field `MWID` reader - MWID"] pub type MwidR = crate :: FieldReader < Mwid > ; impl MwidR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Mwid > { match self . bits { 0 => Some (Mwid :: Bits8) , 1 => Some (Mwid :: Bits16) , 2 => Some (Mwid :: Bits32) , _ => None , } } # [doc = "Memory data bus width 8 bits"] # [inline (always)] pub fn is_bits8 (& self) -> bool { * self == Mwid :: Bits8 } # [doc = "Memory data bus width 16 bits"] # [inline (always)] pub fn is_bits16 (& self) -> bool { * self == Mwid :: Bits16 } # [doc = "Memory data bus width 32 bits"] # [inline (always)] pub fn is_bits32 (& self) -> bool { * self == Mwid :: Bits32 } } # [doc = "Field `MWID` writer - MWID"] pub type MwidW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mwid > ; impl < 'a , REG > MwidW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Memory data bus width 8 bits"] # [inline (always)] pub fn bits8 (self) -> & 'a mut crate :: W < REG > { self . variant (Mwid :: Bits8) } # [doc = "Memory data bus width 16 bits"] # [inline (always)] pub fn bits16 (self) -> & 'a mut crate :: W < REG > { self . variant (Mwid :: Bits16) } # [doc = "Memory data bus width 32 bits"] # [inline (always)] pub fn bits32 (self) -> & 'a mut crate :: W < REG > { self . variant (Mwid :: Bits32) } } # [doc = "FACCEN\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Faccen { # [doc = "0: Corresponding NOR Flash memory access is disabled"] Disabled = 0 , # [doc = "1: Corresponding NOR Flash memory access is enabled"] Enabled = 1 , } impl From < Faccen > for bool { # [inline (always)] fn from (variant : Faccen) -> Self { variant as u8 != 0 } } # [doc = "Field `FACCEN` reader - FACCEN"] pub type FaccenR = crate :: BitReader < Faccen > ; impl FaccenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Faccen { match self . bits { false => Faccen :: Disabled , true => Faccen :: Enabled , } } # [doc = "Corresponding NOR Flash memory access is disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Faccen :: Disabled } # [doc = "Corresponding NOR Flash memory access is enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Faccen :: Enabled } } # [doc = "Field `FACCEN` writer - FACCEN"] pub type FaccenW < 'a , REG > = crate :: BitWriter < 'a , REG , Faccen > ; impl < 'a , REG > FaccenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Corresponding NOR Flash memory access is disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Faccen :: Disabled) } # [doc = "Corresponding NOR Flash memory access is enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Faccen :: Enabled) } } # [doc = "BURSTEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bursten { # [doc = "0: Burst mode disabled"] Disabled = 0 , # [doc = "1: Burst mode enabled"] Enabled = 1 , } impl From < Bursten > for bool { # [inline (always)] fn from (variant : Bursten) -> Self { variant as u8 != 0 } } # [doc = "Field `BURSTEN` reader - BURSTEN"] pub type BurstenR = crate :: BitReader < Bursten > ; impl BurstenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bursten { match self . bits { false => Bursten :: Disabled , true => Bursten :: Enabled , } } # [doc = "Burst mode disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Bursten :: Disabled } # [doc = "Burst mode enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Bursten :: Enabled } } # [doc = "Field `BURSTEN` writer - BURSTEN"] pub type BurstenW < 'a , REG > = crate :: BitWriter < 'a , REG , Bursten > ; impl < 'a , REG > BurstenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Burst mode disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bursten :: Disabled) } # [doc = "Burst mode enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bursten :: Enabled) } } # [doc = "WAITPOL\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waitpol { # [doc = "0: NWAIT active low"] ActiveLow = 0 , # [doc = "1: NWAIT active high"] ActiveHigh = 1 , } impl From < Waitpol > for bool { # [inline (always)] fn from (variant : Waitpol) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITPOL` reader - WAITPOL"] pub type WaitpolR = crate :: BitReader < Waitpol > ; impl WaitpolR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waitpol { match self . bits { false => Waitpol :: ActiveLow , true => Waitpol :: ActiveHigh , } } # [doc = "NWAIT active low"] # [inline (always)] pub fn is_active_low (& self) -> bool { * self == Waitpol :: ActiveLow } # [doc = "NWAIT active high"] # [inline (always)] pub fn is_active_high (& self) -> bool { * self == Waitpol :: ActiveHigh } } # [doc = "Field `WAITPOL` writer - WAITPOL"] pub type WaitpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Waitpol > ; impl < 'a , REG > WaitpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NWAIT active low"] # [inline (always)] pub fn active_low (self) -> & 'a mut crate :: W < REG > { self . variant (Waitpol :: ActiveLow) } # [doc = "NWAIT active high"] # [inline (always)] pub fn active_high (self) -> & 'a mut crate :: W < REG > { self . variant (Waitpol :: ActiveHigh) } } # [doc = "Field `WRAPMOD` reader - WRAPMOD"] pub type WrapmodR = crate :: BitReader ; # [doc = "Field `WRAPMOD` writer - WRAPMOD"] pub type WrapmodW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "WAITCFG\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waitcfg { # [doc = "0: NWAIT signal is active one data cycle before wait state"] BeforeWaitState = 0 , # [doc = "1: NWAIT signal is active during wait state"] DuringWaitState = 1 , } impl From < Waitcfg > for bool { # [inline (always)] fn from (variant : Waitcfg) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITCFG` reader - WAITCFG"] pub type WaitcfgR = crate :: BitReader < Waitcfg > ; impl WaitcfgR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waitcfg { match self . bits { false => Waitcfg :: BeforeWaitState , true => Waitcfg :: DuringWaitState , } } # [doc = "NWAIT signal is active one data cycle before wait state"] # [inline (always)] pub fn is_before_wait_state (& self) -> bool { * self == Waitcfg :: BeforeWaitState } # [doc = "NWAIT signal is active during wait state"] # [inline (always)] pub fn is_during_wait_state (& self) -> bool { * self == Waitcfg :: DuringWaitState } } # [doc = "Field `WAITCFG` writer - WAITCFG"] pub type WaitcfgW < 'a , REG > = crate :: BitWriter < 'a , REG , Waitcfg > ; impl < 'a , REG > WaitcfgW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "NWAIT signal is active one data cycle before wait state"] # [inline (always)] pub fn before_wait_state (self) -> & 'a mut crate :: W < REG > { self . variant (Waitcfg :: BeforeWaitState) } # [doc = "NWAIT signal is active during wait state"] # [inline (always)] pub fn during_wait_state (self) -> & 'a mut crate :: W < REG > { self . variant (Waitcfg :: DuringWaitState) } } # [doc = "WREN\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Wren { # [doc = "0: Write operations disabled for the bank by the FMC"] Disabled = 0 , # [doc = "1: Write operations enabled for the bank by the FMC"] Enabled = 1 , } impl From < Wren > for bool { # [inline (always)] fn from (variant : Wren) -> Self { variant as u8 != 0 } } # [doc = "Field `WREN` reader - WREN"] pub type WrenR = crate :: BitReader < Wren > ; impl WrenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Wren { match self . bits { false => Wren :: Disabled , true => Wren :: Enabled , } } # [doc = "Write operations disabled for the bank by the FMC"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Wren :: Disabled } # [doc = "Write operations enabled for the bank by the FMC"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Wren :: Enabled } } # [doc = "Field `WREN` writer - WREN"] pub type WrenW < 'a , REG > = crate :: BitWriter < 'a , REG , Wren > ; impl < 'a , REG > WrenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Write operations disabled for the bank by the FMC"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wren :: Disabled) } # [doc = "Write operations enabled for the bank by the FMC"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Wren :: Enabled) } } # [doc = "WAITEN\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Waiten { # [doc = "0: Values inside the FMC_BWTR are taken into account"] Disabled = 0 , # [doc = "1: NWAIT signal enabled"] Enabled = 1 , } impl From < Waiten > for bool { # [inline (always)] fn from (variant : Waiten) -> Self { variant as u8 != 0 } } # [doc = "Field `WAITEN` reader - WAITEN"] pub type WaitenR = crate :: BitReader < Waiten > ; impl WaitenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Waiten { match self . bits { false => Waiten :: Disabled , true => Waiten :: Enabled , } } # [doc = "Values inside the FMC_BWTR are taken into account"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Waiten :: Disabled } # [doc = "NWAIT signal enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Waiten :: Enabled } } # [doc = "Field `WAITEN` writer - WAITEN"] pub type WaitenW < 'a , REG > = crate :: BitWriter < 'a , REG , Waiten > ; impl < 'a , REG > WaitenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Values inside the FMC_BWTR are taken into account"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waiten :: Disabled) } # [doc = "NWAIT signal enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Waiten :: Enabled) } } # [doc = "EXTMOD\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Extmod { # [doc = "0: Values inside the FMC_BWTR are not taken into account"] Disabled = 0 , # [doc = "1: Values inside the FMC_BWTR are taken into account"] Enabled = 1 , } impl From < Extmod > for bool { # [inline (always)] fn from (variant : Extmod) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTMOD` reader - EXTMOD"] pub type ExtmodR = crate :: BitReader < Extmod > ; impl ExtmodR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Extmod { match self . bits { false => Extmod :: Disabled , true => Extmod :: Enabled , } } # [doc = "Values inside the FMC_BWTR are not taken into account"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Extmod :: Disabled } # [doc = "Values inside the FMC_BWTR are taken into account"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Extmod :: Enabled } } # [doc = "Field `EXTMOD` writer - EXTMOD"] pub type ExtmodW < 'a , REG > = crate :: BitWriter < 'a , REG , Extmod > ; impl < 'a , REG > ExtmodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Values inside the FMC_BWTR are not taken into account"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Extmod :: Disabled) } # [doc = "Values inside the FMC_BWTR are taken into account"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Extmod :: Enabled) } } # [doc = "ASYNCWAIT\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Asyncwait { # [doc = "0: Wait signal not used in asynchronous mode"] Disabled = 0 , # [doc = "1: Wait signal used even in asynchronous mode"] Enabled = 1 , } impl From < Asyncwait > for bool { # [inline (always)] fn from (variant : Asyncwait) -> Self { variant as u8 != 0 } } # [doc = "Field `ASYNCWAIT` reader - ASYNCWAIT"] pub type AsyncwaitR = crate :: BitReader < Asyncwait > ; impl AsyncwaitR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Asyncwait { match self . bits { false => Asyncwait :: Disabled , true => Asyncwait :: Enabled , } } # [doc = "Wait signal not used in asynchronous mode"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Asyncwait :: Disabled } # [doc = "Wait signal used even in asynchronous mode"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Asyncwait :: Enabled } } # [doc = "Field `ASYNCWAIT` writer - ASYNCWAIT"] pub type AsyncwaitW < 'a , REG > = crate :: BitWriter < 'a , REG , Asyncwait > ; impl < 'a , REG > AsyncwaitW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Wait signal not used in asynchronous mode"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Asyncwait :: Disabled) } # [doc = "Wait signal used even in asynchronous mode"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Asyncwait :: Enabled) } } # [doc = "CPSIZE\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Cpsize { # [doc = "0: No burst split when crossing page boundary"] NoBurstSplit = 0 , # [doc = "1: 128 bytes CRAM page size"] Bytes128 = 1 , # [doc = "2: 256 bytes CRAM page size"] Bytes256 = 2 , # [doc = "3: 512 bytes CRAM page size"] Bytes512 = 3 , # [doc = "4: 1024 bytes CRAM page size"] Bytes1024 = 4 , } impl From < Cpsize > for u8 { # [inline (always)] fn from (variant : Cpsize) -> Self { variant as _ } } impl crate :: FieldSpec for Cpsize { type Ux = u8 ; } impl crate :: IsEnum for Cpsize { } # [doc = "Field `CPSIZE` reader - CPSIZE"] pub type CpsizeR = crate :: FieldReader < Cpsize > ; impl CpsizeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Cpsize > { match self . bits { 0 => Some (Cpsize :: NoBurstSplit) , 1 => Some (Cpsize :: Bytes128) , 2 => Some (Cpsize :: Bytes256) , 3 => Some (Cpsize :: Bytes512) , 4 => Some (Cpsize :: Bytes1024) , _ => None , } } # [doc = "No burst split when crossing page boundary"] # [inline (always)] pub fn is_no_burst_split (& self) -> bool { * self == Cpsize :: NoBurstSplit } # [doc = "128 bytes CRAM page size"] # [inline (always)] pub fn is_bytes128 (& self) -> bool { * self == Cpsize :: Bytes128 } # [doc = "256 bytes CRAM page size"] # [inline (always)] pub fn is_bytes256 (& self) -> bool { * self == Cpsize :: Bytes256 } # [doc = "512 bytes CRAM page size"] # [inline (always)] pub fn is_bytes512 (& self) -> bool { * self == Cpsize :: Bytes512 } # [doc = "1024 bytes CRAM page size"] # [inline (always)] pub fn is_bytes1024 (& self) -> bool { * self == Cpsize :: Bytes1024 } } # [doc = "Field `CPSIZE` writer - CPSIZE"] pub type CpsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Cpsize > ; impl < 'a , REG > CpsizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No burst split when crossing page boundary"] # [inline (always)] pub fn no_burst_split (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsize :: NoBurstSplit) } # [doc = "128 bytes CRAM page size"] # [inline (always)] pub fn bytes128 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsize :: Bytes128) } # [doc = "256 bytes CRAM page size"] # [inline (always)] pub fn bytes256 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsize :: Bytes256) } # [doc = "512 bytes CRAM page size"] # [inline (always)] pub fn bytes512 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsize :: Bytes512) } # [doc = "1024 bytes CRAM page size"] # [inline (always)] pub fn bytes1024 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpsize :: Bytes1024) } } # [doc = "CBURSTRW\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cburstrw { # [doc = "0: Write operations are always performed in asynchronous mode"] Disabled = 0 , # [doc = "1: Write operations are performed in synchronous mode"] Enabled = 1 , } impl From < Cburstrw > for bool { # [inline (always)] fn from (variant : Cburstrw) -> Self { variant as u8 != 0 } } # [doc = "Field `CBURSTRW` reader - CBURSTRW"] pub type CburstrwR = crate :: BitReader < Cburstrw > ; impl CburstrwR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cburstrw { match self . bits { false => Cburstrw :: Disabled , true => Cburstrw :: Enabled , } } # [doc = "Write operations are always performed in asynchronous mode"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Cburstrw :: Disabled } # [doc = "Write operations are performed in synchronous mode"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Cburstrw :: Enabled } } # [doc = "Field `CBURSTRW` writer - CBURSTRW"] pub type CburstrwW < 'a , REG > = crate :: BitWriter < 'a , REG , Cburstrw > ; impl < 'a , REG > CburstrwW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Write operations are always performed in asynchronous mode"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cburstrw :: Disabled) } # [doc = "Write operations are performed in synchronous mode"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cburstrw :: Enabled) } } impl R { # [doc = "Bit 0 - MBKEN"] # [inline (always)] pub fn mbken (& self) -> MbkenR { MbkenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - MUXEN"] # [inline (always)] pub fn muxen (& self) -> MuxenR { MuxenR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - MTYP"] # [inline (always)] pub fn mtyp (& self) -> MtypR { MtypR :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - MWID"] # [inline (always)] pub fn mwid (& self) -> MwidR { MwidR :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 6 - FACCEN"] # [inline (always)] pub fn faccen (& self) -> FaccenR { FaccenR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - BURSTEN"] # [inline (always)] pub fn bursten (& self) -> BurstenR { BurstenR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - WAITPOL"] # [inline (always)] pub fn waitpol (& self) -> WaitpolR { WaitpolR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - WRAPMOD"] # [inline (always)] pub fn wrapmod (& self) -> WrapmodR { WrapmodR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - WAITCFG"] # [inline (always)] pub fn waitcfg (& self) -> WaitcfgR { WaitcfgR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - WREN"] # [inline (always)] pub fn wren (& self) -> WrenR { WrenR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - WAITEN"] # [inline (always)] pub fn waiten (& self) -> WaitenR { WaitenR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - EXTMOD"] # [inline (always)] pub fn extmod (& self) -> ExtmodR { ExtmodR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - ASYNCWAIT"] # [inline (always)] pub fn asyncwait (& self) -> AsyncwaitR { AsyncwaitR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:18 - CPSIZE"] # [inline (always)] pub fn cpsize (& self) -> CpsizeR { CpsizeR :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bit 19 - CBURSTRW"] # [inline (always)] pub fn cburstrw (& self) -> CburstrwR { CburstrwR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - MBKEN"] # [inline (always)] pub fn mbken (& mut self) -> MbkenW < BcrSpec > { MbkenW :: new (self , 0) } # [doc = "Bit 1 - MUXEN"] # [inline (always)] pub fn muxen (& mut self) -> MuxenW < BcrSpec > { MuxenW :: new (self , 1) } # [doc = "Bits 2:3 - MTYP"] # [inline (always)] pub fn mtyp (& mut self) -> MtypW < BcrSpec > { MtypW :: new (self , 2) } # [doc = "Bits 4:5 - MWID"] # [inline (always)] pub fn mwid (& mut self) -> MwidW < BcrSpec > { MwidW :: new (self , 4) } # [doc = "Bit 6 - FACCEN"] # [inline (always)] pub fn faccen (& mut self) -> FaccenW < BcrSpec > { FaccenW :: new (self , 6) } # [doc = "Bit 8 - BURSTEN"] # [inline (always)] pub fn bursten (& mut self) -> BurstenW < BcrSpec > { BurstenW :: new (self , 8) } # [doc = "Bit 9 - WAITPOL"] # [inline (always)] pub fn waitpol (& mut self) -> WaitpolW < BcrSpec > { WaitpolW :: new (self , 9) } # [doc = "Bit 10 - WRAPMOD"] # [inline (always)] pub fn wrapmod (& mut self) -> WrapmodW < BcrSpec > { WrapmodW :: new (self , 10) } # [doc = "Bit 11 - WAITCFG"] # [inline (always)] pub fn waitcfg (& mut self) -> WaitcfgW < BcrSpec > { WaitcfgW :: new (self , 11) } # [doc = "Bit 12 - WREN"] # [inline (always)] pub fn wren (& mut self) -> WrenW < BcrSpec > { WrenW :: new (self , 12) } # [doc = "Bit 13 - WAITEN"] # [inline (always)] pub fn waiten (& mut self) -> WaitenW < BcrSpec > { WaitenW :: new (self , 13) } # [doc = "Bit 14 - EXTMOD"] # [inline (always)] pub fn extmod (& mut self) -> ExtmodW < BcrSpec > { ExtmodW :: new (self , 14) } # [doc = "Bit 15 - ASYNCWAIT"] # [inline (always)] pub fn asyncwait (& mut self) -> AsyncwaitW < BcrSpec > { AsyncwaitW :: new (self , 15) } # [doc = "Bits 16:18 - CPSIZE"] # [inline (always)] pub fn cpsize (& mut self) -> CpsizeW < BcrSpec > { CpsizeW :: new (self , 16) } # [doc = "Bit 19 - CBURSTRW"] # [inline (always)] pub fn cburstrw (& mut self) -> CburstrwW < BcrSpec > { CburstrwW :: new (self , 19) } } # [doc = "SRAM/NOR-Flash chip-select control register %s\n\nYou can [`read`](crate::Reg::read) this register and get [`bcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BcrSpec ; impl crate :: RegisterSpec for BcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`bcr::R`](R) reader structure"] impl crate :: Readable for BcrSpec { } # [doc = "`write(|w| ..)` method takes [`bcr::W`](W) writer structure"] impl crate :: Writable for BcrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets BCR%s to value 0x30d0"] impl crate :: Resettable for BcrSpec { const RESET_VALUE : u32 = 0x30d0 ; }
# [doc = "Register `SR%s` reader"] pub type R = crate :: R < SrSpec > ; # [doc = "Register `SR%s` writer"] pub type W = crate :: W < SrSpec > ; # [doc = "IRS\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Irs { # [doc = "0: Interrupt rising edge did not occur"] DidNotOccur = 0 , # [doc = "1: Interrupt rising edge occurred"] Occurred = 1 , } impl From < Irs > for bool { # [inline (always)] fn from (variant : Irs) -> Self { variant as u8 != 0 } } # [doc = "Field `IRS` reader - IRS"] pub type IrsR = crate :: BitReader < Irs > ; impl IrsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Irs { match self . bits { false => Irs :: DidNotOccur , true => Irs :: Occurred , } } # [doc = "Interrupt rising edge did not occur"] # [inline (always)] pub fn is_did_not_occur (& self) -> bool { * self == Irs :: DidNotOccur } # [doc = "Interrupt rising edge occurred"] # [inline (always)] pub fn is_occurred (& self) -> bool { * self == Irs :: Occurred } } # [doc = "Field `IRS` writer - IRS"] pub type IrsW < 'a , REG > = crate :: BitWriter < 'a , REG , Irs > ; impl < 'a , REG > IrsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt rising edge did not occur"] # [inline (always)] pub fn did_not_occur (self) -> & 'a mut crate :: W < REG > { self . variant (Irs :: DidNotOccur) } # [doc = "Interrupt rising edge occurred"] # [inline (always)] pub fn occurred (self) -> & 'a mut crate :: W < REG > { self . variant (Irs :: Occurred) } } # [doc = "ILS\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ils { # [doc = "0: Interrupt high-level did not occur"] DidNotOccur = 0 , # [doc = "1: Interrupt high-level occurred"] Occurred = 1 , } impl From < Ils > for bool { # [inline (always)] fn from (variant : Ils) -> Self { variant as u8 != 0 } } # [doc = "Field `ILS` reader - ILS"] pub type IlsR = crate :: BitReader < Ils > ; impl IlsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ils { match self . bits { false => Ils :: DidNotOccur , true => Ils :: Occurred , } } # [doc = "Interrupt high-level did not occur"] # [inline (always)] pub fn is_did_not_occur (& self) -> bool { * self == Ils :: DidNotOccur } # [doc = "Interrupt high-level occurred"] # [inline (always)] pub fn is_occurred (& self) -> bool { * self == Ils :: Occurred } } # [doc = "Field `ILS` writer - ILS"] pub type IlsW < 'a , REG > = crate :: BitWriter < 'a , REG , Ils > ; impl < 'a , REG > IlsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt high-level did not occur"] # [inline (always)] pub fn did_not_occur (self) -> & 'a mut crate :: W < REG > { self . variant (Ils :: DidNotOccur) } # [doc = "Interrupt high-level occurred"] # [inline (always)] pub fn occurred (self) -> & 'a mut crate :: W < REG > { self . variant (Ils :: Occurred) } } # [doc = "IFS\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ifs { # [doc = "0: Interrupt falling edge did not occur"] DidNotOccur = 0 , # [doc = "1: Interrupt falling edge occurred"] Occurred = 1 , } impl From < Ifs > for bool { # [inline (always)] fn from (variant : Ifs) -> Self { variant as u8 != 0 } } # [doc = "Field `IFS` reader - IFS"] pub type IfsR = crate :: BitReader < Ifs > ; impl IfsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ifs { match self . bits { false => Ifs :: DidNotOccur , true => Ifs :: Occurred , } } # [doc = "Interrupt falling edge did not occur"] # [inline (always)] pub fn is_did_not_occur (& self) -> bool { * self == Ifs :: DidNotOccur } # [doc = "Interrupt falling edge occurred"] # [inline (always)] pub fn is_occurred (& self) -> bool { * self == Ifs :: Occurred } } # [doc = "Field `IFS` writer - IFS"] pub type IfsW < 'a , REG > = crate :: BitWriter < 'a , REG , Ifs > ; impl < 'a , REG > IfsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt falling edge did not occur"] # [inline (always)] pub fn did_not_occur (self) -> & 'a mut crate :: W < REG > { self . variant (Ifs :: DidNotOccur) } # [doc = "Interrupt falling edge occurred"] # [inline (always)] pub fn occurred (self) -> & 'a mut crate :: W < REG > { self . variant (Ifs :: Occurred) } } # [doc = "IREN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Iren { # [doc = "0: Interrupt rising edge detection request disabled"] Disabled = 0 , # [doc = "1: Interrupt rising edge detection request enabled"] Enabled = 1 , } impl From < Iren > for bool { # [inline (always)] fn from (variant : Iren) -> Self { variant as u8 != 0 } } # [doc = "Field `IREN` reader - IREN"] pub type IrenR = crate :: BitReader < Iren > ; impl IrenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Iren { match self . bits { false => Iren :: Disabled , true => Iren :: Enabled , } } # [doc = "Interrupt rising edge detection request disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Iren :: Disabled } # [doc = "Interrupt rising edge detection request enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Iren :: Enabled } } # [doc = "Field `IREN` writer - IREN"] pub type IrenW < 'a , REG > = crate :: BitWriter < 'a , REG , Iren > ; impl < 'a , REG > IrenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt rising edge detection request disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iren :: Disabled) } # [doc = "Interrupt rising edge detection request enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Iren :: Enabled) } } # [doc = "ILEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ilen { # [doc = "0: Interrupt high-level detection request disabled"] Disabled = 0 , # [doc = "1: Interrupt high-level detection request enabled"] Enabled = 1 , } impl From < Ilen > for bool { # [inline (always)] fn from (variant : Ilen) -> Self { variant as u8 != 0 } } # [doc = "Field `ILEN` reader - ILEN"] pub type IlenR = crate :: BitReader < Ilen > ; impl IlenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ilen { match self . bits { false => Ilen :: Disabled , true => Ilen :: Enabled , } } # [doc = "Interrupt high-level detection request disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ilen :: Disabled } # [doc = "Interrupt high-level detection request enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ilen :: Enabled } } # [doc = "Field `ILEN` writer - ILEN"] pub type IlenW < 'a , REG > = crate :: BitWriter < 'a , REG , Ilen > ; impl < 'a , REG > IlenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt high-level detection request disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ilen :: Disabled) } # [doc = "Interrupt high-level detection request enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ilen :: Enabled) } } # [doc = "IFEN\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ifen { # [doc = "0: Interrupt falling edge detection request disabled"] Disabled = 0 , # [doc = "1: Interrupt falling edge detection request enabled"] Enabled = 1 , } impl From < Ifen > for bool { # [inline (always)] fn from (variant : Ifen) -> Self { variant as u8 != 0 } } # [doc = "Field `IFEN` reader - IFEN"] pub type IfenR = crate :: BitReader < Ifen > ; impl IfenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ifen { match self . bits { false => Ifen :: Disabled , true => Ifen :: Enabled , } } # [doc = "Interrupt falling edge detection request disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Ifen :: Disabled } # [doc = "Interrupt falling edge detection request enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Ifen :: Enabled } } # [doc = "Field `IFEN` writer - IFEN"] pub type IfenW < 'a , REG > = crate :: BitWriter < 'a , REG , Ifen > ; impl < 'a , REG > IfenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Interrupt falling edge detection request disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ifen :: Disabled) } # [doc = "Interrupt falling edge detection request enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ifen :: Enabled) } } # [doc = "FEMPT\n\nValue on reset: 1"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Fempt { # [doc = "0: FIFO not empty"] NotEmpty = 0 , # [doc = "1: FIFO empty"] Empty = 1 , } impl From < Fempt > for bool { # [inline (always)] fn from (variant : Fempt) -> Self { variant as u8 != 0 } } # [doc = "Field `FEMPT` reader - FEMPT"] pub type FemptR = crate :: BitReader < Fempt > ; impl FemptR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Fempt { match self . bits { false => Fempt :: NotEmpty , true => Fempt :: Empty , } } # [doc = "FIFO not empty"] # [inline (always)] pub fn is_not_empty (& self) -> bool { * self == Fempt :: NotEmpty } # [doc = "FIFO empty"] # [inline (always)] pub fn is_empty (& self) -> bool { * self == Fempt :: Empty } } impl R { # [doc = "Bit 0 - IRS"] # [inline (always)] pub fn irs (& self) -> IrsR { IrsR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ILS"] # [inline (always)] pub fn ils (& self) -> IlsR { IlsR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - IFS"] # [inline (always)] pub fn ifs (& self) -> IfsR { IfsR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - IREN"] # [inline (always)] pub fn iren (& self) -> IrenR { IrenR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ILEN"] # [inline (always)] pub fn ilen (& self) -> IlenR { IlenR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - IFEN"] # [inline (always)] pub fn ifen (& self) -> IfenR { IfenR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - FEMPT"] # [inline (always)] pub fn fempt (& self) -> FemptR { FemptR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - IRS"] # [inline (always)] pub fn irs (& mut self) -> IrsW < SrSpec > { IrsW :: new (self , 0) } # [doc = "Bit 1 - ILS"] # [inline (always)] pub fn ils (& mut self) -> IlsW < SrSpec > { IlsW :: new (self , 1) } # [doc = "Bit 2 - IFS"] # [inline (always)] pub fn ifs (& mut self) -> IfsW < SrSpec > { IfsW :: new (self , 2) } # [doc = "Bit 3 - IREN"] # [inline (always)] pub fn iren (& mut self) -> IrenW < SrSpec > { IrenW :: new (self , 3) } # [doc = "Bit 4 - ILEN"] # [inline (always)] pub fn ilen (& mut self) -> IlenW < SrSpec > { IlenW :: new (self , 4) } # [doc = "Bit 5 - IFEN"] # [inline (always)] pub fn ifen (& mut self) -> IfenW < SrSpec > { IfenW :: new (self , 5) } } # [doc = "FIFO status and interrupt register %s\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { } # [doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets SR%s to value 0x40"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0x40 ; }
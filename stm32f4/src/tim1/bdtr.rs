# [doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ; # [doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ; # [doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ; # [doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 , u8 , crate :: Safe > ; # [doc = "Lock configuration\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Lock { # [doc = "0: No bit is write protected"] Off = 0 , # [doc = "1: Any bits except MOE, OSSR, OSSI and LOCK in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register can no longer be written"] Level1 = 1 , # [doc = "2: LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written"] Level2 = 2 , # [doc = "3: LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written"] Level3 = 3 , } impl From < Lock > for u8 { # [inline (always)] fn from (variant : Lock) -> Self { variant as _ } } impl crate :: FieldSpec for Lock { type Ux = u8 ; } impl crate :: IsEnum for Lock { } # [doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader < Lock > ; impl LockR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Lock { match self . bits { 0 => Lock :: Off , 1 => Lock :: Level1 , 2 => Lock :: Level2 , 3 => Lock :: Level3 , _ => unreachable ! () , } } # [doc = "No bit is write protected"] # [inline (always)] pub fn is_off (& self) -> bool { * self == Lock :: Off } # [doc = "Any bits except MOE, OSSR, OSSI and LOCK in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register can no longer be written"] # [inline (always)] pub fn is_level1 (& self) -> bool { * self == Lock :: Level1 } # [doc = "LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written"] # [inline (always)] pub fn is_level2 (& self) -> bool { * self == Lock :: Level2 } # [doc = "LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written"] # [inline (always)] pub fn is_level3 (& self) -> bool { * self == Lock :: Level3 } } # [doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Lock , crate :: Safe > ; impl < 'a , REG > LockW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "No bit is write protected"] # [inline (always)] pub fn off (self) -> & 'a mut crate :: W < REG > { self . variant (Lock :: Off) } # [doc = "Any bits except MOE, OSSR, OSSI and LOCK in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register can no longer be written"] # [inline (always)] pub fn level1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lock :: Level1) } # [doc = "LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written"] # [inline (always)] pub fn level2 (self) -> & 'a mut crate :: W < REG > { self . variant (Lock :: Level2) } # [doc = "LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written"] # [inline (always)] pub fn level3 (self) -> & 'a mut crate :: W < REG > { self . variant (Lock :: Level3) } } # [doc = "Off-state selection for Idle mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ossi { # [doc = "0: When inactive, OC/OCN outputs are disabled"] HiZ = 0 , # [doc = "1: When inactive, OC/OCN outputs are forced to idle level"] IdleLevel = 1 , } impl From < Ossi > for bool { # [inline (always)] fn from (variant : Ossi) -> Self { variant as u8 != 0 } } # [doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader < Ossi > ; impl OssiR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ossi { match self . bits { false => Ossi :: HiZ , true => Ossi :: IdleLevel , } } # [doc = "When inactive, OC/OCN outputs are disabled"] # [inline (always)] pub fn is_hi_z (& self) -> bool { * self == Ossi :: HiZ } # [doc = "When inactive, OC/OCN outputs are forced to idle level"] # [inline (always)] pub fn is_idle_level (& self) -> bool { * self == Ossi :: IdleLevel } } # [doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG , Ossi > ; impl < 'a , REG > OssiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "When inactive, OC/OCN outputs are disabled"] # [inline (always)] pub fn hi_z (self) -> & 'a mut crate :: W < REG > { self . variant (Ossi :: HiZ) } # [doc = "When inactive, OC/OCN outputs are forced to idle level"] # [inline (always)] pub fn idle_level (self) -> & 'a mut crate :: W < REG > { self . variant (Ossi :: IdleLevel) } } # [doc = "Off-state selection for Run mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Ossr { # [doc = "0: When inactive, OC/OCN outputs are disabled"] HiZ = 0 , # [doc = "1: When inactive, OC/OCN outputs are enabled with their inactive level"] IdleLevel = 1 , } impl From < Ossr > for bool { # [inline (always)] fn from (variant : Ossr) -> Self { variant as u8 != 0 } } # [doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader < Ossr > ; impl OssrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Ossr { match self . bits { false => Ossr :: HiZ , true => Ossr :: IdleLevel , } } # [doc = "When inactive, OC/OCN outputs are disabled"] # [inline (always)] pub fn is_hi_z (& self) -> bool { * self == Ossr :: HiZ } # [doc = "When inactive, OC/OCN outputs are enabled with their inactive level"] # [inline (always)] pub fn is_idle_level (& self) -> bool { * self == Ossr :: IdleLevel } } # [doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG , Ossr > ; impl < 'a , REG > OssrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "When inactive, OC/OCN outputs are disabled"] # [inline (always)] pub fn hi_z (self) -> & 'a mut crate :: W < REG > { self . variant (Ossr :: HiZ) } # [doc = "When inactive, OC/OCN outputs are enabled with their inactive level"] # [inline (always)] pub fn idle_level (self) -> & 'a mut crate :: W < REG > { self . variant (Ossr :: IdleLevel) } } # [doc = "Break enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bke { # [doc = "0: Break function x disabled"] Disabled = 0 , # [doc = "1: Break function x enabled"] Enabled = 1 , } impl From < Bke > for bool { # [inline (always)] fn from (variant : Bke) -> Self { variant as u8 != 0 } } # [doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader < Bke > ; impl BkeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bke { match self . bits { false => Bke :: Disabled , true => Bke :: Enabled , } } # [doc = "Break function x disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Bke :: Disabled } # [doc = "Break function x enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Bke :: Enabled } } # [doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG , Bke > ; impl < 'a , REG > BkeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Break function x disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bke :: Disabled) } # [doc = "Break function x enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Bke :: Enabled) } } # [doc = "Break polarity\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Bkp { # [doc = "0: Break input BRKx is active low"] ActiveLow = 0 , # [doc = "1: Break input BRKx is active high"] ActiveHigh = 1 , } impl From < Bkp > for bool { # [inline (always)] fn from (variant : Bkp) -> Self { variant as u8 != 0 } } # [doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader < Bkp > ; impl BkpR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Bkp { match self . bits { false => Bkp :: ActiveLow , true => Bkp :: ActiveHigh , } } # [doc = "Break input BRKx is active low"] # [inline (always)] pub fn is_active_low (& self) -> bool { * self == Bkp :: ActiveLow } # [doc = "Break input BRKx is active high"] # [inline (always)] pub fn is_active_high (& self) -> bool { * self == Bkp :: ActiveHigh } } # [doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG , Bkp > ; impl < 'a , REG > BkpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Break input BRKx is active low"] # [inline (always)] pub fn active_low (self) -> & 'a mut crate :: W < REG > { self . variant (Bkp :: ActiveLow) } # [doc = "Break input BRKx is active high"] # [inline (always)] pub fn active_high (self) -> & 'a mut crate :: W < REG > { self . variant (Bkp :: ActiveHigh) } } # [doc = "Automatic output enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Aoe { # [doc = "0: MOE can be set only by software"] Manual = 0 , # [doc = "1: MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)"] Automatic = 1 , } impl From < Aoe > for bool { # [inline (always)] fn from (variant : Aoe) -> Self { variant as u8 != 0 } } # [doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader < Aoe > ; impl AoeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Aoe { match self . bits { false => Aoe :: Manual , true => Aoe :: Automatic , } } # [doc = "MOE can be set only by software"] # [inline (always)] pub fn is_manual (& self) -> bool { * self == Aoe :: Manual } # [doc = "MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)"] # [inline (always)] pub fn is_automatic (& self) -> bool { * self == Aoe :: Automatic } } # [doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG , Aoe > ; impl < 'a , REG > AoeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "MOE can be set only by software"] # [inline (always)] pub fn manual (self) -> & 'a mut crate :: W < REG > { self . variant (Aoe :: Manual) } # [doc = "MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)"] # [inline (always)] pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (Aoe :: Automatic) } } # [doc = "Main output enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Moe { # [doc = "0: OC/OCN are disabled or forced idle depending on OSSI"] DisabledIdle = 0 , # [doc = "1: OC/OCN are enabled if CCxE/CCxNE are set"] Enabled = 1 , } impl From < Moe > for bool { # [inline (always)] fn from (variant : Moe) -> Self { variant as u8 != 0 } } # [doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader < Moe > ; impl MoeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Moe { match self . bits { false => Moe :: DisabledIdle , true => Moe :: Enabled , } } # [doc = "OC/OCN are disabled or forced idle depending on OSSI"] # [inline (always)] pub fn is_disabled_idle (& self) -> bool { * self == Moe :: DisabledIdle } # [doc = "OC/OCN are enabled if CCxE/CCxNE are set"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Moe :: Enabled } } # [doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG , Moe > ; impl < 'a , REG > MoeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OC/OCN are disabled or forced idle depending on OSSI"] # [inline (always)] pub fn disabled_idle (self) -> & 'a mut crate :: W < REG > { self . variant (Moe :: DisabledIdle) } # [doc = "OC/OCN are enabled if CCxE/CCxNE are set"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Moe :: Enabled) } } impl R { # [doc = "Bits 0:7 - Dead-time generator setup"] # [inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:9 - Lock configuration"] # [inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bit 10 - Off-state selection for Idle mode"] # [inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Off-state selection for Run mode"] # [inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Break enable"] # [inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Break polarity"] # [inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Automatic output enable"] # [inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Main output enable"] # [inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:7 - Dead-time generator setup"] # [inline (always)] pub fn dtg (& mut self) -> DtgW < BdtrSpec > { DtgW :: new (self , 0) } # [doc = "Bits 8:9 - Lock configuration"] # [inline (always)] pub fn lock (& mut self) -> LockW < BdtrSpec > { LockW :: new (self , 8) } # [doc = "Bit 10 - Off-state selection for Idle mode"] # [inline (always)] pub fn ossi (& mut self) -> OssiW < BdtrSpec > { OssiW :: new (self , 10) } # [doc = "Bit 11 - Off-state selection for Run mode"] # [inline (always)] pub fn ossr (& mut self) -> OssrW < BdtrSpec > { OssrW :: new (self , 11) } # [doc = "Bit 12 - Break enable"] # [inline (always)] pub fn bke (& mut self) -> BkeW < BdtrSpec > { BkeW :: new (self , 12) } # [doc = "Bit 13 - Break polarity"] # [inline (always)] pub fn bkp (& mut self) -> BkpW < BdtrSpec > { BkpW :: new (self , 13) } # [doc = "Bit 14 - Automatic output enable"] # [inline (always)] pub fn aoe (& mut self) -> AoeW < BdtrSpec > { AoeW :: new (self , 14) } # [doc = "Bit 15 - Main output enable"] # [inline (always)] pub fn moe (& mut self) -> MoeW < BdtrSpec > { MoeW :: new (self , 15) } } # [doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { } # [doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { }
# [doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ; # [doc = "Counter enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Cen { # [doc = "0: Counter disabled"] Disabled = 0 , # [doc = "1: Counter enabled"] Enabled = 1 , } impl From < Cen > for bool { # [inline (always)] fn from (variant : Cen) -> Self { variant as u8 != 0 } } # [doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader < Cen > ; impl CenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cen { match self . bits { false => Cen :: Disabled , true => Cen :: Enabled , } } # [doc = "Counter disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Cen :: Disabled } # [doc = "Counter enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Cen :: Enabled } } # [doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG , Cen > ; impl < 'a , REG > CenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counter disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cen :: Disabled) } # [doc = "Counter enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cen :: Enabled) } } # [doc = "Update disable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Udis { # [doc = "0: Update event enabled"] Enabled = 0 , # [doc = "1: Update event disabled"] Disabled = 1 , } impl From < Udis > for bool { # [inline (always)] fn from (variant : Udis) -> Self { variant as u8 != 0 } } # [doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader < Udis > ; impl UdisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Udis { match self . bits { false => Udis :: Enabled , true => Udis :: Disabled , } } # [doc = "Update event enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Udis :: Enabled } # [doc = "Update event disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Udis :: Disabled } } # [doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Udis > ; impl < 'a , REG > UdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Update event enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Udis :: Enabled) } # [doc = "Update event disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Udis :: Disabled) } } # [doc = "Update request source\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Urs { # [doc = "0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] AnyEvent = 0 , # [doc = "1: Only counter overflow/underflow generates an update interrupt or DMA request"] CounterOnly = 1 , } impl From < Urs > for bool { # [inline (always)] fn from (variant : Urs) -> Self { variant as u8 != 0 } } # [doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader < Urs > ; impl UrsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Urs { match self . bits { false => Urs :: AnyEvent , true => Urs :: CounterOnly , } } # [doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] # [inline (always)] pub fn is_any_event (& self) -> bool { * self == Urs :: AnyEvent } # [doc = "Only counter overflow/underflow generates an update interrupt or DMA request"] # [inline (always)] pub fn is_counter_only (& self) -> bool { * self == Urs :: CounterOnly } } # [doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG , Urs > ; impl < 'a , REG > UrsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"] # [inline (always)] pub fn any_event (self) -> & 'a mut crate :: W < REG > { self . variant (Urs :: AnyEvent) } # [doc = "Only counter overflow/underflow generates an update interrupt or DMA request"] # [inline (always)] pub fn counter_only (self) -> & 'a mut crate :: W < REG > { self . variant (Urs :: CounterOnly) } } # [doc = "One-pulse mode\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Opm { # [doc = "0: Counter is not stopped at update event"] Disabled = 0 , # [doc = "1: Counter stops counting at the next update event (clearing the CEN bit)"] Enabled = 1 , } impl From < Opm > for bool { # [inline (always)] fn from (variant : Opm) -> Self { variant as u8 != 0 } } # [doc = "Field `OPM` reader - One-pulse mode"] pub type OpmR = crate :: BitReader < Opm > ; impl OpmR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Opm { match self . bits { false => Opm :: Disabled , true => Opm :: Enabled , } } # [doc = "Counter is not stopped at update event"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Opm :: Disabled } # [doc = "Counter stops counting at the next update event (clearing the CEN bit)"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Opm :: Enabled } } # [doc = "Field `OPM` writer - One-pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG , Opm > ; impl < 'a , REG > OpmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counter is not stopped at update event"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Opm :: Disabled) } # [doc = "Counter stops counting at the next update event (clearing the CEN bit)"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Opm :: Enabled) } } # [doc = "Direction\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Dir { # [doc = "0: Counter used as upcounter"] Up = 0 , # [doc = "1: Counter used as downcounter"] Down = 1 , } impl From < Dir > for bool { # [inline (always)] fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Dir { match self . bits { false => Dir :: Up , true => Dir :: Down , } } # [doc = "Counter used as upcounter"] # [inline (always)] pub fn is_up (& self) -> bool { * self == Dir :: Up } # [doc = "Counter used as downcounter"] # [inline (always)] pub fn is_down (& self) -> bool { * self == Dir :: Down } } # [doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG , Dir > ; impl < 'a , REG > DirW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Counter used as upcounter"] # [inline (always)] pub fn up (self) -> & 'a mut crate :: W < REG > { self . variant (Dir :: Up) } # [doc = "Counter used as downcounter"] # [inline (always)] pub fn down (self) -> & 'a mut crate :: W < REG > { self . variant (Dir :: Down) } } # [doc = "Center-aligned mode selection\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Cms { # [doc = "0: The counter counts up or down depending on the direction bit"] EdgeAligned = 0 , # [doc = "1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."] CenterAligned1 = 1 , # [doc = "2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."] CenterAligned2 = 2 , # [doc = "3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."] CenterAligned3 = 3 , } impl From < Cms > for u8 { # [inline (always)] fn from (variant : Cms) -> Self { variant as _ } } impl crate :: FieldSpec for Cms { type Ux = u8 ; } impl crate :: IsEnum for Cms { } # [doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader < Cms > ; impl CmsR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Cms { match self . bits { 0 => Cms :: EdgeAligned , 1 => Cms :: CenterAligned1 , 2 => Cms :: CenterAligned2 , 3 => Cms :: CenterAligned3 , _ => unreachable ! () , } } # [doc = "The counter counts up or down depending on the direction bit"] # [inline (always)] pub fn is_edge_aligned (& self) -> bool { * self == Cms :: EdgeAligned } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."] # [inline (always)] pub fn is_center_aligned1 (& self) -> bool { * self == Cms :: CenterAligned1 } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."] # [inline (always)] pub fn is_center_aligned2 (& self) -> bool { * self == Cms :: CenterAligned2 } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."] # [inline (always)] pub fn is_center_aligned3 (& self) -> bool { * self == Cms :: CenterAligned3 } } # [doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Cms , crate :: Safe > ; impl < 'a , REG > CmsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "The counter counts up or down depending on the direction bit"] # [inline (always)] pub fn edge_aligned (self) -> & 'a mut crate :: W < REG > { self . variant (Cms :: EdgeAligned) } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down."] # [inline (always)] pub fn center_aligned1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cms :: CenterAligned1) } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up."] # [inline (always)] pub fn center_aligned2 (self) -> & 'a mut crate :: W < REG > { self . variant (Cms :: CenterAligned2) } # [doc = "The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down."] # [inline (always)] pub fn center_aligned3 (self) -> & 'a mut crate :: W < REG > { self . variant (Cms :: CenterAligned3) } } # [doc = "Auto-reload preload enable\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Arpe { # [doc = "0: TIMx_APRR register is not buffered"] Disabled = 0 , # [doc = "1: TIMx_APRR register is buffered"] Enabled = 1 , } impl From < Arpe > for bool { # [inline (always)] fn from (variant : Arpe) -> Self { variant as u8 != 0 } } # [doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader < Arpe > ; impl ArpeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Arpe { match self . bits { false => Arpe :: Disabled , true => Arpe :: Enabled , } } # [doc = "TIMx_APRR register is not buffered"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Arpe :: Disabled } # [doc = "TIMx_APRR register is buffered"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Arpe :: Enabled } } # [doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG , Arpe > ; impl < 'a , REG > ArpeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TIMx_APRR register is not buffered"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Arpe :: Disabled) } # [doc = "TIMx_APRR register is buffered"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Arpe :: Enabled) } } # [doc = "Clock division\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Ckd { # [doc = "0: t_DTS = t_CK_INT"] Div1 = 0 , # [doc = "1: t_DTS = 2 × t_CK_INT"] Div2 = 1 , # [doc = "2: t_DTS = 4 × t_CK_INT"] Div4 = 2 , } impl From < Ckd > for u8 { # [inline (always)] fn from (variant : Ckd) -> Self { variant as _ } } impl crate :: FieldSpec for Ckd { type Ux = u8 ; } impl crate :: IsEnum for Ckd { } # [doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader < Ckd > ; impl CkdR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Option < Ckd > { match self . bits { 0 => Some (Ckd :: Div1) , 1 => Some (Ckd :: Div2) , 2 => Some (Ckd :: Div4) , _ => None , } } # [doc = "t_DTS = t_CK_INT"] # [inline (always)] pub fn is_div1 (& self) -> bool { * self == Ckd :: Div1 } # [doc = "t_DTS = 2 × t_CK_INT"] # [inline (always)] pub fn is_div2 (& self) -> bool { * self == Ckd :: Div2 } # [doc = "t_DTS = 4 × t_CK_INT"] # [inline (always)] pub fn is_div4 (& self) -> bool { * self == Ckd :: Div4 } } # [doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckd > ; impl < 'a , REG > CkdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "t_DTS = t_CK_INT"] # [inline (always)] pub fn div1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ckd :: Div1) } # [doc = "t_DTS = 2 × t_CK_INT"] # [inline (always)] pub fn div2 (self) -> & 'a mut crate :: W < REG > { self . variant (Ckd :: Div2) } # [doc = "t_DTS = 4 × t_CK_INT"] # [inline (always)] pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (Ckd :: Div4) } } impl R { # [doc = "Bit 0 - Counter enable"] # [inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Update disable"] # [inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Update request source"] # [inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - One-pulse mode"] # [inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Direction"] # [inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Center-aligned mode selection"] # [inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Auto-reload preload enable"] # [inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Clock division"] # [inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter enable"] # [inline (always)] pub fn cen (& mut self) -> CenW < Cr1Spec > { CenW :: new (self , 0) } # [doc = "Bit 1 - Update disable"] # [inline (always)] pub fn udis (& mut self) -> UdisW < Cr1Spec > { UdisW :: new (self , 1) } # [doc = "Bit 2 - Update request source"] # [inline (always)] pub fn urs (& mut self) -> UrsW < Cr1Spec > { UrsW :: new (self , 2) } # [doc = "Bit 3 - One-pulse mode"] # [inline (always)] pub fn opm (& mut self) -> OpmW < Cr1Spec > { OpmW :: new (self , 3) } # [doc = "Bit 4 - Direction"] # [inline (always)] pub fn dir (& mut self) -> DirW < Cr1Spec > { DirW :: new (self , 4) } # [doc = "Bits 5:6 - Center-aligned mode selection"] # [inline (always)] pub fn cms (& mut self) -> CmsW < Cr1Spec > { CmsW :: new (self , 5) } # [doc = "Bit 7 - Auto-reload preload enable"] # [inline (always)] pub fn arpe (& mut self) -> ArpeW < Cr1Spec > { ArpeW :: new (self , 7) } # [doc = "Bits 8:9 - Clock division"] # [inline (always)] pub fn ckd (& mut self) -> CkdW < Cr1Spec > { CkdW :: new (self , 8) } } # [doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { }
# [doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ; # [doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ; # [doc = "Capture/Compare %s selection"] pub use super :: ccmr1_output :: Cc1s as Cc1s ; # [doc = "Field `CCS(3-4)` reader - Capture/Compare %s selection"] pub use super :: ccmr1_output :: CcsR as CcsR ; # [doc = "Field `CCS(3-4)` writer - Capture/Compare %s selection"] pub use super :: ccmr1_output :: CcsW as CcsW ; # [doc = "Output compare %s fast enable"] pub use super :: ccmr1_output :: Oc1fe as Oc1fe ; # [doc = "Field `OCFE(3-4)` reader - Output compare %s fast enable"] pub use super :: ccmr1_output :: OcfeR as OcfeR ; # [doc = "Field `OCFE(3-4)` writer - Output compare %s fast enable"] pub use super :: ccmr1_output :: OcfeW as OcfeW ; # [doc = "Output compare %s preload enable"] pub use super :: ccmr1_output :: Oc1pe as Oc1pe ; # [doc = "Field `OCPE(3-4)` reader - Output compare %s preload enable"] pub use super :: ccmr1_output :: OcpeR as OcpeR ; # [doc = "Field `OCPE(3-4)` writer - Output compare %s preload enable"] pub use super :: ccmr1_output :: OcpeW as OcpeW ; # [doc = "Output compare %s mode"] pub use super :: ccmr1_output :: Oc1m as Oc1m ; # [doc = "Field `OCM(3-4)` reader - Output compare %s mode"] pub use super :: ccmr1_output :: OcmR as OcmR ; # [doc = "Field `OCM(3-4)` writer - Output compare %s mode"] pub use super :: ccmr1_output :: OcmW as OcmW ; # [doc = "Output compare %s clear enable"] pub use super :: ccmr1_output :: Oc1ce as Oc1ce ; # [doc = "Field `OCCE(3-4)` reader - Output compare %s clear enable"] pub use super :: ccmr1_output :: OcceR as OcceR ; # [doc = "Field `OCCE(3-4)` writer - Output compare %s clear enable"] pub use super :: ccmr1_output :: OcceW as OcceW ; impl R { # [doc = "Capture/Compare (3-4) selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC3S` field.</div>"] # [inline (always)] pub fn ccs (& self , n : u8) -> CcsR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; CcsR :: new (((self . bits >> (n * 8)) & 3) as u8) } # [doc = "Iterator for array of:"] # [doc = "Capture/Compare (3-4) selection"] # [inline (always)] pub fn ccs_iter (& self) -> impl Iterator < Item = CcsR > + '_ { (0 .. 2) . map (move | n | CcsR :: new (((self . bits >> (n * 8)) & 3) as u8)) } # [doc = "Bits 0:1 - Capture/Compare 3 selection"] # [inline (always)] pub fn cc3s (& self) -> CcsR { CcsR :: new ((self . bits & 3) as u8) } # [doc = "Bits 8:9 - Capture/Compare 4 selection"] # [inline (always)] pub fn cc4s (& self) -> CcsR { CcsR :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Output compare (3-4) fast enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3FE` field.</div>"] # [inline (always)] pub fn ocfe (& self , n : u8) -> OcfeR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcfeR :: new (((self . bits >> (n * 8 + 2)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Output compare (3-4) fast enable"] # [inline (always)] pub fn ocfe_iter (& self) -> impl Iterator < Item = OcfeR > + '_ { (0 .. 2) . map (move | n | OcfeR :: new (((self . bits >> (n * 8 + 2)) & 1) != 0)) } # [doc = "Bit 2 - Output compare 3 fast enable"] # [inline (always)] pub fn oc3fe (& self) -> OcfeR { OcfeR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 10 - Output compare 4 fast enable"] # [inline (always)] pub fn oc4fe (& self) -> OcfeR { OcfeR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Output compare (3-4) preload enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3PE` field.</div>"] # [inline (always)] pub fn ocpe (& self , n : u8) -> OcpeR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcpeR :: new (((self . bits >> (n * 8 + 3)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Output compare (3-4) preload enable"] # [inline (always)] pub fn ocpe_iter (& self) -> impl Iterator < Item = OcpeR > + '_ { (0 .. 2) . map (move | n | OcpeR :: new (((self . bits >> (n * 8 + 3)) & 1) != 0)) } # [doc = "Bit 3 - Output compare 3 preload enable"] # [inline (always)] pub fn oc3pe (& self) -> OcpeR { OcpeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 11 - Output compare 4 preload enable"] # [inline (always)] pub fn oc4pe (& self) -> OcpeR { OcpeR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Output compare (3-4) mode"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3M` field.</div>"] # [inline (always)] pub fn ocm (& self , n : u8) -> OcmR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcmR :: new (((self . bits >> (n * 8 + 4)) & 7) as u8) } # [doc = "Iterator for array of:"] # [doc = "Output compare (3-4) mode"] # [inline (always)] pub fn ocm_iter (& self) -> impl Iterator < Item = OcmR > + '_ { (0 .. 2) . map (move | n | OcmR :: new (((self . bits >> (n * 8 + 4)) & 7) as u8)) } # [doc = "Bits 4:6 - Output compare 3 mode"] # [inline (always)] pub fn oc3m (& self) -> OcmR { OcmR :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bits 12:14 - Output compare 4 mode"] # [inline (always)] pub fn oc4m (& self) -> OcmR { OcmR :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Output compare (3-4) clear enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3CE` field.</div>"] # [inline (always)] pub fn occe (& self , n : u8) -> OcceR { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcceR :: new (((self . bits >> (n * 8 + 7)) & 1) != 0) } # [doc = "Iterator for array of:"] # [doc = "Output compare (3-4) clear enable"] # [inline (always)] pub fn occe_iter (& self) -> impl Iterator < Item = OcceR > + '_ { (0 .. 2) . map (move | n | OcceR :: new (((self . bits >> (n * 8 + 7)) & 1) != 0)) } # [doc = "Bit 7 - Output compare 3 clear enable"] # [inline (always)] pub fn oc3ce (& self) -> OcceR { OcceR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 15 - Output compare 4 clear enable"] # [inline (always)] pub fn oc4ce (& self) -> OcceR { OcceR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Capture/Compare (3-4) selection"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `CC3S` field.</div>"] # [inline (always)] pub fn ccs (& mut self , n : u8) -> CcsW < Ccmr2OutputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; CcsW :: new (self , n * 8) } # [doc = "Bits 0:1 - Capture/Compare 3 selection"] # [inline (always)] pub fn cc3s (& mut self) -> CcsW < Ccmr2OutputSpec > { CcsW :: new (self , 0) } # [doc = "Bits 8:9 - Capture/Compare 4 selection"] # [inline (always)] pub fn cc4s (& mut self) -> CcsW < Ccmr2OutputSpec > { CcsW :: new (self , 8) } # [doc = "Output compare (3-4) fast enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3FE` field.</div>"] # [inline (always)] pub fn ocfe (& mut self , n : u8) -> OcfeW < Ccmr2OutputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcfeW :: new (self , n * 8 + 2) } # [doc = "Bit 2 - Output compare 3 fast enable"] # [inline (always)] pub fn oc3fe (& mut self) -> OcfeW < Ccmr2OutputSpec > { OcfeW :: new (self , 2) } # [doc = "Bit 10 - Output compare 4 fast enable"] # [inline (always)] pub fn oc4fe (& mut self) -> OcfeW < Ccmr2OutputSpec > { OcfeW :: new (self , 10) } # [doc = "Output compare (3-4) preload enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3PE` field.</div>"] # [inline (always)] pub fn ocpe (& mut self , n : u8) -> OcpeW < Ccmr2OutputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcpeW :: new (self , n * 8 + 3) } # [doc = "Bit 3 - Output compare 3 preload enable"] # [inline (always)] pub fn oc3pe (& mut self) -> OcpeW < Ccmr2OutputSpec > { OcpeW :: new (self , 3) } # [doc = "Bit 11 - Output compare 4 preload enable"] # [inline (always)] pub fn oc4pe (& mut self) -> OcpeW < Ccmr2OutputSpec > { OcpeW :: new (self , 11) } # [doc = "Output compare (3-4) mode"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3M` field.</div>"] # [inline (always)] pub fn ocm (& mut self , n : u8) -> OcmW < Ccmr2OutputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcmW :: new (self , n * 8 + 4) } # [doc = "Bits 4:6 - Output compare 3 mode"] # [inline (always)] pub fn oc3m (& mut self) -> OcmW < Ccmr2OutputSpec > { OcmW :: new (self , 4) } # [doc = "Bits 12:14 - Output compare 4 mode"] # [inline (always)] pub fn oc4m (& mut self) -> OcmW < Ccmr2OutputSpec > { OcmW :: new (self , 12) } # [doc = "Output compare (3-4) clear enable"] # [doc = ""] # [doc = "<div class=\"warning\">`n` is number of field in register. `n == 0` corresponds to `OC3CE` field.</div>"] # [inline (always)] pub fn occe (& mut self , n : u8) -> OcceW < Ccmr2OutputSpec > { # [allow (clippy :: no_effect)] [() ; 2] [n as usize] ; OcceW :: new (self , n * 8 + 7) } # [doc = "Bit 7 - Output compare 3 clear enable"] # [inline (always)] pub fn oc3ce (& mut self) -> OcceW < Ccmr2OutputSpec > { OcceW :: new (self , 7) } # [doc = "Bit 15 - Output compare 4 clear enable"] # [inline (always)] pub fn oc4ce (& mut self) -> OcceW < Ccmr2OutputSpec > { OcceW :: new (self , 15) } } # [doc = "capture/compare mode register 2 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { } # [doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { }